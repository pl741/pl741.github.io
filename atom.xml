<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木木的博客</title>
  
  <subtitle>木木的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://pl741.github.io/"/>
  <updated>2020-03-31T06:29:40.661Z</updated>
  <id>http://pl741.github.io/</id>
  
  <author>
    <name>木木</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法题</title>
    <link href="http://pl741.github.io/2020/03/24/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://pl741.github.io/2020/03/24/算法题/</id>
    <published>2020-03-24T01:43:48.000Z</published>
    <updated>2020-03-31T06:29:40.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法题1：获胜一方的三张牌的点数最大和-2020-3-24"><a href="#算法题1：获胜一方的三张牌的点数最大和-2020-3-24" class="headerlink" title="算法题1：获胜一方的三张牌的点数最大和 (2020/3/24)"></a>算法题1：获胜一方的三张牌的点数最大和 (2020/3/24)</h3><p>输入：第行仅包含一个正整数n，代表双方掌握的牌的数量，(1&lt;=n&lt;=20000)接下来有2行，每行有n个数字，数字的范围在1 ~ 10^9以内，分别代表双方可选的n张牌。</p><p>输出：仅包含个正警数， 即获胜的一方三张牌的最大牌型的点数之和， 当然是可能有平局的，此时答家也是唯一的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">L1 = list(map(int, input().split(<span class="string">" "</span>)))</span><br><span class="line">L2 = list(map(int, input().split(<span class="string">" "</span>)))</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WinMaxValue</span><span class="params">(self, n, FirstList, SecondList)</span>:</span></span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">firstmax = self.MaxValue(n, FirstList)</span><br><span class="line">secondmax = self.MaxValue(n, SecondList)</span><br><span class="line"><span class="keyword">return</span> max(firstmax, secondmax)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MaxValue</span><span class="params">(self, n, N_list)</span>:</span></span><br><span class="line">heap = []</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="number">3</span>:</span><br><span class="line">heapq.heappush(heap, N_list[index])</span><br><span class="line">index += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> index &lt; n:</span><br><span class="line">heap_min = heap[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> heap_min &lt; N_list[index]:</span><br><span class="line">heapq.heappushpop(heap, N_list[index])</span><br><span class="line">index += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> sum(heap)</span><br></pre></td></tr></table></figure><h3 id="算法题2：LeetCode-17-按摩师-2020-3-24"><a href="#算法题2：LeetCode-17-按摩师-2020-3-24" class="headerlink" title="算法题2：LeetCode  17.按摩师 (2020/3/24)"></a>算法题2：LeetCode  17.<a href="https://leetcode-cn.com/problems/the-masseuse-lcci" target="_blank" rel="noopener">按摩师</a> (2020/3/24)</h3><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">massage</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> nums == <span class="literal">None</span> <span class="keyword">or</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    p, p_1, p_2 = nums[<span class="number">-3</span>]+nums[<span class="number">-1</span>], nums[<span class="number">-2</span>], nums[<span class="number">-1</span>]</span><br><span class="line">    index = len(nums) - <span class="number">4</span></span><br><span class="line">    <span class="keyword">while</span> index &gt;= <span class="number">0</span>:</span><br><span class="line">    temp = max(p_1, p_2) + nums[index]</span><br><span class="line">    p_2 = p_1</span><br><span class="line">    p_1 = p</span><br><span class="line">    p = temp</span><br><span class="line">    index -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max(p, p_1)</span><br></pre></td></tr></table></figure><h3 id="算法题3：LeetCode-892-三维形体的表面积-2020-3-25"><a href="#算法题3：LeetCode-892-三维形体的表面积-2020-3-25" class="headerlink" title="算法题3：LeetCode 892. 三维形体的表面积 (2020/3/25)"></a>算法题3：LeetCode 892. <a href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes/" target="_blank" rel="noopener">三维形体的表面积</a> (2020/3/25)</h3><p>在 $N <em> N$ 的网格上，我们放置一些 $1 </em> 1 * 1$  的立方体。每个值 $v = grid[i][j]$ 表示 v 个正方体叠放在对应单元格 $(i, j)$ 上。请你返回最终形体的表面积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">surfaceArea</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> grid == <span class="literal">None</span> <span class="keyword">or</span> len(grid) == <span class="number">0</span> <span class="keyword">or</span> len(grid[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                dp = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> row &gt; <span class="number">0</span>: dp += min(grid[row][col], grid[row<span class="number">-1</span>][col])</span><br><span class="line">                <span class="keyword">if</span> row &lt; len(grid) - <span class="number">1</span>: dp += min(grid[row][col], grid[row+<span class="number">1</span>][col])</span><br><span class="line">                <span class="keyword">if</span> col &gt; <span class="number">0</span>: dp += min(grid[row][col], grid[row][col<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">if</span> col &lt; len(grid[<span class="number">0</span>]) - <span class="number">1</span>: dp += min(grid[row][col], grid[row][col+<span class="number">1</span>])</span><br><span class="line">                area += self.Area(grid[row][col]) - dp</span><br><span class="line">        <span class="keyword">return</span> area</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Area</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">2</span> * (<span class="number">2</span> * num + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="算法题4：A获奖的概率-2020-3-25"><a href="#算法题4：A获奖的概率-2020-3-25" class="headerlink" title="算法题4：A获奖的概率 (2020/3/25)"></a>算法题4：A获奖的概率 (2020/3/25)</h3><p>有一个抽奖箱，里面有 $n$ 张中将票，$m$ 张不中奖票。A和B轮流从中那个抽一张奖票出来。有人抽到中奖票就结束抽奖过程，抽到中奖票的人胜利。抽过的奖票会被丢弃。其次，B每次抽后，会再次抽取一张票并丢弃掉（这张票中奖不算B胜利）。现在，A先抽，请问A的胜率，保留4位小数后输出。如果两人到最后也没有抽到中奖票算作B胜利。<br>原文链接：<a href="https://blog.csdn.net/sinat_27990891/article/details/105085392" target="_blank" rel="noopener">https://blog.csdn.net/sinat_27990891/article/details/105085392</a></p><pre><code>样例输入: 1 3  样例输出:0.5000解释：如果A第一轮抽到中奖票，A胜利，概率0.25。如果A第二轮抽到中奖票，情况为A第一轮没有抽到中奖票，B也没有抽到中奖票，并且B丢弃掉的奖票也不是中奖票。概率位3/4 * 2/3 * 1/2 = 0.25。综上，中奖率为0.5。样例输入: 2 3  样例输出:0.6000</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算法题5：LeetCode-820-单词的压缩编码-2020-3-28-★★★"><a href="#算法题5：LeetCode-820-单词的压缩编码-2020-3-28-★★★" class="headerlink" title="算法题5：LeetCode 820. 单词的压缩编码 (2020/3/28) ★★★"></a>算法题5：LeetCode <a href="https://leetcode-cn.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">820. 单词的压缩编码</a> (2020/3/28) ★★★</h3><p>给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目标就是保留所有不是其他单词后缀的单词，最后的结果就是这些单词长度加一的总和，因为每个单词编码后后面还需要跟一个 # 符号。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumLengthEncoding</span><span class="params">(self, words: List[str])</span> -&gt; int:</span></span><br><span class="line">        good = set(words)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, len(word)):</span><br><span class="line">                good.discard(word[k:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(len(word) + <span class="number">1</span> <span class="keyword">for</span> word <span class="keyword">in</span> good)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典树的叶子节点（没有孩子的节点）就代表没有后缀的单词，统计叶子节点代表的单词长度加一的和即为我们要的答案。</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumLengthEncoding</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        words = list(set(words)) <span class="comment">#remove duplicates</span></span><br><span class="line">        Trie = <span class="keyword">lambda</span>: collections.defaultdict(Trie)</span><br><span class="line">        trie = Trie()</span><br><span class="line">        <span class="comment">#reduce(..., S, trie) is trie[S[0]][S[1]][S[2]][...][S[S.length - 1]]</span></span><br><span class="line">        <span class="comment"># reduce() 函数会对参数序列中元素进行累积。</span></span><br><span class="line">        <span class="comment"># 函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</span></span><br><span class="line">        nodes = [reduce(dict.__getitem__, word[::<span class="number">-1</span>], trie)</span><br><span class="line">                 <span class="keyword">for</span> word <span class="keyword">in</span> words]</span><br><span class="line">        <span class="comment">#Add word to the answer if it's node has no neighbors</span></span><br><span class="line">        <span class="keyword">return</span> sum(len(word) + <span class="number">1</span></span><br><span class="line">                   <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(words)</span><br><span class="line">                   <span class="keyword">if</span> len(nodes[i]) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="算法题6-LeetCode-1162-地图分析-2020-3-29-BFS-动态规划-★★★"><a href="#算法题6-LeetCode-1162-地图分析-2020-3-29-BFS-动态规划-★★★" class="headerlink" title="算法题6.  LeetCode. 1162. 地图分析 (2020/3/29) BFS 动态规划 ★★★"></a>算法题6.  LeetCode. <a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">1162. 地图分析</a> (2020/3/29) BFS 动态规划 ★★★</h3><p>你现在手里有一份大小为 $N * N$ 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：$(x_{0}, y_{0})$ 和 $(x_{1}, y_{1})$ 这两个区域之间的距离是 $|x_{0} - x_{1}| + |y_{0} - y_{1}|$ 。如果我们的地图上只有陆地或者海洋，请返回 -1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDistance</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        steps = <span class="number">-1</span></span><br><span class="line">        queue = [(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">for</span> j <span class="keyword">in</span> range(n) <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> len(queue) == <span class="number">0</span> <span class="keyword">or</span> len(queue) == n ** <span class="number">2</span>: <span class="keyword">return</span> steps</span><br><span class="line">        <span class="keyword">while</span> len(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)): </span><br><span class="line">                x, y = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> xi, yj <span class="keyword">in</span> [(x + <span class="number">1</span>, y), (x - <span class="number">1</span>, y), (x, y + <span class="number">1</span>), (x, y - <span class="number">1</span>)]:</span><br><span class="line">                    <span class="keyword">if</span> xi &gt;= <span class="number">0</span> <span class="keyword">and</span> xi &lt; n <span class="keyword">and</span> yj &gt;= <span class="number">0</span> <span class="keyword">and</span> yj &lt; n <span class="keyword">and</span> grid[xi][yj] == <span class="number">0</span>:</span><br><span class="line">                        queue.append((xi, yj))</span><br><span class="line">                        grid[xi][yj] = <span class="number">-1</span></span><br><span class="line">            steps += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> steps</span><br></pre></td></tr></table></figure><h3 id="算法题7-数字游戏-2020-3-30-★★★"><a href="#算法题7-数字游戏-2020-3-30-★★★" class="headerlink" title="算法题7.   数字游戏 (2020/3/30)   ★★★"></a>算法题7.   数字游戏 (2020/3/30)   ★★★</h3><p>小W发明了一个游戏，他在黑板上写出了一行数字$a_{1},a_{2},….a_{n}$，然后给你m个回合的机会，每回合你可以从中选择一个数擦去它，接着剩下来的每个数字 $a_{i}$ 都要递减一个值 $b_{i}$。如此重复m个回合，所有你擦去的数字之和就是你所得到的分数。 求出最多可得多少分。</p><pre><code>输入：5 (第一行输入整数, 1&lt;=n&lt;=100，表示数字的个数)     5 (一个整数，表示回合数， 1&lt;=m&lt;=n)     10 20 30 40 50 (n个不超过10000的正整数，分别为a1, a2, a3...)     4 5 6 7 8 (n个不超过500的正整数，分别为b1, b2, b3...)输出：100</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态规划表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MaxValue</span><span class="params">(self, n, m, list1, list2)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line"><span class="keyword">if</span> list2[i] &lt; list2[j]:</span><br><span class="line">self.swap(list2, i, j)</span><br><span class="line">self.swap(list1, i, j)</span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, min(m, i)+<span class="number">1</span>):</span><br><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+list1[i<span class="number">-1</span>]-list2[i<span class="number">-1</span>]*(j<span class="number">-1</span>))</span><br><span class="line"><span class="keyword">return</span> dp[n][m]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, nums, index1, index2)</span>:</span></span><br><span class="line">temp = nums[index1]</span><br><span class="line">nums[index1] = nums[index2]</span><br><span class="line">nums[index2] = temp</span><br><span class="line"><span class="comment"># 数字生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NumberGenerator</span><span class="params">(n_range, list1_range, list2_range)</span>:</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">n = random.randint(<span class="number">1</span>, n_range)</span><br><span class="line">m = random.randint(<span class="number">1</span>, n)</span><br><span class="line">list1 = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">list1.append(random.randint(<span class="number">1</span>, list1_range))</span><br><span class="line">list2 = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">list2.append(random.randint(<span class="number">1</span>, list2_range))</span><br><span class="line"><span class="keyword">return</span> n, m, list1, list2</span><br><span class="line"><span class="comment"># 暴力解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViolentSolution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ViolentSolution</span><span class="params">(self, n, m, list1, list2)</span>:</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line">index = list(combinations([i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)], m))</span><br><span class="line">maxvalue = []</span><br><span class="line">print(len(index))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> index:</span><br><span class="line">nums1, nums2 = [], []</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">nums1.append(list1[j])</span><br><span class="line">nums2.append(list2[j])</span><br><span class="line">print(<span class="string">"包含m个数的列表"</span>, nums1, nums2)</span><br><span class="line">maxvalue.append(self.ListMaxValue(nums1, nums2))</span><br><span class="line">print(maxvalue, len(maxvalue))</span><br><span class="line"><span class="keyword">return</span> max(maxvalue)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ListMaxValue</span><span class="params">(self, list1, list2)</span>:</span></span><br><span class="line">maxvalue = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list1)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(list1)):</span><br><span class="line"><span class="keyword">if</span> list2[i] &lt; list2[j]:</span><br><span class="line">self.swap(list2, i, j)</span><br><span class="line">self.swap(list1, i, j)</span><br><span class="line">print(list1, list2)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">maxvalue += i</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">maxvalue -= list2[i] * i</span><br><span class="line"><span class="keyword">return</span> maxvalue</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, nums, index1, index2)</span>:</span></span><br><span class="line">temp = nums[index1]</span><br><span class="line">nums[index1] = nums[index2]</span><br><span class="line">nums[index2] = temp</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">TN = <span class="number">0</span></span><br><span class="line">SUM = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(SUM):</span><br><span class="line">n, m, list1, list2 = NumberGenerator(<span class="number">10</span>, <span class="number">100</span>, <span class="number">50</span>)</span><br><span class="line">value1 = ViolentSolution().ViolentSolution(n, m, copy.deepcopy(list1), copy.deepcopy(list2))</span><br><span class="line">value2 = Solution().MaxValue(n, m, list1, list2)</span><br><span class="line">print(<span class="string">'当前的一组数字是：'</span>, n, m, list1, list2, value1, value2)</span><br><span class="line"><span class="keyword">if</span> value1 == value2:</span><br><span class="line">TN += <span class="number">1</span></span><br><span class="line">print(TN/SUM)</span><br><span class="line"><span class="comment"># 还有一部分数据最总结果两个对不上，继续思考。</span></span><br></pre></td></tr></table></figure><h3 id="算法题8-LeetCode-面试题62-圆圈中最后剩下的数字-2020-3-30-★★★"><a href="#算法题8-LeetCode-面试题62-圆圈中最后剩下的数字-2020-3-30-★★★" class="headerlink" title="算法题8. LeetCode. 面试题62. 圆圈中最后剩下的数字 (2020/3/30)  ★★★"></a>算法题8. LeetCode. <a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题62. 圆圈中最后剩下的数字</a> (2020/3/30)  ★★★</h3><p>$0,1,\dots,n-1$这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p>经典解法：利用环形链表模拟圆圈，创建一个共有 n 个节点的环形链表，然后每次在这个链表中删除第 m 个节点。每删除一个数字需要 m 步运算，共有 n 个数字，总的时间复杂度为 $O(mn)$，同时还需要一个辅助链表来模拟圆圈，额外空间复杂度为 $O(n)$。</p><p>找规律法：设 $f(n, m)$，表示每次在 n 个数字0，1，…，n-1中删除第 m 个数字最后剩下的数字，删除的第一个数字$(m-1)\%n$，记为 k，$f^{‘}(n-1, m)$ 表示在第一个数字被删除后，序列重新调整后删除第 m 个节点最后剩下的数字，因此 $f^{<code>}(n-1, m)=f(n, m)$；设 $p(x)=(x-k-1)\%n$，表示如果映射前的数字是 $x$，映射后的数字是 $(x-k-1)\%n$，逆映射为 $p^{-1}(x) = (x+k+1)\%n$。因此 $f^{</code>}(n-1, m)=p^{-1}[f(n-1,m)]=[f(n-1, m)+k+1] \%n$。</p><script type="math/tex; mode=display">f(n, m)=\begin{cases}0, & \text{n=1} \\[3ex][f(n-1, m)+m]\%n, & \text{n>1}\end{cases}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span> <span class="keyword">or</span> m &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        last = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            last = (last + m) % i</span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure><h3 id="算法题9-LeetCode-912-排序数组-2020-3-31"><a href="#算法题9-LeetCode-912-排序数组-2020-3-31" class="headerlink" title="算法题9. LeetCode. 912. 排序数组 (2020/3/31)"></a>算法题9. LeetCode. <a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">912. 排序数组</a> (2020/3/31)</h3><p> 给定一个整数数组 $nums$，将该数组升序排列。 <a href="https://leetcode-cn.com/problems/sort-an-array/solution/pai-xu-shu-zu-by-leetcode-solution/" target="_blank" rel="noopener">LeetCode-Solution</a></p><p>方法一：堆排序 </p><p>堆排序的思想就是先将待排序的序列建成大根堆，使得每个父节点的元素大于等于它的子节点。此时整个序列最大值即为堆顶元素，我们将其与末尾元素交换，使末尾元素为最大值，然后再调整堆顶元素使得剩下的 n-1 个元素仍为大根堆，再重复执行以上操作我们即能得到一个有序的序列。</p><p>时间复杂度：$O(n\log n)$。初始化建堆的时间复杂度为 O(n)O(n)，建完堆以后需要进行 n-1 次调整，一次调整（即 maxHeapify） 的时间复杂度为 $O(\log n)$，那么 n-1 次调整即需要 $O(n\log n)$ 的时间复杂度。因此，总时间复杂度为 $O(n+n\log n)=O(n\ logn)$。</p><p>空间复杂度：$O(1)$。只需要常数的空间存放若干变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">self.heap_sort(nums)</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">self.build_heap(nums)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">nums[i], nums[<span class="number">0</span>] = nums[<span class="number">0</span>], nums[i]</span><br><span class="line">self.heapify(nums, <span class="number">0</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_heap</span><span class="params">(self, heap)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(heap)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">self.heapify(heap, i, len(heap))</span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(self, heap, root, heap_len)</span>:</span></span><br><span class="line">p = root</span><br><span class="line"><span class="keyword">while</span> p * <span class="number">2</span> + <span class="number">1</span> &lt; heap_len:</span><br><span class="line">l, r = p*<span class="number">2</span>+<span class="number">1</span>, p*<span class="number">2</span>+<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> heap_len &lt;= r <span class="keyword">or</span> heap[r] &lt; heap[l]:</span><br><span class="line">nex = l</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">nex = r</span><br><span class="line"><span class="keyword">if</span> heap[p] &lt; heap[nex]:</span><br><span class="line">heap[p], heap[nex] = heap[nex], heap[p]</span><br><span class="line">p = nex</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p> <strong>⭐️</strong> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法题1：获胜一方的三张牌的点数最大和-2020-3-24&quot;&gt;&lt;a href=&quot;#算法题1：获胜一方的三张牌的点数最大和-2020-3-24&quot; class=&quot;headerlink&quot; title=&quot;算法题1：获胜一方的三张牌的点数最大和 (2020/3/24)&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://pl741.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://pl741.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>找工作</title>
    <link href="http://pl741.github.io/2020/03/01/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    <id>http://pl741.github.io/2020/03/01/找工作/</id>
    <published>2020-03-01T08:11:48.000Z</published>
    <updated>2020-03-25T14:33:58.717Z</updated>
    
    <content type="html"><![CDATA[<p><strong>• <a href="http://www.yingjiesheng.com/" target="_blank" rel="noopener">应届生求职网</a>：</strong>网申截止日期很好用，BBS板块可以看笔面经。 </p><p><strong>• 各大高校的就业信息网</strong>：<a href="https://job.bupt.edu.cn/recruit.html" target="_blank" rel="noopener">北邮就业信息网</a>、<a href="https://job.bjtu.edu.cn/cms/notice/" target="_blank" rel="noopener">北交就业信息网</a>、<a href="http://job.bit.edu.cn/portal/home.html" target="_blank" rel="noopener">北理工就业信息网</a>、<a href="http://career.cic.tsinghua.edu.cn/xsglxt/f/jyxt/anony/xxfb" target="_blank" rel="noopener">清华就业信息网</a>、<a href="https://scc.pku.edu.cn/home!recruitList.action?category=1" target="_blank" rel="noopener">北大就业信息网</a>、<a href="http://rdjy.ruc.edu.cn/html/main/col3/column_3_1.html" target="_blank" rel="noopener">人大就业信息网</a>、<a href="http://career.buaa.edu.cn/gotoRecruitmentInfoListAction.dhtml?selectedNavigationName=RecruitmentInfoMain&amp;selectedItem=recruit" target="_blank" rel="noopener">北航就业信息网</a>、<a href="http://career.bnu.edu.cn/front/channel.jspa?channelId=745&amp;parentId=741" target="_blank" rel="noopener">北师就业信息网</a>。</p><p><strong>•</strong> <a href="https://bbs.byr.cn/#!board/JobInfo" target="_blank" rel="noopener"><strong>北邮人论坛—招聘信息</strong></a></p><p><strong>•</strong> <a href="https://www.nowcoder.com/discuss" target="_blank" rel="noopener"><strong>牛客网</strong></a></p><h3 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h3><p><strong>阿里内推</strong> —— 内推时间：3.13，【阿里钉钉】：<a href="https://bbs.byr.cn/#!article/JobInfo/876537" target="_blank" rel="noopener">招聘信息</a>；【阿里云】：【蚂蚁金服】</p><p><strong>腾讯内推</strong> —— <a href="https://bbs.byr.cn/#!article/JobInfo/877562" target="_blank" rel="noopener">内推地址</a></p><p><strong>字节跳动 </strong>—— 网申时间【2.24 - 4.30】，每人只能申请一个职位，邮件咨询：campushr@bytedance.com，<a href="https://mp.weixin.qq.com/s/exBEtpwIkku7IgrFWMBWFA" target="_blank" rel="noopener">招聘信息</a>，【投递邮箱】luxingpei@bytedance.com，也可以使用我的内推码 BUTVJNW 在官网 <a href="https://job.toutiao.com/campus/" target="_blank" rel="noopener">https://job.toutiao.com/campus/</a> 投递。【简历命名】毕业时间-姓名-岗位-地点-学校</p><p><a href="https://careers.microsoft.com/us/en" target="_blank" rel="noopener"><strong>微软</strong></a> —— <a href="https://mp.weixin.qq.com/s?__biz=Mzg4NTI0NDc4NQ==&amp;mid=2247484035&amp;idx=3&amp;sn=3160f43720121213d61734d8f1417189&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">招聘信息</a></p><p><strong>亚马逊</strong> —— <a href="https://mp.weixin.qq.com/s/sxR06G7Zot4ob10zQRrXbA" target="_blank" rel="noopener">招聘信息</a></p><p><strong>百度内推</strong> —— <a href="https://bbs.byr.cn/#!article/JobInfo/877647" target="_blank" rel="noopener">内推地址</a></p><p><strong>京东内推 </strong>—— 网申时间【2.5 - 3.13】，<a href="https://mp.weixin.qq.com/s?__biz=Mzg4NTI0NDc4NQ==&amp;mid=2247484119&amp;idx=1&amp;sn=11acb0ebd46caff20fd755c3a244c2c0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">招聘信息</a>，<a href="https://bbs.byr.cn/#!article/JobInfo/875628" target="_blank" rel="noopener">内推地址</a></p><p><strong>网易内推 </strong>—— 招聘信息，网申时间： 3月9日-3月28日，<a href="http://m.bole.netease.com/?from=singlemessage&amp;isappinstalled=0#/app/index?boleId=df65870f364f275e&amp;name=%E4%B8%81%E4%BC%9F%E4%BC%9F&amp;type=6&amp;boleType=2&amp;signature=a4b912589ea4dbb647ec338f6575757c&amp;projectId=24" target="_blank" rel="noopener">网申内推地址</a></p><p><strong>小米 </strong>—— 网申时间【 3月5日-4月30日 】，<a href="https://bbs.byr.cn/#!article/JobInfo/877658" target="_blank" rel="noopener">招聘信息</a></p><p><strong>哔哩哔哩</strong> —— 网申时间【2.26 - 5月中旬】，<a href="https://mp.weixin.qq.com/s/Z02JNmySE5P4LfMfT2mc1w" target="_blank" rel="noopener">招聘信息</a></p><p><strong>拼多多内推</strong> —— <a href="https://bbs.byr.cn/#!article/JobInfo/875970" target="_blank" rel="noopener">内推地址</a>，目前实习内推没有开始，待确认</p><p><strong>360内推 </strong>—— <a href="https://bbs.byr.cn/#!article/JobInfo/877092" target="_blank" rel="noopener">招聘信息</a>，网申时间： 3月9日-3月22日 ，<a href="http://campus.chinahr.com/ws/v/5e38f4ae5d11bf061249260f/index.html?refer=share#/campus?projectId=5e38f4ae5d11bf061249260f&amp;shaMarkId=e5a89b40-18d4-4151-a81c-9ca66eebf6f9" target="_blank" rel="noopener">网申内推地址</a></p><p><strong>滴滴内推</strong> —— <a href="https://bbs.byr.cn/#!article/JobInfo/877674" target="_blank" rel="noopener">内推</a></p><p><a href="https://campus.meituan.com/" target="_blank" rel="noopener"><strong>美团内推</strong></a> —— 网申时间【2020.04.20，24:00】，<a href="https://mp.weixin.qq.com/s?__biz=Mzg4NTI0NDc4NQ==&amp;mid=2247484179&amp;idx=4&amp;sn=2b8b89d0a14b50e9b9471a54cf30a08a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">招聘信息</a> ，<a href="https://bbs.byr.cn/#!article/JobInfo/877618" target="_blank" rel="noopener">内推</a></p><p><a href="http://zhaopin.iqiyi.com/job-detail-info-school.html?id=2625&amp;isschool=1" target="_blank" rel="noopener"><strong>爱奇艺</strong></a> —— <a href="https://mp.weixin.qq.com/s?__biz=Mzg4NTI0NDc4NQ==&amp;mid=2247483976&amp;idx=2&amp;sn=5bc97c05f28b0efc59ef668b325c2520&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">招聘信息</a>， <a href="https://bbs.byr.cn/#!article/JobInfo/876741" target="_blank" rel="noopener">内推信息</a></p><p><strong>携程</strong> —— 网申时间【内推&amp;提前批：3.16/23:59，正式：5.6/23:59】，<a href="https://mp.weixin.qq.com/s?__biz=Mzg4NTI0NDc4NQ==&amp;mid=2247484176&amp;idx=1&amp;sn=d5fd5661348886047308b76f83637c7d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">招聘信息</a></p><p><strong>去哪网</strong> —— <a href="https://www.nowcoder.com/discuss/372228?type=post&amp;order=time&amp;pos=&amp;page=1" target="_blank" rel="noopener">招聘信息</a></p><p><strong>猿辅导</strong> —— <a href="https://bbs.byr.cn/#!article/JobInfo/877760" target="_blank" rel="noopener">招聘信息</a></p><p><strong>知乎</strong> —— <a href="https://www.nowcoder.com/discuss/377003?type=post&amp;order=time&amp;pos=&amp;page=1" target="_blank" rel="noopener">招聘信息</a></p><p><strong>搜狐</strong> —— <a href="https://mp.weixin.qq.com/s/zHBqTgR6ACpWu-L2sSs5vA" target="_blank" rel="noopener">搜索研发工程师，内推</a>，只有一个项目组，可以再找一下</p><p><strong>搜狗 </strong>—— <a href="https://bbs.byr.cn/#!article/JobInfo/878087" target="_blank" rel="noopener">招聘信息</a>，  简历筛选（3月-4月） </p><p><strong>快手</strong> —— <a href="https://job.bupt.edu.cn/recruitment.2.ff8080816e6da2fe0170f08ac55516b1.html" target="_blank" rel="noopener">招聘信息</a>， 报名信息：3月9日-4月22日 ，<a href="https://campus.kuaishou.cn/recruit/campus/e/#/campus/share/job-list/ZqIKi9zSVmam3Aq%2FlMzlHw%3D%3D" target="_blank" rel="noopener">内推地址</a></p><p><strong>唯品会</strong> —— <a href="https://bbs.byr.cn/#!article/JobInfo/875361" target="_blank" rel="noopener">招聘信息</a></p><p><strong>旷视</strong> —— </p><p><strong>商汤</strong>：</p><p><strong>VIVO</strong>：</p><p><strong>图森未来</strong> —— 感知算法研究员、感知算法工程师 ，<a href="https://bbs.byr.cn/#!article/JobInfo/876473" target="_blank" rel="noopener">招聘信息</a>，<a href="https://bbs.byr.cn/#!article/JobInfo/877741" target="_blank" rel="noopener">网申内推</a></p><p><del><a href="http://shannon.ai/employment/" target="_blank" rel="noopener"><strong>香侬科技</strong></a>  ——  目前实习生招聘只有NLP和CV</del></p><p><strong>飞猪 </strong>—— 阿里飞猪</p><p><strong>Boss直聘</strong> —— <a href="https://mp.weixin.qq.com/s/zHBqTgR6ACpWu-L2sSs5vA" target="_blank" rel="noopener">内推地址</a>，可以再找一下， <a href="https://bbs.byr.cn/#!article/JobInfo/877449" target="_blank" rel="noopener">北邮人论坛上内推含微信</a></p><p><strong>数美科技</strong> —— <a href="https://mp.weixin.qq.com/s/zHBqTgR6ACpWu-L2sSs5vA" target="_blank" rel="noopener">内推地址</a>，可以再找一下</p><p><strong>作业帮</strong> —— <a href="https://job.bupt.edu.cn/recruitment.2.ff8080816e6da34801709f843e010454.html" target="_blank" rel="noopener">招聘信息</a>，<a href="https://www.nowcoder.com/discuss/378048?type=post&amp;order=time&amp;pos=&amp;page=2" target="_blank" rel="noopener">内推地址</a></p><p><del><strong>shopee</strong> —  深圳和新加坡，没有北京</del></p><p><strong>陌陌 </strong>—— <a href="https://www.nowcoder.com/discuss/373988?type=post&amp;order=time&amp;pos=&amp;page=4" target="_blank" rel="noopener">内推地址</a></p><p><del><a href="http://zhaopin.midea.com.cn/mideaweb/hrZhaopin/" target="_blank" rel="noopener"><strong>美的</strong></a>——<a href="https://mp.weixin.qq.com/s?__biz=Mzg4NTI0NDc4NQ==&amp;mid=2247484129&amp;idx=2&amp;sn=045c79af07827b55a86c9e9ea872060a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">招聘信息</a>，可联系的<a href="https://www.nowcoder.com/discuss/269502" target="_blank" rel="noopener">内推地址</a>，没有北京实习岗位</del></p><p><strong>深信服内推</strong> —— <a href="https://bbs.byr.cn/#!article/JobInfo/875263" target="_blank" rel="noopener">内推地址</a></p><p><strong>斗鱼</strong> —— <a href="https://job.bupt.edu.cn/recruitment.2.ff8080816e6da34801709a7a9c8c0427.html" target="_blank" rel="noopener">招聘信息</a>，<a href="https://www.nowcoder.com/discuss/380612?type=post&amp;order=time&amp;pos=&amp;page=1" target="_blank" rel="noopener">内推地址</a></p><p><strong>花椒直播</strong> —— <a href="https://job.bupt.edu.cn/recruitment.2.ff8080816e6da2fe0170a5e0bbf71560.html" target="_blank" rel="noopener">招聘信息</a>，无内推已确定</p><p><strong>平安科技</strong> —— <a href="https://job.bupt.edu.cn/recruitment.2.ff8080816e6da3480170a4401f780475.html" target="_blank" rel="noopener">招聘信息</a></p><p><strong>北京数码视讯</strong> —— <a href="https://job.bupt.edu.cn/recruitment.2.ff8080816e6da3480170cc7e532b051c.html" target="_blank" rel="noopener">招聘信息</a>，无内推</p><p><strong>联想</strong> —— <a href="https://mp.weixin.qq.com/s/WTp_mqsViYCBjeNlMIMd6A" target="_blank" rel="noopener">招聘信息</a></p><p><strong>华为</strong> —— <a href="https://mp.weixin.qq.com/s/ZSVTArXg7wfquafW4UCTzw" target="_blank" rel="noopener">招聘信息</a></p><p>链家、英特尔、地平线、嘉实基金、华泰证券、</p><h3 id="国企-amp-amp-银行"><a href="#国企-amp-amp-银行" class="headerlink" title="国企 &amp;&amp; 银行"></a>国企 &amp;&amp; 银行</h3><p><strong>华夏基金</strong>：<a href="https://bbs.byr.cn/#!article/JobInfo/877652" target="_blank" rel="noopener">招聘信息</a></p><p><strong>中信证券</strong>：<a href="https://job.bupt.edu.cn/recruitment.2.ff8080816e6da2fe017086fb2b5f150c.html" target="_blank" rel="noopener">招聘信息</a></p><p><strong>招商银行</strong>：<a href="http://career.cloud.cmbchina.com/index.html#fintech" target="_blank" rel="noopener">精英训练营</a>，报名时间：3.28—4.22， <a href="https://cmbjob.ccc.cmbchina.com/WeChatRecruit/positionlist.html?refereeId=028d4fb4-7744-44d2-9881-70c7382b507a&amp;refereeCode=e1f7b902-8235-4a64-a48a-696fa469828b&amp;deptId=003&amp;recruitType=2&amp;positionClass=" target="_blank" rel="noopener">内推地址</a></p><p><strong>中国银行</strong>：<a href="https://mp.weixin.qq.com/s/ehshwY1cjmAULmuokJt5vg" target="_blank" rel="noopener">招聘信息</a>, 报名时间：即日起—4月中旬或5月中旬</p><p><strong>微众银行</strong>：<a href="https://mp.weixin.qq.com/s/tfOLtpjCDEcTmQE0imJALA" target="_blank" rel="noopener">招聘信息</a></p><h3 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h3><p>作者：克拉克华<br><a href="https://www.nowcoder.com/discuss/379016?type=post&amp;order=time&amp;pos=&amp;page=1来源：牛客网" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/379016?type=post&amp;order=time&amp;pos=&amp;page=1来源：牛客网</a></p><ol><li>自我介绍 </li><li>项目介绍，问项目细节，项目中遇到的最大的问题是什么 </li><li>两道算法题：第一个是两个链表的公共结点，第二个是给定栈，保证栈的效率的同时能够在O(1)返回栈的最大值。说了下思路，思路没问题就没让我写代码。 </li></ol><p>休息30分钟</p><p>二面（50分钟）：</p><ol><li>自我介绍 </li><li>项目简单介绍 </li><li>逻辑回归损失函数，SVM损失函数，随机森林和GBDT的理解 </li><li>两道算法题：删除字符串中连续的重复字符，判断二叉树上是否存在一条从根结点到叶结点的路径，满足其上的元素之和等于target。先说的思路，然后在牛客的窗口里写了代码。第一道题应该用栈进行求解，脑子抽了没想出来，希望不要凉</li></ol><h3 id="C-C从代码到可执行程序之间经历了哪些过程？每一步的作用是什么？"><a href="#C-C从代码到可执行程序之间经历了哪些过程？每一步的作用是什么？" class="headerlink" title="C++/C从代码到可执行程序之间经历了哪些过程？每一步的作用是什么？"></a>C++/C从代码到可执行程序之间经历了哪些过程？每一步的作用是什么？</h3><p>从代码到可执行程序之间经历了：</p><ol><li>预编译：主要处理源代码文件中的以 ‘#’ 开头的预编译指令，产生 .ii 文件。（主要有以下处理规则：删除所有的 #define，展开所有的宏定义；处理所有的条件预编译指令，如 “#if”、”#endif”、”ifdef“、”#elif“, “#else”；处理 “#include” 预编译指令，将文件内容替换到它的位置，是一个递归过程，文件中含其他文件；删除所有的注释；保留所有的 #pragma编译器指令；添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告时能够显示行号。）</li><li>编译：将预编译之后产生的 .ii 文件，进行一系列词法分析、语法分析、语义分析及优化后，产生 .s 汇编文件。(词法分析：利用类似于”有限状态机“的算法，将源代码程序输入到扫描中，将其中的字符序列分割成一系列的记号；语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树；语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义；优化：源代码级别的优化过程；目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇报语言；目标代码优化：对目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令。)</li><li>汇编：将汇编代码转变成机器可以执行的指令，根据汇编指令和机器指令的对照表一一翻译过来，汇编过程由汇编器 as 完成，产生目标文件.o或者.obj文件</li><li>链接：将不同的源文件产生目标文件进行链接，从而形成一个可执行的程序，产生可执行文件.out或者.exe文件；分为静态链接和动态链接（静态链接：函数和数据被编译成一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，连接器从库中复制这些函数和数据并把它们和应用程序的其他模块组合起来创建最终的可执行文件，空间浪费——每个可执行程序中对所有需要的目标文件都要有一个副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；更新困难——每当库函数的代码修改时，就需要重新进行编译链接形成可执行程序；运行速度快——在可执行程序中已经具备了所有执行程序所需要的任何东西。动态链接：把程序按照模块拆分成各个相对独立的部分，在程序运行时才将他们连接在一起形成一个完整的程序，静态链接把所有程序模块都链接成一个独立的可执行文件。共享库——即使每个程序都依赖同一个库，多个程序在执行时共享同一份副本；更新方便——更新时只需要替换原来的目标文件，无需将所有程序再重新连接一遍，当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来；性能损耗——链接会推迟程序的运行。</li></ol><h3 id="列举你心目中优秀代码具有哪些特性？并从代码风格、团队合作、软件工程等角度谈谈何如保证自己的代码交付质量？"><a href="#列举你心目中优秀代码具有哪些特性？并从代码风格、团队合作、软件工程等角度谈谈何如保证自己的代码交付质量？" class="headerlink" title="列举你心目中优秀代码具有哪些特性？并从代码风格、团队合作、软件工程等角度谈谈何如保证自己的代码交付质量？"></a>列举你心目中优秀代码具有哪些特性？并从代码风格、团队合作、软件工程等角度谈谈何如保证自己的代码交付质量？</h3><p>代码架构合理，分层清楚，逻辑清晰，模块划分合理；具有一定的注释，可读性好，易维护，可扩展性，可以随时增加，修改和删除一部分功能，易迁移，函数及变量名是否准确，结构是否完备易用；函数是否内聚，低耦合；使用算法是否高效。</p><p>需求分析是否完整合理，测试代码是否足够测试代码功能，软件是否有很好的测试性，有足够的log纪录用于跟踪bug，是否安全稳健，能处理异常输入。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;• &lt;a href=&quot;http://www.yingjiesheng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;应届生求职网&lt;/a&gt;：&lt;/strong&gt;网申截止日期很好用，BBS板块可以看笔面经。 &lt;/p&gt;
&lt;p&gt;&lt;stron
      
    
    </summary>
    
    
      <category term="找工作" scheme="http://pl741.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="招聘信息" scheme="http://pl741.github.io/tags/%E6%8B%9B%E8%81%98%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>程序员代码面试指南</title>
    <link href="http://pl741.github.io/2020/03/01/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>http://pl741.github.io/2020/03/01/程序员代码面试指南/</id>
    <published>2020-03-01T06:18:48.000Z</published>
    <updated>2020-06-05T04:51:25.705Z</updated>
    
    <content type="html"><![CDATA[<h4 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h4><h5 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h5><p>异或运算（<font color="red">无进位相加，相同为0， 不同为1</font>）比正常加减速度快，异或运算的性质  <code>a ⊕ b = b  ⊕ a；a  ⊕  (b  ⊕  c) = (a  ⊕  b)  ⊕  c；0  ⊕ N = N；N ⊕ N = 0</code><br>交换两个数的值，不申请额外的变量：<code>a = a ^ b, b = a ^ b, a = a ^ b</code> ，在 a, b指向的内存地址不同时（值可以相同），可以这样做。Python 中交换两个变量的值 <code>a, b = b, a</code>，加减法交换两个变量的值：<code>a = a + b，b = a - b，a = a - b</code>  </p><ol><li>数组中只有一种数出现奇数次，其他均出现偶数次，利用时间复杂度 $O(1)$，额外空间复杂度 $O(1)$ 找到出现奇数次的数。<br>练习：<a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a>  <a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137. 只出现一次的数字 II</a>（137题中一个数字出现1次，其他数字出现3次，没看懂使用异或运算的算法）</li><li>数组中有两种数出现奇数次，找出这两个数。<br>eor = 0 与数组中所有数都异或一次 ==&gt; eor = 两个出现奇数次的数的异或结果，且eor != 0  ——&gt; eor 的二进制表达中有一位为 1，设k位上为 1，找出数组中所有 k 位为 1 的数，异或这些数的结果为 eor’，则eor’ 一定是其中一个出现奇数次的数。<font color="red">提取一个不等于0的数最右侧的1</font>：位移 for 循环（不快）；（~eor)+1 &amp; eor 即取反加1，再和自己与<br>练习：<a href="https://leetcode-cn.com/problems/single-number-iii/" target="_blank" rel="noopener">260. 只出现一次的数字 III</a><div><div class="fold_hider"><div class="close hider_title">数组中有两种出现奇数次的数</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printOddTimesNum2</span><span class="params">(arr)</span>:</span></span><br><span class="line">eor = <span class="number">0</span></span><br><span class="line">eorhasOne = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">eor ^= i</span><br><span class="line">rightOne = eor &amp; (~eor + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line"><span class="keyword">if</span> i &amp; rightOne != <span class="number">0</span>:</span><br><span class="line">eorhasOne ^= i</span><br><span class="line"><span class="keyword">return</span> eorhasOne, (eor ^ eorhasOne)</span><br></pre></td></tr></table></figure></div></div></li></ol><h5 id="求中点"><a href="#求中点" class="headerlink" title="求中点"></a>求中点</h5><p>正常 (L + R)/2 有可能会溢出，可使用 L + ((L-R）&gt;&gt;1)</p><h5 id="递归行为时间复杂度"><a href="#递归行为时间复杂度" class="headerlink" title="递归行为时间复杂度"></a>递归行为时间复杂度</h5><p>master公式：$T(N) = a*T(N/b) + O(N^d)$</p><script type="math/tex; mode=display">log(b, a) > d 复杂度为 O(N*log(b, a))</script><script type="math/tex; mode=display">log(b, a) = d 复杂度为 O(N^d*log N)</script><script type="math/tex; mode=display">log(b, a) < d 复杂度为 O(N^d)</script><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>排序测试用例：</p><ol><li>已经排序好的数组</li><li>元素的值全部相等或者元素的值近似相等</li><li>随机生成的数据</li></ol><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>  每次从待排序的数据中选择最小的数，交换待排数组的起始位置与最小元素；再从剩余的未排序数组中选择最小元素，以此类推。<strong><font color="red">每次找最小的值放在i位置</font></strong>。<br>  时间复杂度 $O(N^{2})$，额外空间复杂度 $O(1)$。<strong>特点：在一般情况下或者在平均来看，选择排序在排序过程中交换元素的次数最少。</strong>选择排序的运行时间和数据本身所具有的特点无关，优点：排序过程中，元素交换的总次数是最少的，如果移动元素的成本很大，可以考虑选择排序。缺点：排序过程中元素两两间比较的次数较多。<br><div><div class="fold_hider"><div class="close hider_title">选择排序</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line"><span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">minIndex = i</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(arr)):</span><br><span class="line"><span class="keyword">if</span> arr[j] &lt; arr[minIndex]:</span><br><span class="line">minIndex = j</span><br><span class="line">self.swap(arr, i, minIndex)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">tmp = arr[i]</span><br><span class="line">arr[i] = arr[j]</span><br><span class="line">arr[j] = tmp</span><br><span class="line">print(arr)</span><br></pre></td></tr></table></figure></div></div></p><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>依次比较两个元素，按照谁打谁放后的规则，每一次循环可以确定最大值。<font color="red">谁大谁往后，每次循环可以确定最大值。</font>时间复杂度 $O(N^{2})$，额外空间复杂度 $O(1)$。<br><div><div class="fold_hider"><div class="close hider_title">冒泡排序</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line"><span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line"><span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">self.swap(arr, j, j+<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">tmp = arr[i]</span><br><span class="line">arr[i] = arr[j]</span><br><span class="line">arr[j] = tmp</span><br><span class="line">print(i, j, arr)</span><br></pre></td></tr></table></figure></div></div></p><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置插入。（有两种将未排数据插入的方式：逐个交换——往前看，若未排序数据小则交换两个数字的位置；逐个后退——从已排序序列末尾开始，若比待排序数据大则往后退）<font color="red">往前看，小交换，0~1范围有序——&gt;0~2范围有序….</font> 时间复杂度 $O(N^{2})$，额外空间复杂度 $O(1)$。<strong>是时间复杂度为</strong>$O(N^2)$<strong>中最好的排序方法</strong>。在数组近乎有序的情况下，插入排序会很快完成排序任务，即若带排序数组有序，则插入排序的时间复杂度为 $O(N)$。算法复杂度与实际的数据状况有关。<br><div><div class="fold_hider"><div class="close hider_title">插入排序</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line"><span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># 往前看</span></span><br><span class="line"><span class="keyword">if</span> arr[j+<span class="number">1</span>] &lt; arr[j]: <span class="comment"># 小交换</span></span><br><span class="line">self.swap(arr, j, j+<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">tmp = arr[i]</span><br><span class="line">arr[i] = arr[j]</span><br><span class="line">arr[j] = tmp</span><br><span class="line">print(i, j, arr)</span><br></pre></td></tr></table></figure></div></div></p><h5 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h5><ol><li>在一个有序数组中，找某个数是否存在，遍历的方法时间复杂度为$O(N)$， 二分法的时间复杂度为$O(\log N)$。<br> 练习：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a>  <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a> <div><div class="fold_hider"><div class="close hider_title">二分法</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSExist</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, arr, num)</span>:</span></span><br><span class="line"><span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">L = <span class="number">0</span></span><br><span class="line">R = len(arr) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> L &lt; R:</span><br><span class="line">mid = L + ((R - L) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> arr[mid] == num:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">elif</span> arr[mid] &gt; num:</span><br><span class="line">R = mid - <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">L = mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> arr[L] == num:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div></div></li><li>在一个有序数组中，找&gt;=某个数最左侧的位置，例如：找到 [1, 1, 1, 1,  2,  2, 2, 2, 3, 3, 3, 4, 4] 数组中大于等于 2 的最左侧的位置。<br>练习： <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a><div><div class="fold_hider"><div class="close hider_title">二分法</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSNearLeft</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nearestIndex</span><span class="params">(self, arr, value)</span>:</span></span><br><span class="line">    L = <span class="number">0</span></span><br><span class="line">        R = len(nums) - <span class="number">1</span></span><br><span class="line">        indexL = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">            mid = L + ((R - L) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                R = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                L = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                indexL = mid</span><br><span class="line">                R = mid - <span class="number">1</span></span><br><span class="line">        L = <span class="number">0</span></span><br><span class="line">        R = len(nums) - <span class="number">1</span></span><br><span class="line">        indexR = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">            mid = L + ((R - L &gt;&gt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                L = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                R = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                indexR = mid</span><br><span class="line">                L = mid + <span class="number">1</span></span><br><span class="line">         <span class="keyword">return</span> [indexL, indexR]</span><br></pre></td></tr></table></figure></div></div></li><li>局部最小值问题，一个无需数组中，任何两个相邻数在数组中不等，找到一个局部最小。<br>练习：<a href="https://www.nowcoder.com/practice/d1c8838fc9e54b89bc10b5b6d2b52157?tpId=101&amp;tqId=33096&amp;tPage=1&amp;rp=1&amp;ru=/ta/programmer-code-interview-guide&amp;qru=/ta/programmer-code-interview-guide/question-ranking" target="_blank" rel="noopener">在数组中找到一个局部最小的位置</a><br>情况一：$ arr[0] &lt; arr[1]$，返回位置 0；情况二：$arr[N-1] &lt; arr[N-2]$，返回位置 $N-1$；情况三：$arr[i-1] &gt; arr[i] &lt; arr[i+1]$，返回位置 $i$。<br>做法：比较 0, 1位置上的数，若$ arr[0] &lt; arr[1]$找到，否则 ==&gt; 比较$N-1， N-2$，若$arr[N-1] &lt; arr[N-2]$找到，否则  ==&gt; 0~N-1 上比存在局部最小  ==&gt; 找到中间位置 mid，比较，若$arr[mid-1] &gt; arr[mid] &lt; arr[mid+1]$找到，否则 ==&gt; 若$arr[mid-1] &lt; arr[mid]$，缩小范围到 0~mid，若$arr[mid+1] &lt; arr[mid]$，缩小范围到 mid~N-1<div><div class="fold_hider"><div class="close hider_title">二分法</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LocalMin</span><span class="params">(self, arr)</span>:</span></span><br><span class="line"><span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> len(arr) == <span class="number">1</span> <span class="keyword">or</span> arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">N = len(arr)</span><br><span class="line"><span class="keyword">if</span> arr[N<span class="number">-1</span>] &lt; arr[N<span class="number">-2</span>]:</span><br><span class="line"><span class="keyword">return</span> N<span class="number">-1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"> L = <span class="number">1</span></span><br><span class="line"> R = N<span class="number">-2</span></span><br><span class="line"> <span class="keyword">while</span> L &lt;= R:</span><br><span class="line"> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"> <span class="keyword">if</span> arr[mid] &gt; arr[mid+<span class="number">1</span>]:</span><br><span class="line"> L = mid + <span class="number">1</span></span><br><span class="line"> <span class="keyword">elif</span> arr[mid] &gt; arr[mid<span class="number">-1</span>]:</span><br><span class="line"> R = mid - <span class="number">1</span></span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line"> <span class="keyword">return</span> mid</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></div></div></li></ol><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>将两个有序数组归并成一个更大的有序数组，【左边排好序、右边排好序，整体有序】，<font color="red">需要一个新的辅助空间和两个指针，用于比较</font>。时间复杂度 $O(N \log N)$，额外空间复杂度 $O(N)$。<br><div><div class="fold_hider"><div class="close hider_title">归并排序</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line"><span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">self.mergeSortCore(arr, <span class="number">0</span>, len(arr)<span class="number">-1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSortCore</span><span class="params">(self, arr, l, r)</span>:</span></span><br><span class="line"><span class="keyword">if</span> l == r:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">self.mergeSortCore(arr, l, mid)</span><br><span class="line">self.mergeSortCore(arr, mid+<span class="number">1</span>, r)</span><br><span class="line">self.merge(arr, l ,mid, r)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, arr, l, m, r)</span>:</span></span><br><span class="line">help = []</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">p1 = l</span><br><span class="line">p2 = m + <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> p1 &lt;= m <span class="keyword">and</span> p2 &lt;= r:</span><br><span class="line"><span class="keyword">if</span> arr[p1] &lt; arr[p2]:</span><br><span class="line">help.append(arr[p1])</span><br><span class="line">p1 += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">help.append(arr[p2])</span><br><span class="line">p2 += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> p1 &lt;= m:</span><br><span class="line">help.append(arr[p1])</span><br><span class="line">p1 += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> p2 &lt;= r:</span><br><span class="line">help.append(arr[p2])</span><br><span class="line">p2 += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(help)):</span><br><span class="line">arr[l+i] = help[i]</span><br><span class="line">print(l, m, r, arr)</span><br></pre></td></tr></table></figure></div></div><br>归并排序的扩展：小和问题和逆序对问题。<br>例题：<a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a>，<a href="https://www.acwing.com/problem/content/61/" target="_blank" rel="noopener">《剑指 Offer》（第 2 版）第 51 题：计算数组的逆序对</a>，<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a>， <a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a>，<a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a><br>小和问题：在一个数组中，每个数左边比当前数小的数累加起来，求一个数组的小和。换一个思路想：看每个数右边有多少个数比它大，可以将整体进行归并排序，左侧部分小则开始产生小和。<br><div><div class="fold_hider"><div class="close hider_title">小和问题</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallSum</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallSum</span><span class="params">(self, arr)</span>:</span></span><br><span class="line"><span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> self.mergeSort(arr, <span class="number">0</span>, len(arr)<span class="number">-1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(self, arr, l, r)</span>:</span></span><br><span class="line"><span class="keyword">if</span> l == r:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">res = self.mergeSort(arr, l, mid) \</span><br><span class="line">  + self.mergeSort(arr, mid + <span class="number">1</span>, r) \</span><br><span class="line">  + self.merge(arr, l, mid, r)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, arr, l, m, r)</span>:</span></span><br><span class="line">help = []</span><br><span class="line">p1 = l</span><br><span class="line">p2 = m + <span class="number">1</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> p1 &lt;= m <span class="keyword">and</span> p2 &lt;= r:</span><br><span class="line"><span class="keyword">if</span> arr[p1] &lt; arr[p2]:</span><br><span class="line">help.append(arr[p1])</span><br><span class="line">res += arr[p1] * (r - p2 + <span class="number">1</span>)</span><br><span class="line">p1 += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">help.append(arr[p2])</span><br><span class="line">p2 += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> p1 &lt;= m:</span><br><span class="line">help.append(arr[p1])</span><br><span class="line">p1 += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> p2 &lt;= r:</span><br><span class="line">help.append(arr[p2])</span><br><span class="line">p2 += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(help)):</span><br><span class="line">arr[l+i] = help[i]</span><br><span class="line">print(l, m, r, arr, res)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div><br>逆序对问题，在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对。<br>练习：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a>  <a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a>   <a href="https://leetcode-cn.com/problems/k-inverse-pairs-array/" target="_blank" rel="noopener">629. K个逆序对数组</a><br><div><div class="fold_hider"><div class="close hider_title">逆序对问题</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> nums == <span class="literal">None</span> <span class="keyword">or</span> len(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.mergeSort(nums, <span class="number">0</span>, len(nums)<span class="number">-1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(self, nums, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = l + ((r-l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        res = self.mergeSort(nums, l, mid) + self.mergeSort(nums, mid+<span class="number">1</span>, r) + self.merge(nums, l, mid, r)</span><br><span class="line">        <span class="keyword">return</span> res </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, arr, l, m, r)</span>:</span></span><br><span class="line">        help = []</span><br><span class="line">        p1 = l</span><br><span class="line">        p2 = m + <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt;= m <span class="keyword">and</span> p2 &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> arr[p1] &gt; arr[p2]:</span><br><span class="line">                res += (m - p1 + <span class="number">1</span>)</span><br><span class="line">                help.append(arr[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                help.append(arr[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt;= m:</span><br><span class="line">            help.append(arr[p1])</span><br><span class="line">            p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p2 &lt;= r:</span><br><span class="line">            help.append(arr[p2])</span><br><span class="line">            p2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(help)):</span><br><span class="line">            arr[l+i] = help[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div></p><h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><p>堆结构是用数组实现的完全二叉树结构(满二叉树，在从左往右依次变满，用连续数组实现，位置关系：节点 i 的左孩子是 $2<em>i+1$，节点 i 的右孩子$2</em>i+2$，节点 i 的父节点$(i-1)/2$ 向下取整），完全二叉树中如果每棵子数的最大值都在顶部就是大根堆 (例如：数组 [6, 3, 5, 1, 2, 4] 是大根堆)，完全二叉树中如果每棵子数的最小值都在顶部就是小根堆，优先级队列结构即堆结构。<br>堆排序过程：</p><ol><li>先让整个数组都变成大根堆结构，建堆过程：heapsize 纪录堆的大小<br>1）从上到下的方法：heapInsert 方法，时间复杂度为 $O(N \log N)$，用户一个数一个数的依次给你；若用户一次性将数据给你，通过从下往上每个数都 heapify，则建立大根堆的时间复杂度可以优化为 $O(N)$。<br>2）从下到上的方法：heapify 方法，时间复杂度为 $O(N \log N)$</li><li>把堆的最大值和堆末尾的值交换，然后减少堆到的大小后，再去调整为大根堆，周而复始，时间复杂度为 $O(N \log N)$</li><li>堆大小减小为 0 后，排序完成。<img src="/2020/03/01/程序员代码面试指南/2.jpg">  <div><div class="fold_hider"><div class="close hider_title">堆排序</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line"><span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">self.heapInsert(arr, i) <span class="comment"># arr数组上0~i是大根堆</span></span><br><span class="line">heapsize = len(arr) - <span class="number">1</span></span><br><span class="line">self.swap(arr, <span class="number">0</span>, heapsize)</span><br><span class="line"><span class="keyword">while</span> heapsize &gt; <span class="number">0</span>:</span><br><span class="line">self.heapify(arr, <span class="number">0</span>, heapsize)</span><br><span class="line">heapsize -= <span class="number">1</span></span><br><span class="line">self.swap(arr, <span class="number">0</span>, heapsize)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapInsert</span><span class="params">(self, arr, index)</span>:</span></span><br><span class="line">print(<span class="string">'开始heapInsert'</span>, index, (index - <span class="number">1</span>)//<span class="number">2</span>)</span><br><span class="line"><span class="keyword">while</span> (index<span class="number">-1</span>)//<span class="number">2</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[index] &gt; arr[(index - <span class="number">1</span>)//<span class="number">2</span>]:</span><br><span class="line">self.swap(arr, index, (index<span class="number">-1</span>)//<span class="number">2</span>)</span><br><span class="line">index = (index<span class="number">-1</span>)//<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(self, arr, index, heapsize)</span>:</span></span><br><span class="line">print(<span class="string">'开始heapify'</span>, index, heapsize)</span><br><span class="line">left = <span class="number">2</span> * index + <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; heapsize:</span><br><span class="line"><span class="keyword">if</span> left + <span class="number">1</span> &lt; heapsize <span class="keyword">and</span> arr[left+<span class="number">1</span>] &gt; arr[left]:</span><br><span class="line">largest = left + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">largest = left</span><br><span class="line"><span class="keyword">if</span> arr[largest] &lt; arr[index]:</span><br><span class="line">largest = index</span><br><span class="line"><span class="keyword">if</span> largest == index:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">self.swap(arr, largest, index)</span><br><span class="line">index = largest</span><br><span class="line">left = <span class="number">2</span> * index + <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">tmp = arr[i]</span><br><span class="line">arr[i] = arr[j]</span><br><span class="line">arr[j] = tmp</span><br><span class="line">print(i, j, arr)</span><br><span class="line">HeapSort().heapsort([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure></div></div></li></ol><p>$Python$ 中 $heapq$ 模块基本实现最小堆：<br><div><div class="fold_hider"><div class="close hider_title">heapq模块基本实现最小堆</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">heap = [] <span class="comment">#创建了一个空堆</span></span><br><span class="line">heappush(heap,item) <span class="comment">#往堆中插入一条新的值</span></span><br><span class="line">item = heappop(heap) <span class="comment">#从堆中弹出最小值</span></span><br><span class="line">item = heap[<span class="number">0</span>] <span class="comment">#查看堆中最小值，不弹出</span></span><br><span class="line">heapify(x) <span class="comment">#以线性时间讲一个列表转化为堆</span></span><br><span class="line">item = heapreplace(heap,item) <span class="comment">#弹出并返回最小值，然后将heapqreplace方法中item的值插入到堆中</span></span><br><span class="line">heappushpop() <span class="comment">#顾名思义，将值插入到堆中同时弹出堆中的最小值。</span></span><br><span class="line">merge(*iterables) <span class="comment">#合并多个堆然后输出</span></span><br><span class="line">nlargest(n , iterbale, key=<span class="literal">None</span>) <span class="comment">#从堆中找出做大的N个数，key的作用和sorted( )方法里面的key类似，用列表元素的某个属性和函数作为关键字。</span></span><br><span class="line">nsmallest(n, iterable, key=<span class="literal">None</span>) <span class="comment">#找到堆中最小的N个数用法同上。</span></span><br></pre></td></tr></table></figure></div></div><br>修改为最大堆：<br><div><div class="fold_hider"><div class="close hider_title">大根堆</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.val &gt; other.val</span><br><span class="line">q = []</span><br><span class="line">heapq.heappush(q, MyObject(<span class="number">50</span>))</span><br><span class="line">heapq.heappush(q, MyObject(<span class="number">40</span>))</span><br><span class="line">heapq.heappush(q, MyObject(<span class="number">30</span>))</span><br><span class="line">heapq.heappush(q, MyObject(<span class="number">20</span>))</span><br><span class="line">heapq.heappush(q, MyObject(<span class="number">200</span>))</span><br><span class="line">obj = heapq.heappop(q)</span><br><span class="line">print(obj.val)  <span class="comment"># 200</span></span><br><span class="line">heapq.heapreplace(q, MyObject(<span class="number">47</span>))  <span class="comment"># 将最大值替换为47</span></span><br><span class="line">print(heapq.heappop(q).val)  <span class="comment"># 47</span></span><br><span class="line">print(q[<span class="number">0</span>].val) <span class="comment"># 40</span></span><br></pre></td></tr></table></figure></div></div><br>堆排序扩展题目：已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过 k，并且 k 相对于数组来说比较小。<br><div><div class="fold_hider"><div class="close hider_title">扩展</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></p><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>不改进的快速排序：</p><ol><li><p>把数组范围中的最后一个数作为划分值，然后把数组通过荷兰国旗问题分成三个部分：左侧 &lt; 划分值、中间 == 划分值、右侧 &gt; 划分值。</p><ol><li><p><font color="red">Partition​ 问题</font>：给定一个数组 $arr$ 和一个数 $num$，请把小于等于 $num$ 的数放在数组的左边，大于 $num$ 的数放在数组的右边，要求额外空间复杂度 $O(1)$， 时间复杂度 $O(N)$<br>用一个变量表示 $\le$ 区域，$i$ ：表示从左往右遍历的变量 （当前数）<br>①  $arr[i] \le num$：当前数和 $\le 区域$ 下一个数交换， $\le 区域$ 扩一个位置，当前数跳下一个<br>②  $arr[i] \gt num$：当前数直接跳下一个<br>剑指offer：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题39. 数组中出现次数超过一半的数字</a></p><div><div class="fold_hider"><div class="close hider_title">partition问题</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></div></div></li><li><p><font color="red">荷兰国旗问题</font>：给定一个数组 $arr$ 和一个数 $num$，请把小于 $num$ 的数放在数组的左边，等于 $num$ 的数放在数组的中间，大于 $num$ 的数放在数组的右边，要求额外空间复杂度 $O(1)$， 时间复杂度 $O(N)$。<br>用一个变量表示左边界 $\lt 区域$， 一个变量表示右边界 $\gt 区域$，$i$ ：表示从左往右遍历的变量 （当前数）<br>①  $arr[i] \lt num$：当前数和 $\lt 区域$ 下一个数交换， $\lt 区域$ 扩一个位置，当前数跳下一个<br>②  $arr[i] = num$：当前数直接跳下一个<br>③  $arr[i] \gt num$：当前数和 $\gt 区域$ 前一个数交换， $\gt 区域$ 左扩一个位置，当前数定在原地<br>④  当前数 == $\gt 区域$左边界时停止</p><div><div class="fold_hider"><div class="close hider_title">荷兰国旗问题</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">NetherlandsFlag</span>:</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, arr, l, r, p)</span>:</span></span><br><span class="line"> less = l - <span class="number">1</span></span><br><span class="line"> more = r + <span class="number">1</span></span><br><span class="line"> <span class="keyword">while</span> l &lt; more:</span><br><span class="line"> <span class="keyword">if</span> arr[l] &lt; p:</span><br><span class="line"> self.swap(arr, l, less+<span class="number">1</span>)</span><br><span class="line"> less += <span class="number">1</span></span><br><span class="line"> l += <span class="number">1</span></span><br><span class="line"> <span class="keyword">elif</span> arr[l] &gt; p:</span><br><span class="line"> self.swap(arr, more<span class="number">-1</span>, l)</span><br><span class="line"> more -= <span class="number">1</span></span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line"> l += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> [less, more]</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line"> tmp = arr[i]</span><br><span class="line"> arr[i] = arr[j]</span><br><span class="line"> arr[j] = tmp</span><br><span class="line"> print(arr, i, j)</span><br></pre></td></tr></table></figure></div></div></li></ol></li><li><p>对左侧范围和右侧范围，递归执行<br> 不改进的快速排序：划分值越靠近两侧，复杂度越高；划分值越靠近中间，复杂度越低。数据越有序，不改进的快速排序复杂度越高，最差情况：当数据有序时，时间复杂度为 $O(N^{2})$；好情况：每次划分值处于相当中间的位置，时间复杂度 $O(N \log N)$<br> 改进的快速排序（随机快速排序）：</p><ol><li>在数组范围中，等概率随机选一个数作为划分值，然后把数组通过荷兰国旗问题分成三个部分：左侧 &lt; 划分值、中间 == 划分值、右侧 &gt; 划分值。</li><li>对左侧范围和右侧范围，递归执行</li><li>时间复杂度为 $O(N \log N)$【所有情况下期望】，额外空间复杂度 $O(\log N)$【期望上的长期收敛】（好情况：每次以几乎二分递归的方式，中间数是树的高度 $\log N$，坏情况：中点特别偏，树多大，栈压多少层 $N$）<div><div class="fold_hider"><div class="close hider_title">快速排序</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line"><span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">self.quickSortCore(arr, <span class="number">0</span>, len(arr)<span class="number">-1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSortCore</span><span class="params">(self, arr, l, r)</span>:</span></span><br><span class="line"><span class="keyword">if</span> l &lt; r:</span><br><span class="line">p = self.partition(arr, l, r)</span><br><span class="line">print(l, r, p)</span><br><span class="line">self.quickSortCore(arr, l, p[<span class="number">0</span>])</span><br><span class="line">self.quickSortCore(arr, p[<span class="number">1</span>]+<span class="number">1</span>, r)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, arr, l, r)</span>:</span></span><br><span class="line">print(l, r)</span><br><span class="line">less = l - <span class="number">1</span></span><br><span class="line">more = r</span><br><span class="line"><span class="keyword">while</span> l &lt; more:</span><br><span class="line"><span class="keyword">if</span> arr[l] &lt; arr[r]:</span><br><span class="line">self.swap(arr, less+<span class="number">1</span>, l)</span><br><span class="line">l += <span class="number">1</span></span><br><span class="line">less += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> arr[l] &gt; arr[r]:</span><br><span class="line">self.swap(arr, more<span class="number">-1</span>, l)</span><br><span class="line">more -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">l += <span class="number">1</span></span><br><span class="line">self.swap(arr, more, r)</span><br><span class="line"><span class="keyword">return</span> [less, more]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">temp = arr[i]</span><br><span class="line">arr[i] = arr[j]</span><br><span class="line">arr[j] = temp</span><br><span class="line">print(arr)</span><br></pre></td></tr></table></figure></div></div></li></ol></li></ol><h5 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h5><p>桶排序思想下的排序都是不基于比较的排序，时间复杂度 $O(N)$，额外空间复杂度 $O(M)$</p><ol><li>计数排序</li><li>基数排序</li></ol><h4 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h4><h5 id="面试题1：设计一个有-getMin-功能的栈"><a href="#面试题1：设计一个有-getMin-功能的栈" class="headerlink" title="面试题1：设计一个有 getMin 功能的栈"></a>面试题1：设计一个有 getMin 功能的栈</h5><p>题目：设计一个特殊栈：在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。pop、push、getMin操作的时间复杂度都是O(1)。<br>练习：<a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a>，<a href="https://leetcode-cn.com/problems/min-stack-lcci/" target="_blank" rel="noopener">面试题 03.02. 栈的最小值</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">self.stackData = []</span><br><span class="line">self.stackMin = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">self.stackData.append(x)</span><br><span class="line"><span class="keyword">if</span> self.stackMin == [] <span class="keyword">or</span> self.stackMin[<span class="number">-1</span>] &gt;= x:</span><br><span class="line">self.stackMin.append(x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">if</span> self.stackData.pop() == self.stackMin[<span class="number">-1</span>]:</span><br><span class="line">self.stackMin.pop()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.stackMin[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题2：由两个栈组成的队列"><a href="#面试题2：由两个栈组成的队列" class="headerlink" title="面试题2：由两个栈组成的队列"></a>面试题2：由两个栈组成的队列</h5><p>题目：用两个栈实现一个队列，支持队列的基本操作（add,poll,peek）<br>练习：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">面试题09. 用两个栈实现队列</a>，<a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">self.stackPush = []</span><br><span class="line">self.stackPop = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value)</span>:</span></span><br><span class="line">self.stackPush.append(value)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">if</span> self.stackPop != []:</span><br><span class="line"><span class="keyword">return</span> self.stackPop.pop()</span><br><span class="line"><span class="keyword">elif</span> self.stackPush == []:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">while</span> self.stackPush != []:</span><br><span class="line">self.stackPop.append(self.stackPush.pop())</span><br><span class="line"><span class="keyword">return</span> self.stackPop.pop()</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题3：如何仅用递归函数和栈操作逆序一个栈-★"><a href="#面试题3：如何仅用递归函数和栈操作逆序一个栈-★" class="headerlink" title="面试题3：如何仅用递归函数和栈操作逆序一个栈  ★"></a>面试题3：如何仅用递归函数和栈操作逆序一个栈  ★</h5><p>递归函数一：将栈stack的栈底元素返回并移除<br>递归函数二：逆序一个栈<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, n, stack)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> stack == []:</span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">    i = self.getAndRemoveLastElement(stack)</span><br><span class="line">    self.reverse(n<span class="number">-1</span>, stack)</span><br><span class="line">    stack.append(str(i))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(stack)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getAndRemoveLastElement</span><span class="params">(self, stack)</span>:</span></span><br><span class="line">    value = stack.pop()</span><br><span class="line">    <span class="keyword">if</span> stack == []:</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      last = self.getAndRemoveLastElement(stack)</span><br><span class="line">      stack.append(value)</span><br><span class="line">      <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题4：猫狗队列"><a href="#面试题4：猫狗队列" class="headerlink" title="面试题4：猫狗队列"></a>面试题4：猫狗队列</h5><h5 id="面试题5：用一个栈实现另一个栈的排序-★"><a href="#面试题5：用一个栈实现另一个栈的排序-★" class="headerlink" title="面试题5：用一个栈实现另一个栈的排序   ★"></a>面试题5：用一个栈实现另一个栈的排序   ★</h5><p>题目：只准许申请一个栈，从顶到底按照从大到小的顺序排序<br>练习：<a href="https://leetcode-cn.com/problems/sort-of-stacks-lcci/" target="_blank" rel="noopener">面试题 03.05. 栈排序</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sortStack</span><span class="params">(self, n, stack)</span>:</span></span><br><span class="line">    help = []</span><br><span class="line">    <span class="keyword">while</span> stack != []:</span><br><span class="line">      value = stack.pop()</span><br><span class="line">      <span class="keyword">while</span> help != [] <span class="keyword">and</span> help[<span class="number">-1</span>] &lt; value:</span><br><span class="line">        stack.append(help.pop())</span><br><span class="line">      help.append(value)</span><br><span class="line">    <span class="keyword">while</span> help != []:</span><br><span class="line">      stack.append(str(help.pop()))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(stack[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题6：用栈来解决汉诺塔问题"><a href="#面试题6：用栈来解决汉诺塔问题" class="headerlink" title="面试题6：用栈来解决汉诺塔问题"></a>面试题6：用栈来解决汉诺塔问题</h5><h5 id="面试题7：生成窗口最大值数组-★"><a href="#面试题7：生成窗口最大值数组-★" class="headerlink" title="面试题7：生成窗口最大值数组   ★"></a>面试题7：生成窗口最大值数组   ★</h5><p>题目：有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。如果数组长度为n，窗口大小为w，则一共产生n-w+1个窗口的最大值。<br>练习：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a><br>解题：利用双端队列实现窗口最大值的更新。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">1</span> <span class="keyword">or</span> k &lt; <span class="number">1</span> <span class="keyword">or</span> len(nums) &lt; k:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        qmax = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">while</span> qmax <span class="keyword">and</span> nums[qmax[<span class="number">-1</span>]] &lt;= nums[i]:</span><br><span class="line">                qmax.pop()</span><br><span class="line">            qmax.append(i)</span><br><span class="line">            <span class="keyword">if</span> qmax[<span class="number">0</span>] == i- k:</span><br><span class="line">                qmax.popleft()</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k<span class="number">-1</span>:</span><br><span class="line">                res.append(nums[qmax[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题8：单调栈结构-★"><a href="#面试题8：单调栈结构-★" class="headerlink" title="面试题8：单调栈结构   ★"></a>面试题8：单调栈结构   ★</h5><p>题目：给定一个不含有重复值的数组arr，找到每一个i位置左边和右边离i位置最近且值比arr[i]小的位置。返回所有位置相应的信息 。<br>练习：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a><br>解题：准备一个栈，存放元素在数组中的位置。 如果找到每一个i位置左边和右边离i位置最近且值比arr[i]小的位置，那么需要让stack从栈顶到栈底的位置所代表的值是严格递减的；如果找到每一个i位置左边和右边离i位置最近且值比arr[i]大的位置，那么需要让stack从栈顶到栈底的位置所代表的值是严格递增的。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getnearestsmaller</span><span class="params">(self, n, nums)</span>:</span></span><br><span class="line">    res = [[<span class="number">-1</span>, <span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">      <span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>]] &gt; nums[i]:</span><br><span class="line">        value = stack.pop()</span><br><span class="line">        left = stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        res[value] = [left, i]</span><br><span class="line">      stack.append(i)</span><br><span class="line">    <span class="keyword">while</span> stack != []:</span><br><span class="line">      value = stack.pop()</span><br><span class="line">      left = stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">      res[value] = [left, <span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div></p><p>进阶问题：给定一个可能含有重复值的数组arr，找到每一个i位置左边和右边离i位置最近且值比arr[i]小的位置。返回所有位置相应的信息。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNearsLess</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">res = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>][<span class="number">0</span>]] &gt; nums[i]:</span><br><span class="line">value = stack.pop()</span><br><span class="line">left = stack[<span class="number">-1</span>][<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> value:</span><br><span class="line">res[j] = [left, i]</span><br><span class="line"><span class="keyword">if</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>][<span class="number">0</span>]] == nums[i]:</span><br><span class="line">stack[<span class="number">-1</span>].append(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">stack.append([i])</span><br><span class="line"><span class="keyword">while</span> stack != []:</span><br><span class="line">value = stack.pop()</span><br><span class="line">left = stack[<span class="number">-1</span>][<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> value:</span><br><span class="line">res[j] = [left, <span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题9：求最大子矩阵的大小-★"><a href="#面试题9：求最大子矩阵的大小-★" class="headerlink" title="面试题9：求最大子矩阵的大小   ★"></a>面试题9：求最大子矩阵的大小   ★</h5><p>题目：给定一个整型矩阵map，其中的值只有0和1两种，求其中全是1的所有矩形区域中，最大的矩形区域为1的数量。<br>练习：<a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85. 最大矩形</a><br>解题：以矩形的每一行为底，统计以当前行作为底的情况下，每个位置往上1的数量，使用高度数组height表示，并利用每次更新后的height数组求出以当前行为底的情况下，最大矩形。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        rows = len(matrix)</span><br><span class="line">        cols = len(matrix[<span class="number">0</span>])</span><br><span class="line">        heights = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(cols)]</span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    heights[j] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    heights[j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[<span class="number">-1</span>]] &gt;= heights[j]:</span><br><span class="line">                    index = stack.pop()</span><br><span class="line">                    k = stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">                    res = max(res, heights[index]*(j-k<span class="number">-1</span>))</span><br><span class="line">                stack.append(j)</span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                index = stack.pop()</span><br><span class="line">                k = stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">                res = max(res, heights[index]*(cols-k<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题10：最大值减去最小值小于或等于-num-的子数组数量"><a href="#面试题10：最大值减去最小值小于或等于-num-的子数组数量" class="headerlink" title="面试题10：最大值减去最小值小于或等于 num 的子数组数量"></a>面试题10：最大值减去最小值小于或等于 num 的子数组数量</h5><p>题目： 给定数组arr和整数num，共返回有多少个子数组满足如下情况：max(arr[i..j]) - min(arr[i..j]) &lt;= num；max(arr[i..j])表示子数组arr[i..j]中的最大值，min(arr[i..j])表示子数组arr[i..j]中的最小值。<br>解法：使用两个双端队列，qmax维护子窗口数组的最大值，qmin维护子窗口数组的最小值。 如果子数组arr[i..j]满足条件，即max(arr[i..j])-min(arr[i..j])&lt;=num，那么arr[i..j]中的每一个子数组，即arr[k..l]（i≤k≤l≤j）都满足条件； 如果子数组arr[i..j]不满足条件，那么所有包含arr[i..j]的子数组，即arr[k..l]（k≤i≤j≤l）都不满足条件。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getNum</span><span class="params">(self, nums, n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span> <span class="keyword">or</span> n &lt; <span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    qmax = []</span><br><span class="line">    qmin = []</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">      <span class="keyword">while</span> j &lt; len(nums):</span><br><span class="line">        <span class="keyword">while</span> qmax <span class="keyword">and</span> nums[qmax[<span class="number">-1</span>]] &lt;= nums[j]:</span><br><span class="line">          qmax.pop()</span><br><span class="line">        qmax.append(j)</span><br><span class="line">        <span class="keyword">while</span> qmin <span class="keyword">and</span> nums[qmin[<span class="number">-1</span>]] &gt;= nums[j]:</span><br><span class="line">          qmin.pop()</span><br><span class="line">        qmin.append(j)</span><br><span class="line">        <span class="keyword">if</span> nums[qmax[<span class="number">0</span>]] - nums[qmin[<span class="number">0</span>]] &gt; n:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">      res += j -i</span><br><span class="line">      <span class="keyword">if</span> qmax[<span class="number">0</span>] == i:qmax.pop(<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">if</span> qmin[<span class="number">0</span>] == i:qmin.pop(<span class="number">0</span>)</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题11：可见的山峰对数量"><a href="#面试题11：可见的山峰对数量" class="headerlink" title="面试题11：可见的山峰对数量"></a>面试题11：可见的山峰对数量</h5><p>题目： 一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度。3-&gt;1-&gt;2-&gt;4-&gt;5-&gt;3方向叫  作next方向（逆时针），3-&gt;5-&gt;4-&gt;2-&gt;1-&gt;3方向叫作last方向（  顺时针。<br>要求：arr长度为N，没有重复值的情况下时间复杂度达到O(1)，可能有重复值的情况下时间复杂度请达到O(N)。<br>原问题：数组中没有重复值。可见山峰对的数量可以由公式得到。小找大原则找到的山峰对的数量就是总的可见山峰对数量。公式：2*i-3对。<br>进阶问题： 给定一个不含有负数但可能含有重复值的数组arr，返回有多少对山峰能够相互看见。 单调栈。<br>练习：<a href="https://www.nowcoder.com/practice/16d1047e9fa54cea8b5170b156d89e38?tpId=101&amp;tqId=33173&amp;tPage=6&amp;rp=1&amp;ru=%2Fta%2Fprogrammer-code-interview-guide&amp;qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking" target="_blank" rel="noopener">可见的山峰对数量</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    self.val = x</span><br><span class="line">    self.times = <span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getVisibleNum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    size = len(nums)</span><br><span class="line">    maxIndex = nums.index(max(nums))</span><br><span class="line">    stack = []</span><br><span class="line">    stack.append(Record(nums[maxIndex]))</span><br><span class="line">    index = maxIndex + <span class="number">1</span> <span class="keyword">if</span> maxIndex &lt; size - <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index != maxIndex:</span><br><span class="line">      <span class="keyword">while</span> stack[<span class="number">-1</span>].val &lt; nums[index]:</span><br><span class="line">        k = stack.pop().times</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>: res += <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>: res += <span class="number">2</span> * k + (k*(k<span class="number">-1</span>)//<span class="number">2</span>)</span><br><span class="line">      <span class="keyword">if</span> stack[<span class="number">-1</span>].val == nums[index]:</span><br><span class="line">        stack[<span class="number">-1</span>].times += <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        stack.append(Record(nums[index]))</span><br><span class="line">      index = index + <span class="number">1</span> <span class="keyword">if</span> index &lt; size <span class="number">-1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> len(stack) &gt; <span class="number">2</span>:</span><br><span class="line">      k = stack.pop().times</span><br><span class="line">      <span class="keyword">if</span> k == <span class="number">1</span>: res += <span class="number">2</span></span><br><span class="line">      <span class="keyword">else</span>: res += <span class="number">2</span> * k + (k*(k<span class="number">-1</span>)//<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> len(stack) == <span class="number">2</span>:</span><br><span class="line">      k = stack.pop().times</span><br><span class="line">      <span class="keyword">if</span> stack[<span class="number">-1</span>].times == <span class="number">1</span>:res += k</span><br><span class="line">      <span class="keyword">else</span>: res += <span class="number">2</span>*k</span><br><span class="line">      <span class="keyword">if</span> k != <span class="number">1</span>:res += (k*(k<span class="number">-1</span>)//<span class="number">2</span>)</span><br><span class="line">    k = stack.pop().times</span><br><span class="line">    res += (k*(k<span class="number">-1</span>)//<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div></p><h5 id="指标A最大"><a href="#指标A最大" class="headerlink" title="指标A最大"></a>指标A最大</h5><p>题目：数组中累积和与最小值的乘积，叫做指标A，请返回子数组中指标A最大的值。<br>技巧：快速得到[a, …, b]范围上的累加和——数据预处理生成一个前缀和数组——sum[a, .., b] = sum[b] - sum[a-1]<br>解题：单调栈<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IndexA</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">pre_sum = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">pre_sum[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">pre_sum[i] = pre_sum[i<span class="number">-1</span>] + nums[i]</span><br><span class="line">maxA = float(<span class="string">'-inf'</span>)</span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>]] &gt;= nums[i]:</span><br><span class="line">index = stack.pop()</span><br><span class="line">left = stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">tmp = <span class="number">0</span> <span class="keyword">if</span> left &lt; <span class="number">0</span> <span class="keyword">else</span> pre_sum[left]</span><br><span class="line">maxA = max(maxA, nums[index]*(pre_sum[i<span class="number">-1</span>]-tmp))</span><br><span class="line">stack.append(i)</span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">index = stack.pop()</span><br><span class="line">left = stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">tmp = <span class="number">0</span> <span class="keyword">if</span> left &lt; <span class="number">0</span> <span class="keyword">else</span> pre_sum[left]</span><br><span class="line">maxA = max(maxA, nums[index]*(pre_sum[len(nums)<span class="number">-1</span>]-tmp))</span><br><span class="line"><span class="keyword">return</span> maxA</span><br></pre></td></tr></table></figure></div></div></p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h5 id="面试题1：打印两个有序链表的公共部分"><a href="#面试题1：打印两个有序链表的公共部分" class="headerlink" title="面试题1：打印两个有序链表的公共部分"></a>面试题1：打印两个有序链表的公共部分</h5><p>题目：给定两个有序链表的头指针head1和head2，打印两个链表的公共部分。<br>解题：有序链表，从两个链表的头开始进行，若head1的值小于head2，则head1往下移动，若大于，head2往下移动，若相等打印，一起移动。<br>练习：<a href="https://www.nowcoder.com/practice/8943eea40dbb4185b187d80fd050fee9?tpId=101&amp;tqId=33116&amp;tPage=1&amp;rp=1&amp;ru=/ta/programmer-code-interview-guide&amp;qru=/ta/programmer-code-interview-guide/question-ranking" target="_blank" rel="noopener">打印两个有序链表的公共部分</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printCommonPart</span><span class="params">(self, head1, head2)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> head1 != <span class="literal">None</span> <span class="keyword">and</span> head2 != <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">if</span> head1.val &gt; head2.val:</span><br><span class="line">        head2 = head2.next</span><br><span class="line">      <span class="keyword">elif</span> head1.val &lt; head2.val:</span><br><span class="line">        head1 = head1.next</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        res.append(str(head1.val))</span><br><span class="line">        head1 = head1.next</span><br><span class="line">        head2 = head2.next</span><br><span class="line">    print(<span class="string">' '</span>.join(res)) <span class="keyword">if</span> res <span class="keyword">else</span> print(<span class="string">'None'</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题2：在单链表和双链表中删除倒数第-k-个节点"><a href="#面试题2：在单链表和双链表中删除倒数第-k-个节点" class="headerlink" title="面试题2：在单链表和双链表中删除倒数第 k 个节点"></a>面试题2：在单链表和双链表中删除倒数第 k 个节点</h5><p>题目： 一个可以删除单链表中倒数第K个节点，另一个可以删除双链表中倒数第K个节点。<br>练习：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a><br>解题： 如果链表长度为N，要删除倒数第K个节点，倒数第K个节点的前一个节点就是第N-K个节点。在第一次遍历后，K的值变为K-N。第二次遍历时，K的值不断加1，加到0就停止遍历，第二次遍历当然会停到第N-K个节点的位置 (0-(K-N)=N-K)。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> k &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node != <span class="literal">None</span>:</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head.next</span><br><span class="line">        <span class="keyword">elif</span> k &lt; <span class="number">0</span>:</span><br><span class="line">            node = head</span><br><span class="line">            <span class="keyword">while</span> k+<span class="number">1</span> != <span class="number">0</span>:</span><br><span class="line">                node = node.next</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            node.next = node.next.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></div></div></p><p>双链表：与单链表基本相同<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> k &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node != <span class="literal">None</span>:</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            head = head.next</span><br><span class="line">            head.last = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">            node = head</span><br><span class="line">            <span class="keyword">while</span> k+<span class="number">1</span> != <span class="number">0</span>:</span><br><span class="line">                node = node.next</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            newNext = node.next.next</span><br><span class="line">            node.next = newNext</span><br><span class="line">            <span class="keyword">if</span> newNext != <span class="literal">None</span>:</span><br><span class="line">                newNext.last = node</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题3：删除链表的中间节点和-a-b-处的节点"><a href="#面试题3：删除链表的中间节点和-a-b-处的节点" class="headerlink" title="面试题3：删除链表的中间节点和 a/b 处的节点"></a>面试题3：删除链表的中间节点和 a/b 处的节点</h5><p>题目：删除链表的中间节点。如果链表为空或长度为1，不需要调整，如果链表长度为2，删除头节点，如果链表长度为3，删除第2个节点，链表长度为4，删除第2个节点，链表长度为5，删除第3个节……链表长度每增加2，要删除的节点就向后移动一个。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">removeMidNode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.next == <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">if</span> head.next.next == <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span> head.next</span><br><span class="line">    pre = head</span><br><span class="line">    cur = head.next.next</span><br><span class="line">    <span class="keyword">while</span> cur.next != <span class="literal">None</span> <span class="keyword">and</span> cur.next.next != <span class="literal">None</span>:</span><br><span class="line">      pre = pre.next</span><br><span class="line">      cur = cur.next.next</span><br><span class="line">    pre.next = pre.next.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题4：反转单向和双向链表"><a href="#面试题4：反转单向和双向链表" class="headerlink" title="面试题4：反转单向和双向链表"></a>面试题4：反转单向和双向链表</h5><p>题目：反转单向链表<br>练习：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">面试题24. 反转链表</a>，<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head != <span class="literal">None</span>:</span><br><span class="line">            tmp = head.next</span><br><span class="line">            head.next = pre</span><br><span class="line">            pre = head</span><br><span class="line">            head = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></div></div></p><p>题目：反转双向链表<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">pre = <span class="literal">None</span></span><br><span class="line"><span class="keyword">while</span> head != <span class="literal">None</span>:</span><br><span class="line">tmp = head.next</span><br><span class="line">head.next = pre</span><br><span class="line">head.last = tmp</span><br><span class="line">pre = head</span><br><span class="line">head = tmp</span><br><span class="line"><span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题5：反转部分单向链表"><a href="#面试题5：反转部分单向链表" class="headerlink" title="面试题5：反转部分单向链表"></a>面试题5：反转部分单向链表</h5><p>题目： 给定一个单向链表的头节点head，以及两个整数from和to，在单向链表上把第from个节点到第to个节点这一部分进行反转。<br>练习：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        res = ListNode(<span class="literal">None</span>)</span><br><span class="line">        res.next = head</span><br><span class="line">        pre = res</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(m<span class="number">-1</span>):</span><br><span class="line">            pre = pre.next</span><br><span class="line">        cur = pre.next</span><br><span class="line">        node = cur</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n-m):</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = tmp.next</span><br><span class="line">            tmp.next = node</span><br><span class="line">            node = tmp</span><br><span class="line">        pre.next = node</span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题6：环形单链表的约瑟夫问题"><a href="#面试题6：环形单链表的约瑟夫问题" class="headerlink" title="面试题6：环形单链表的约瑟夫问题"></a>面试题6：环形单链表的约瑟夫问题</h5><p>题目： 41个人排成一个圆圈，由第1个人开始报数，报数到3的人就自杀，然后再由下一个人重新报1，报数到3的人再自杀，这样依次下去，直到剩下最后一个人时，那个人可以自由选择自己的命运。这就是著名的约瑟夫问题。 节点数为N，时间复杂度O(N)完成。</p><p>练习：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题62. 圆圈中最后剩下的数字</a>  </p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n: int, m: int)</span> -&gt; int:</span></span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            f = (m + f) % i</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题7：判断一个链表是否为回文结构"><a href="#面试题7：判断一个链表是否为回文结构" class="headerlink" title="面试题7：判断一个链表是否为回文结构"></a>面试题7：判断一个链表是否为回文结构</h5><p>要求：链表长度为N，时间复杂度为O(N)，额外空间复杂度O(1)</p><p>练习：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a>   <a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank" rel="noopener">面试题 02.06. 回文链表</a></p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        node1 = node2 = head</span><br><span class="line">        <span class="keyword">while</span> node2.next != <span class="literal">None</span> <span class="keyword">and</span> node2.next.next != <span class="literal">None</span>:</span><br><span class="line">            node1 = node1.next</span><br><span class="line">            node2 = node2.next.next</span><br><span class="line">        node2 = node1.next</span><br><span class="line">        node1.next = <span class="literal">None</span></span><br><span class="line">        node3 = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> node2 != <span class="literal">None</span>:</span><br><span class="line">            node3 = node2.next</span><br><span class="line">            node2.next = node1</span><br><span class="line">            node1 = node2</span><br><span class="line">            node2 = node3</span><br><span class="line">        node3 = node1</span><br><span class="line">        node2 = head</span><br><span class="line">        res = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> node1 != <span class="literal">None</span> <span class="keyword">and</span> node2 != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node1.val != node2.val:</span><br><span class="line">                res = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            node1 = node1.next</span><br><span class="line">            node2 = node2.next</span><br><span class="line">        node1 = node3.next</span><br><span class="line">        node3.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> node1 != <span class="literal">None</span>:</span><br><span class="line">            node2 = node1.next</span><br><span class="line">            node1.next = node3</span><br><span class="line">            node3 = node1</span><br><span class="line">            node1 = node2</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式"><a href="#面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式" class="headerlink" title="面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式"></a>面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式</h5><p>题目： 将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。 每个部分里的节点从左到右的顺序于原链表中节点的先后次序一致，且若链表长度为N，则时间复杂度为O(N)，额外空间复杂度为O(1)<br>练习：<a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表</a>  <a href="https://leetcode-cn.com/problems/partition-list-lcci/" target="_blank" rel="noopener">面试题 02.04. 分割链表</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">        small = small_head = ListNode(<span class="literal">None</span>)</span><br><span class="line">        equal = equal_head = ListNode(<span class="literal">None</span>)</span><br><span class="line">        big = big_head = ListNode(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> head != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">                small.next = head</span><br><span class="line">                small = small.next</span><br><span class="line">            <span class="keyword">elif</span> head.val == x:</span><br><span class="line">                equal.next = head</span><br><span class="line">                equal = equal.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                big.next = head</span><br><span class="line">                big = big.next</span><br><span class="line">            head = head.next</span><br><span class="line">        big.next = <span class="literal">None</span></span><br><span class="line">        equal.next = big_head.next</span><br><span class="line">        small.next = equal_head.next</span><br><span class="line">        <span class="keyword">return</span> small_head.next</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题9：复制含有随机指针节点的链表"><a href="#面试题9：复制含有随机指针节点的链表" class="headerlink" title="面试题9：复制含有随机指针节点的链表"></a>面试题9：复制含有随机指针节点的链表</h5><p>练习：<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. 复制带随机指针的链表</a>  <a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">面试题35. 复杂链表的复制</a><br>要求：时间复杂度O(N)，额外空间复杂度O(1)<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        org = head</span><br><span class="line">        <span class="keyword">while</span> org != <span class="literal">None</span>:</span><br><span class="line">            node = Node(org.val)</span><br><span class="line">            next = org.next</span><br><span class="line">            org.next = node</span><br><span class="line">            node.next = next</span><br><span class="line">            org = next</span><br><span class="line">        org = head</span><br><span class="line">        <span class="keyword">while</span> org != <span class="literal">None</span>:</span><br><span class="line">            org.next.random = org.random.next <span class="keyword">if</span> org.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            org = org.next.next</span><br><span class="line">        org = head</span><br><span class="line">        res = pre = head.next</span><br><span class="line">        <span class="keyword">while</span> org != <span class="literal">None</span>:</span><br><span class="line">            org.next = pre.next</span><br><span class="line">            org = org.next</span><br><span class="line">            pre.next = org.next <span class="keyword">if</span> org <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题10：两个单链表生成相加链表"><a href="#面试题10：两个单链表生成相加链表" class="headerlink" title="面试题10：两个单链表生成相加链表"></a>面试题10：两个单链表生成相加链表</h5><p>练习：<a href="https://leetcode-cn.com/problems/sum-lists-lcci/" target="_blank" rel="noopener">面试题 02.05. 链表求和</a>  <a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">445. 两数相加 II</a>  <a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a><br><div><div class="fold_hider"><div class="close hider_title">不修改链表</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">   s1, s2 = [], []</span><br><span class="line">        <span class="keyword">while</span> l1 != <span class="literal">None</span>:</span><br><span class="line">            s1.append(l1.val)</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        <span class="keyword">while</span> l2 != <span class="literal">None</span>:</span><br><span class="line">            s2.append(l2.val)</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        head = <span class="literal">None</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> s1 != [] <span class="keyword">and</span> s2 != []:</span><br><span class="line">            digit = s1.pop() + s2.pop() + cur</span><br><span class="line">            node = ListNode(digit%<span class="number">10</span>)</span><br><span class="line">            node.next = head</span><br><span class="line">            head = node</span><br><span class="line">            cur = digit // <span class="number">10</span></span><br><span class="line">        s = s1 <span class="keyword">if</span> s1 != [] <span class="keyword">else</span> s2</span><br><span class="line">        <span class="keyword">while</span> s != []:</span><br><span class="line">            digit = s.pop() + cur</span><br><span class="line">            node = ListNode(digit%<span class="number">10</span>)</span><br><span class="line">            node.next = head</span><br><span class="line">            head = node</span><br><span class="line">            cur = digit // <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> cur == <span class="number">1</span>:</span><br><span class="line">            node = ListNode(<span class="number">1</span>)</span><br><span class="line">            node.next = head</span><br><span class="line">            head = node</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></div></div><br><div><div class="fold_hider"><div class="close hider_title">修改链表</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        l1 = self.reverse(l1)</span><br><span class="line">        l2 = self.reverse(l2)</span><br><span class="line">        ca = <span class="number">0</span></span><br><span class="line">        head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            n1 = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n2 = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n = n1 + n2 + ca</span><br><span class="line">            node = ListNode(n%<span class="number">10</span>)</span><br><span class="line">            node.next = head</span><br><span class="line">            head = node</span><br><span class="line">            ca = n // <span class="number">10</span></span><br><span class="line">            l1 = l1.next <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            l2 = l2.next <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> ca == <span class="number">1</span>:</span><br><span class="line">            node = ListNode(<span class="number">1</span>)</span><br><span class="line">            node.next = head</span><br><span class="line">            head = node</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head != <span class="literal">None</span>:</span><br><span class="line">            tmp = head.next</span><br><span class="line">            head.next = pre</span><br><span class="line">            pre = head</span><br><span class="line">            head = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题11：两个单链表相交的一系列问题"><a href="#面试题11：两个单链表相交的一系列问题" class="headerlink" title="面试题11：两个单链表相交的一系列问题"></a>面试题11：两个单链表相交的一系列问题</h5><p>题目： 单链表可能有环，也可能无环。给定两个单链表的头节点head1和head2，这两个链表可能相交，也可能不相交。请实现一个函数，如果两个链表相交，请返回相交的第一个节点；如果不相交，返回null即可。 </p><p>要求： 如果链表1的长度为N，链表2的长度为M，时间复杂度请达到O(N+M)，额外空间复杂度请达到O(1)。 </p><p>拆分问题：</p><p>问题一：链表是否有环，如果有，则返回第一个进入环的节点。<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a>  <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></p><p>解题： 1．设置一个慢指针slow和一个快指针fast。在开始时，slow和fast都指向链表的头节点head。然后slow每次移动一步，fast每次移动两步，在链表中遍历起来。2．如果链表无环，那么fast指针在移动过程中一定先遇到终点，一旦fast到达终点，说明链表是没有环的，直接返回null，表示该链表无环，当然也没有第一个入环的节点。 3．如果链表有环，那么fast指针和slow指针一定会在环中的某个位置相遇，当fast和slow相遇时，fast指针重新回到head的位置，slow指针不动。接下来，fast指针从每次移动两步改为每次移动一步，slow指针依然每次移动一步，然后继续遍历。4．fast指针和slow指针一定会再次相遇，并且在第一个入环的节点处相遇。</p><div><div class="fold_hider"><div class="close hider_title">链表是否有环</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.next == <span class="literal">None</span> <span class="keyword">or</span> head.next.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        slow = head.next</span><br><span class="line">        fast = head.next.next</span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="keyword">if</span> fast.next == <span class="literal">None</span> <span class="keyword">or</span> fast.next.next == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            fast = fast.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure></div></div><p>问题二：两个无环链表是否相交，相交返回第一个相交节点。<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a>  <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/" target="_blank" rel="noopener">面试题 02.07. 链表相交</a></p><div><div class="fold_hider"><div class="close hider_title">两个无环链表相交</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        node1 = headA</span><br><span class="line">        node2 = headB</span><br><span class="line">        <span class="keyword">while</span> node1 != node2:</span><br><span class="line">            node1 = node1.next <span class="keyword">if</span> node1 <span class="keyword">else</span> headB</span><br><span class="line">            node2 = node2.next <span class="keyword">if</span> node2 <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> node1</span><br></pre></td></tr></table></figure></div></div><p>问题三：两个有环链表是否相交，相交返回第一个相交节点。</p><p>解题：假设已经得到了两个链表各自的第一个入环节点，loop1和loop2。如果loop1==loop2， 只要考虑链表1从头开始到loop1这一段与链表2从头开始到loop2这一段，在那里第一次相交即可，而不用考虑进环该怎么处理，与问题二类似，只不过问题二是把null作为一个链表的终点，而这里是把loop1(loop2)作为链表的终点。但是判断的主要过程是相同的；如果loop1 != loop2， 让链表1从loop1出发，因为loop1和之后的所有节点都在环上，所以将来一定能回到loop1。如果回到loop1之前并没有遇到loop2，说明两个链表不相交， 如果回到loop1之前遇到了loop2，说明两个链表相交。因为loop1和loop2都在两条链表上，只不过loop1是离链表1较近的节点，loop2是离链表2较近的节点。所以，此时返回loop1或loop2都可以。</p><h5 id="面试题12：将单链表的每-K-个节点之间逆序"><a href="#面试题12：将单链表的每-K-个节点之间逆序" class="headerlink" title="面试题12：将单链表的每 K 个节点之间逆序"></a>面试题12：将单链表的每 K 个节点之间逆序</h5><p>题目：给定一个单链表的头节点head，实现一个调整单链表的函数，使得每K个节点之间逆序，如果最后不够K个节点一组，则不调整最后几个节点。 </p><p>练习：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a></p><p>解题：若K&lt;2，则不用做任何调整；使用栈结构得解法：时间复杂度O(N)，额外空间复杂度O(k)，从左到右遍历链表，如果栈的大小不等于K，就将节点不断压入栈中，当栈的大小第一次达到K时，从栈中依次弹出这些节点，并根据弹出顺序重新连接，完成逆序后纪录新的头部和尾部。不使用栈结构的解法：时间复杂度O(N)，额外空间复杂度O(k)，用变量纪录每一组开始的第一个节点和最后一个节点，直接逆序调整。</p><div><div class="fold_hider"><div class="close hider_title">不使用栈方法的逆序</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题13：删除无序单链表中值重复出现的节点"><a href="#面试题13：删除无序单链表中值重复出现的节点" class="headerlink" title="面试题13：删除无序单链表中值重复出现的节点"></a>面试题13：删除无序单链表中值重复出现的节点</h5><p>题目： 给定一个无序单链表的头节点head，删除其中值重复出现的节点。 </p><p>练习：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a>  <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a></p><p>解题：使用哈希表：时间复杂度O(N)，额外空间复杂度O(N)，生成一个哈希表，头节点是不用删除的节点，首先将头节点的值放入哈希表中，从头节点的下一个节点开始往后遍历节点， 假设当前遍历到cur节点，先检查cur的值是否在哈希表中，如果在，则说明cur节点的值是之前出现过的，就将cur节点删除，删除的方式是将最近一个没有被删除的节点pre连接到cur的下一个节点，即pre.next=cur.next。如果不在，将cur节点的值加入哈希表，同时令pre=cur，即更新最近一个没有被删除的节点。</p><div><div class="fold_hider"><div class="close hider_title">使用哈希表</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><p>不使用哈希表：类似选择排序，时间复杂度O(N^2)，额外空间复杂度O(1)</p><div><div class="fold_hider"><div class="close hider_title">不使用哈希表</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题14：在单链表中删除指定值的节点"><a href="#面试题14：在单链表中删除指定值的节点" class="headerlink" title="面试题14：在单链表中删除指定值的节点"></a>面试题14：在单链表中删除指定值的节点</h5><p>题目： 给定一个链表的头节点head和一个整数num，请实现函数将值为num的节点全部删除。 </p><p>练习：<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. 移除链表元素</a>  <a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">237. 删除链表中的节点</a>  <a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">面试题18. 删除链表的节点</a></p><div><div class="fold_hider"><div class="close hider_title">删除指定节点</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题15：将搜索二叉树转换成双向链表"><a href="#面试题15：将搜索二叉树转换成双向链表" class="headerlink" title="面试题15：将搜索二叉树转换成双向链表"></a>面试题15：将搜索二叉树转换成双向链表</h5><p>题目：一棵搜索二叉树，请将其转换为一个有序的双向链表 </p><p>练习：<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a>  <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">面试题36. 二叉搜索树与双向链表</a>  <a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a>  leetcode 426</p><p>解题：利用递归函数，中序遍历，时间复杂度O(N)，额外空间复杂度O(h)，具体过程是先把 以X为头的搜索二叉树的左子树转换为有序双向链表，并且返回左子树有序双向链表的头和尾，然后把以X为头的搜索二叉树的右子树转换为有序双向链表，并且返回右子树有序双向链表的头和尾，接着通过X把两部分接起来即可。</p><div><div class="fold_hider"><div class="close hider_title">搜索二叉树——双向链表</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题16：单链表的选择排序"><a href="#面试题16：单链表的选择排序" class="headerlink" title="面试题16：单链表的选择排序"></a>面试题16：单链表的选择排序</h5><p>题目： 给定一个无序单链表的头节点head，实现单链表的选择排序。额外空间复杂度O(1) </p><p>练习：<a href="https://leetcode-cn.com/problems/insertion-sort-list/" target="_blank" rel="noopener">147. 对链表进行插入排序</a>    <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a></p><p>解题：选择排序是从未排序的部分中找到最小值，然后放在排好序部分的尾部，逐渐将未排序的部分缩小。时间复杂度为O(N^2)</p><div><div class="fold_hider"><div class="close hider_title">链表排序</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题17：一种怪异的节点删除方式"><a href="#面试题17：一种怪异的节点删除方式" class="headerlink" title="面试题17：一种怪异的节点删除方式"></a>面试题17：一种怪异的节点删除方式</h5><p>题目：链表节点值类型为int型，给定一个链表中的节点node，但不给定整个链表的头节点。在链表中删除node？请实现这个函数，并分析这样做会出现哪些问题。要求：时间复杂度为O(1)。 </p><p>解题：将要删除的节点的值变成其下一个节点的值，删除下一个节点。</p><p>存在问题：第一无法删除最后一个节点；第二这种删除方法在工程上存在很大的问题。</p><h5 id="面试题18：向有序的环形单链表中插入新节点"><a href="#面试题18：向有序的环形单链表中插入新节点" class="headerlink" title="面试题18：向有序的环形单链表中插入新节点"></a>面试题18：向有序的环形单链表中插入新节点</h5><p>题目：一个环形单链表从头节点head开始不降序，同时由最后的节点指回头节点。给定这样一个环形单链表的头节点head和一个整数num，请生成节点值为num的新节点，并插入到这个环形链表中，保证调整后的链表依然有序。</p><p> 具体过程：</p><ol><li><h5 id="面试题19：合并两个有序的单链表"><a href="#面试题19：合并两个有序的单链表" class="headerlink" title="面试题19：合并两个有序的单链表"></a>面试题19：合并两个有序的单链表</h5></li></ol><p>题目：给定两个有序单链表的头节点head1和head2，请合并两个有序链表，合并后的链表依然有序，并返回合并后链表的头节点。</p><p>练习：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a>  <a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">面试题25. 合并两个排序的链表</a>  <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a></p><div><div class="fold_hider"><div class="close hider_title">链表合并</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题20：按照左右半区的方式重新组合单链表"><a href="#面试题20：按照左右半区的方式重新组合单链表" class="headerlink" title="面试题20：按照左右半区的方式重新组合单链表"></a>面试题20：按照左右半区的方式重新组合单链表</h5><p>题目： 给定一个单链表的头部节点head，链表长度为N，如果N为偶数，那么前N/2个节点算作左半区，后N/2个节点算作右半区；如果N为奇数，那么前N/2个节点算作左半区，后N/2 + 1个节点算作右半区。左半区从左到右依次记为L1-&gt;L2-&gt;…，右半区从左到右依次记为R1-&gt;R2-&gt;…，请将单链表调整成L1-&gt;R1-&gt;L2-&gt;R2-&gt;…的 形式 </p><p>练习：<a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. 重排链表</a></p><p>解题：时间复杂度为O(N)，额外空间复杂度为O(1)的解法：将链表分成左半区和右半区，将右半区逆序，最后合并两个链表。</p><div><div class="fold_hider"><div class="close hider_title">链表重排</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历"><a href="#面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历" class="headerlink" title="面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历"></a>面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历</h5><p>题目： 用递归和非递归方式，分别按照二叉树先序、中序和后序打印所有的节点。我们约定：先序遍历顺序为根、左、右；中序遍历顺序为左、根、右；后序遍历顺序为左、右、 根 </p><ol><li><p>二叉树的先序遍历，练习：<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></p><div><div class="fold_hider"><div class="close hider_title">递归先序遍历</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></div></div><div><div class="fold_hider"><div class="close hider_title">非递归先序遍历</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></div></div></li><li><p>二叉树的中序遍历，练习：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></p><div><div class="fold_hider"><div class="close hider_title">递归中序遍历</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></div></div><div><div class="fold_hider"><div class="close hider_title">非递归中序遍历</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></div></div></li><li><p>二叉树的后序遍历，练习：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></p><div><div class="fold_hider"><div class="close hider_title">递归后序遍历</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></div></div><div><div class="fold_hider"><div class="close hider_title">非递归后序遍历</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></div></div></li><li><p>二叉树的层序遍历，练习：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a> <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. 二叉树的层次遍历 II</a></p><div><div class="fold_hider"><div class="close hider_title">层序遍历</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></div></div></li><li><p>二叉树的垂序遍历，练习：<a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="noopener">987. 二叉树的垂序遍历</a></p><div><div class="fold_hider"><div class="close hider_title">垂序遍历</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></div></div></li></ol><h5 id="面试题2：打印二叉树的边界节点"><a href="#面试题2：打印二叉树的边界节点" class="headerlink" title="面试题2：打印二叉树的边界节点"></a>面试题2：打印二叉树的边界节点</h5><p>题目：给定一棵二叉树的头节点head，按照如下两种标准分别实现二叉树边界节点的逆时针打印。</p><p>标准一：1．头节点为边界节点。2．叶节点为边界节点。3．如果节点在其所在的层中是最左的或最右的，那么该节点也是边界节点。</p><p>标准二：1．头节点为边界节点。2．叶节点为边界节点。3．树左边界延伸下去的路径为边界节点。4．树右边界延伸下去的路径为边界节点。 </p><p>练习：Leetcode 545</p><p>要求：1. 如果节点数为N，两种标准实现的时间复杂度要求都为O(N)，额外空间复杂度要求都为O(h)，h为二叉树的高度。2．两种标准都要求逆时针顺序且不重复打印所有的边界节点。 </p><h5 id="面试题3：如何较为直观地打印二叉树"><a href="#面试题3：如何较为直观地打印二叉树" class="headerlink" title="面试题3：如何较为直观地打印二叉树"></a>面试题3：如何较为直观地打印二叉树</h5><p>练习：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题32 - I. 从上到下打印二叉树</a>  <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">面试题32 - II. 从上到下打印二叉树 II</a>  <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">面试题32 - III. 从上到下打印二叉树 III</a></p><h5 id="面试题4：二叉树地序列化和反序列化"><a href="#面试题4：二叉树地序列化和反序列化" class="headerlink" title="面试题4：二叉树地序列化和反序列化"></a>面试题4：二叉树地序列化和反序列化</h5><p>题目： 二叉树被记录成文件的过程叫作二叉树的序列化，通过文件内容重建原来二叉树的过程叫作二叉树的反序列化。 </p><p>练习：<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题37. 序列化二叉树</a>  <a href="https://leetcode-cn.com/problems/bst-sequences-lcci/" target="_blank" rel="noopener">面试题 04.09. 二叉搜索树序列</a>  <a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/" target="_blank" rel="noopener">449. 序列化和反序列化二叉搜索树</a>  <a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. 二叉树的序列化与反序列化</a></p><h5 id="面试题5：遍历二叉树地神级方法"><a href="#面试题5：遍历二叉树地神级方法" class="headerlink" title="面试题5：遍历二叉树地神级方法"></a>面试题5：遍历二叉树地神级方法</h5><h5 id="面试题6：在二叉树中找到累加和为指定值地最长路径长度"><a href="#面试题6：在二叉树中找到累加和为指定值地最长路径长度" class="headerlink" title="面试题6：在二叉树中找到累加和为指定值地最长路径长度"></a>面试题6：在二叉树中找到累加和为指定值地最长路径长度</h5><h5 id="面试题7：找到二叉树中最大搜索二叉子数"><a href="#面试题7：找到二叉树中最大搜索二叉子数" class="headerlink" title="面试题7：找到二叉树中最大搜索二叉子数"></a>面试题7：找到二叉树中最大搜索二叉子数</h5><h5 id="面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构"><a href="#面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构" class="headerlink" title="面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构"></a>面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构</h5><h5 id="面试题9：二叉树的按层打印预-ZigZag-打印"><a href="#面试题9：二叉树的按层打印预-ZigZag-打印" class="headerlink" title="面试题9：二叉树的按层打印预 ZigZag 打印"></a>面试题9：二叉树的按层打印预 ZigZag 打印</h5><h5 id="面试题10：调整搜索二叉树中两个错误的节点"><a href="#面试题10：调整搜索二叉树中两个错误的节点" class="headerlink" title="面试题10：调整搜索二叉树中两个错误的节点"></a>面试题10：调整搜索二叉树中两个错误的节点</h5><h5 id="面试题11：判断-t1-树是否包含-t2-树全部的拓扑结构"><a href="#面试题11：判断-t1-树是否包含-t2-树全部的拓扑结构" class="headerlink" title="面试题11：判断 t1 树是否包含 t2 树全部的拓扑结构"></a>面试题11：判断 t1 树是否包含 t2 树全部的拓扑结构</h5><h5 id="面试题12：判断-t1-树中是否有与-t2-树拓扑结构完全相同的子数"><a href="#面试题12：判断-t1-树中是否有与-t2-树拓扑结构完全相同的子数" class="headerlink" title="面试题12：判断 t1 树中是否有与 t2 树拓扑结构完全相同的子数"></a>面试题12：判断 t1 树中是否有与 t2 树拓扑结构完全相同的子数</h5><h5 id="面试题13：判断二叉树是否为平衡二叉树"><a href="#面试题13：判断二叉树是否为平衡二叉树" class="headerlink" title="面试题13：判断二叉树是否为平衡二叉树"></a>面试题13：判断二叉树是否为平衡二叉树</h5><h5 id="面试题14：根据后序数组重建搜索二叉树"><a href="#面试题14：根据后序数组重建搜索二叉树" class="headerlink" title="面试题14：根据后序数组重建搜索二叉树"></a>面试题14：根据后序数组重建搜索二叉树</h5><h5 id="面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树"><a href="#面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树" class="headerlink" title="面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树"></a>面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树</h5><h5 id="面试题16：通过有序数组生成平衡搜索二叉树"><a href="#面试题16：通过有序数组生成平衡搜索二叉树" class="headerlink" title="面试题16：通过有序数组生成平衡搜索二叉树"></a>面试题16：通过有序数组生成平衡搜索二叉树</h5><h5 id="面试题17：在二叉树中找到一个节点的后继节点"><a href="#面试题17：在二叉树中找到一个节点的后继节点" class="headerlink" title="面试题17：在二叉树中找到一个节点的后继节点"></a>面试题17：在二叉树中找到一个节点的后继节点</h5><h5 id="面试题18：在二叉树中找到两个节点的最低公共祖先"><a href="#面试题18：在二叉树中找到两个节点的最低公共祖先" class="headerlink" title="面试题18：在二叉树中找到两个节点的最低公共祖先"></a>面试题18：在二叉树中找到两个节点的最低公共祖先</h5><h5 id="面试题19：Tarjan-算法与并查集解决二叉树节点间最低公共祖先的批量查询问题"><a href="#面试题19：Tarjan-算法与并查集解决二叉树节点间最低公共祖先的批量查询问题" class="headerlink" title="面试题19：Tarjan 算法与并查集解决二叉树节点间最低公共祖先的批量查询问题"></a>面试题19：Tarjan 算法与并查集解决二叉树节点间最低公共祖先的批量查询问题</h5><h5 id="面试题20：二叉树节点间的最大距离问题"><a href="#面试题20：二叉树节点间的最大距离问题" class="headerlink" title="面试题20：二叉树节点间的最大距离问题"></a>面试题20：二叉树节点间的最大距离问题</h5><h5 id="面试题21：派对的最大快乐值"><a href="#面试题21：派对的最大快乐值" class="headerlink" title="面试题21：派对的最大快乐值"></a>面试题21：派对的最大快乐值</h5><h5 id="面试题22：通过先序和中序数组生成后序数组"><a href="#面试题22：通过先序和中序数组生成后序数组" class="headerlink" title="面试题22：通过先序和中序数组生成后序数组"></a>面试题22：通过先序和中序数组生成后序数组</h5><h5 id="面试题23：统计和生成所有不同的二叉树"><a href="#面试题23：统计和生成所有不同的二叉树" class="headerlink" title="面试题23：统计和生成所有不同的二叉树"></a>面试题23：统计和生成所有不同的二叉树</h5><h5 id="面试题24：统计完全二叉树的节点树"><a href="#面试题24：统计完全二叉树的节点树" class="headerlink" title="面试题24：统计完全二叉树的节点树"></a>面试题24：统计完全二叉树的节点树</h5><h4 id="递归和动态规划"><a href="#递归和动态规划" class="headerlink" title="递归和动态规划"></a>递归和动态规划</h4><h5 id="面试题1：斐波那契数列问题的递归和动态规划"><a href="#面试题1：斐波那契数列问题的递归和动态规划" class="headerlink" title="面试题1：斐波那契数列问题的递归和动态规划"></a>面试题1：斐波那契数列问题的递归和动态规划</h5><h5 id="面试题2：矩阵的最小路径和"><a href="#面试题2：矩阵的最小路径和" class="headerlink" title="面试题2：矩阵的最小路径和"></a>面试题2：矩阵的最小路径和</h5><h5 id="面试题3：换钱的最少货币数"><a href="#面试题3：换钱的最少货币数" class="headerlink" title="面试题3：换钱的最少货币数"></a>面试题3：换钱的最少货币数</h5><h5 id="面试题4：机器人达到指定位置方法数"><a href="#面试题4：机器人达到指定位置方法数" class="headerlink" title="面试题4：机器人达到指定位置方法数"></a>面试题4：机器人达到指定位置方法数</h5><h5 id="面试题5：换钱的方法数"><a href="#面试题5：换钱的方法数" class="headerlink" title="面试题5：换钱的方法数"></a>面试题5：换钱的方法数</h5><h5 id="面试题6：打气球的最大分数"><a href="#面试题6：打气球的最大分数" class="headerlink" title="面试题6：打气球的最大分数"></a>面试题6：打气球的最大分数</h5><h5 id="面试题7：最长递增子序列"><a href="#面试题7：最长递增子序列" class="headerlink" title="面试题7：最长递增子序列"></a>面试题7：最长递增子序列</h5><h5 id="面试题8：信封嵌套问题"><a href="#面试题8：信封嵌套问题" class="headerlink" title="面试题8：信封嵌套问题"></a>面试题8：信封嵌套问题</h5><h5 id="面试题9：汉诺塔问题"><a href="#面试题9：汉诺塔问题" class="headerlink" title="面试题9：汉诺塔问题"></a>面试题9：汉诺塔问题</h5><h5 id="面试题10：最长公共子序列问题"><a href="#面试题10：最长公共子序列问题" class="headerlink" title="面试题10：最长公共子序列问题"></a>面试题10：最长公共子序列问题</h5><h5 id="面试题11：最长公共子串问题"><a href="#面试题11：最长公共子串问题" class="headerlink" title="面试题11：最长公共子串问题"></a>面试题11：最长公共子串问题</h5><h5 id="面试题12：子数组异或和为0的最多划分"><a href="#面试题12：子数组异或和为0的最多划分" class="headerlink" title="面试题12：子数组异或和为0的最多划分"></a>面试题12：子数组异或和为0的最多划分</h5><h5 id="面试题13：最小编辑代价"><a href="#面试题13：最小编辑代价" class="headerlink" title="面试题13：最小编辑代价"></a>面试题13：最小编辑代价</h5><h5 id="面试题14：字符串的交错组成"><a href="#面试题14：字符串的交错组成" class="headerlink" title="面试题14：字符串的交错组成"></a>面试题14：字符串的交错组成</h5><h5 id="面试题15：龙与地下城游戏问题"><a href="#面试题15：龙与地下城游戏问题" class="headerlink" title="面试题15：龙与地下城游戏问题"></a>面试题15：龙与地下城游戏问题</h5><h5 id="面试题16：数字字符串转换为字符组合的种数"><a href="#面试题16：数字字符串转换为字符组合的种数" class="headerlink" title="面试题16：数字字符串转换为字符组合的种数"></a>面试题16：数字字符串转换为字符组合的种数</h5><h5 id="面试题17：表达式得到期望结果的组成种树"><a href="#面试题17：表达式得到期望结果的组成种树" class="headerlink" title="面试题17：表达式得到期望结果的组成种树"></a>面试题17：表达式得到期望结果的组成种树</h5><h5 id="面试题18：排成一条线的纸牌博弈问题"><a href="#面试题18：排成一条线的纸牌博弈问题" class="headerlink" title="面试题18：排成一条线的纸牌博弈问题"></a>面试题18：排成一条线的纸牌博弈问题</h5><h5 id="面试题19：跳跃游戏"><a href="#面试题19：跳跃游戏" class="headerlink" title="面试题19：跳跃游戏"></a>面试题19：跳跃游戏</h5><h5 id="面试题20：数组中的最长连续序列"><a href="#面试题20：数组中的最长连续序列" class="headerlink" title="面试题20：数组中的最长连续序列"></a>面试题20：数组中的最长连续序列</h5><h5 id="面试题21：N-皇后问题"><a href="#面试题21：N-皇后问题" class="headerlink" title="面试题21：N 皇后问题"></a>面试题21：N 皇后问题</h5><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="面试题1：判断两个字符串是否互为变形词"><a href="#面试题1：判断两个字符串是否互为变形词" class="headerlink" title="面试题1：判断两个字符串是否互为变形词"></a>面试题1：判断两个字符串是否互为变形词</h5><h5 id="面试题2：判断两个字符串是否互为旋转词"><a href="#面试题2：判断两个字符串是否互为旋转词" class="headerlink" title="面试题2：判断两个字符串是否互为旋转词"></a>面试题2：判断两个字符串是否互为旋转词</h5><h5 id="面试题3：字符串中统计字符串"><a href="#面试题3：字符串中统计字符串" class="headerlink" title="面试题3：字符串中统计字符串"></a>面试题3：字符串中统计字符串</h5><h5 id="面试题4：判断字符数组中是否所有的字符都只出现过一次"><a href="#面试题4：判断字符数组中是否所有的字符都只出现过一次" class="headerlink" title="面试题4：判断字符数组中是否所有的字符都只出现过一次"></a>面试题4：判断字符数组中是否所有的字符都只出现过一次</h5><h5 id="面试题5：在有序但包含空数组中查找字符串"><a href="#面试题5：在有序但包含空数组中查找字符串" class="headerlink" title="面试题5：在有序但包含空数组中查找字符串"></a>面试题5：在有序但包含空数组中查找字符串</h5><h5 id="面试题6：字符串的调整与替换"><a href="#面试题6：字符串的调整与替换" class="headerlink" title="面试题6：字符串的调整与替换"></a>面试题6：字符串的调整与替换</h5><h5 id="面试题7：翻转字符串"><a href="#面试题7：翻转字符串" class="headerlink" title="面试题7：翻转字符串"></a>面试题7：翻转字符串</h5><h5 id="面试题8：完美洗牌问题"><a href="#面试题8：完美洗牌问题" class="headerlink" title="面试题8：完美洗牌问题"></a>面试题8：完美洗牌问题</h5><h5 id="面试题9：删除多余字符得到字典序最小的字符串"><a href="#面试题9：删除多余字符得到字典序最小的字符串" class="headerlink" title="面试题9：删除多余字符得到字典序最小的字符串"></a>面试题9：删除多余字符得到字典序最小的字符串</h5><h5 id="面试题10：数组中两个字符串的最小距离"><a href="#面试题10：数组中两个字符串的最小距离" class="headerlink" title="面试题10：数组中两个字符串的最小距离"></a>面试题10：数组中两个字符串的最小距离</h5><h5 id="面试题11：字符串的转换路径问题"><a href="#面试题11：字符串的转换路径问题" class="headerlink" title="面试题11：字符串的转换路径问题"></a>面试题11：字符串的转换路径问题</h5><h5 id="面试题12：添加最少字符使字符串整体都是回文字符串"><a href="#面试题12：添加最少字符使字符串整体都是回文字符串" class="headerlink" title="面试题12：添加最少字符使字符串整体都是回文字符串"></a>面试题12：添加最少字符使字符串整体都是回文字符串</h5><h5 id="面试题13：括号字符串的有效性和最长有效长度"><a href="#面试题13：括号字符串的有效性和最长有效长度" class="headerlink" title="面试题13：括号字符串的有效性和最长有效长度"></a>面试题13：括号字符串的有效性和最长有效长度</h5><h5 id="面试题14：公司字符串求值"><a href="#面试题14：公司字符串求值" class="headerlink" title="面试题14：公司字符串求值"></a>面试题14：公司字符串求值</h5><h5 id="面试题15：0-左边必有-1-的二进制字符串数量"><a href="#面试题15：0-左边必有-1-的二进制字符串数量" class="headerlink" title="面试题15：0 左边必有 1 的二进制字符串数量"></a>面试题15：0 左边必有 1 的二进制字符串数量</h5><h5 id="面试题16：拼接所有字符串产生字典顺序最小的大写字符串"><a href="#面试题16：拼接所有字符串产生字典顺序最小的大写字符串" class="headerlink" title="面试题16：拼接所有字符串产生字典顺序最小的大写字符串"></a>面试题16：拼接所有字符串产生字典顺序最小的大写字符串</h5><h5 id="面试题17：找到字符串的最长无重复字符子串"><a href="#面试题17：找到字符串的最长无重复字符子串" class="headerlink" title="面试题17：找到字符串的最长无重复字符子串"></a>面试题17：找到字符串的最长无重复字符子串</h5><h5 id="面试题18：找到指定的新类型字符"><a href="#面试题18：找到指定的新类型字符" class="headerlink" title="面试题18：找到指定的新类型字符"></a>面试题18：找到指定的新类型字符</h5><h5 id="面试题19：旋变字符串问题"><a href="#面试题19：旋变字符串问题" class="headerlink" title="面试题19：旋变字符串问题"></a>面试题19：旋变字符串问题</h5><h5 id="面试题20：最小包含子串的长度"><a href="#面试题20：最小包含子串的长度" class="headerlink" title="面试题20：最小包含子串的长度"></a>面试题20：最小包含子串的长度</h5><h5 id="面试题21：回文最少分割数"><a href="#面试题21：回文最少分割数" class="headerlink" title="面试题21：回文最少分割数"></a>面试题21：回文最少分割数</h5><h5 id="面试题22：字符串匹配问题"><a href="#面试题22：字符串匹配问题" class="headerlink" title="面试题22：字符串匹配问题"></a>面试题22：字符串匹配问题</h5><h5 id="面试题23：字典树（前缀树）的实现"><a href="#面试题23：字典树（前缀树）的实现" class="headerlink" title="面试题23：字典树（前缀树）的实现"></a>面试题23：字典树（前缀树）的实现</h5><h5 id="面试题24：子数组的最大异或和"><a href="#面试题24：子数组的最大异或和" class="headerlink" title="面试题24：子数组的最大异或和"></a>面试题24：子数组的最大异或和</h5><h4 id="大数据和空间限制"><a href="#大数据和空间限制" class="headerlink" title="大数据和空间限制"></a>大数据和空间限制</h4><h5 id="面试题1-认识布隆过滤器"><a href="#面试题1-认识布隆过滤器" class="headerlink" title="面试题1.  认识布隆过滤器"></a>面试题1.  认识布隆过滤器</h5><h5 id="面试题2-只用2GB内存在20亿个整数中找到出现次数最多的数"><a href="#面试题2-只用2GB内存在20亿个整数中找到出现次数最多的数" class="headerlink" title="面试题2.  只用2GB内存在20亿个整数中找到出现次数最多的数"></a>面试题2.  只用2GB内存在20亿个整数中找到出现次数最多的数</h5><h5 id="面试题3-40亿个非负整数中找到未出现的数"><a href="#面试题3-40亿个非负整数中找到未出现的数" class="headerlink" title="面试题3.  40亿个非负整数中找到未出现的数"></a>面试题3.  40亿个非负整数中找到未出现的数</h5><h5 id="面试题4-找到100亿个URL中重复的URL及搜索词汇的Top-K问题"><a href="#面试题4-找到100亿个URL中重复的URL及搜索词汇的Top-K问题" class="headerlink" title="面试题4.  找到100亿个URL中重复的URL及搜索词汇的Top  K问题"></a>面试题4.  找到100亿个URL中重复的URL及搜索词汇的Top  K问题</h5><h5 id="面试题5-40亿个非负整数中找到出现两次的数和所有数的中位数（"><a href="#面试题5-40亿个非负整数中找到出现两次的数和所有数的中位数（" class="headerlink" title="面试题5.  40亿个非负整数中找到出现两次的数和所有数的中位数（"></a>面试题5.  40亿个非负整数中找到出现两次的数和所有数的中位数（</h5><h5 id="面试题6-一致性哈希算法的基本原理"><a href="#面试题6-一致性哈希算法的基本原理" class="headerlink" title="面试题6.  一致性哈希算法的基本原理"></a>面试题6.  一致性哈希算法的基本原理</h5><h5 id="面试题7-岛问题"><a href="#面试题7-岛问题" class="headerlink" title="面试题7.  岛问题"></a>面试题7.  岛问题</h5><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><h5 id="面试题1-不用额外变量交换两个整数的值"><a href="#面试题1-不用额外变量交换两个整数的值" class="headerlink" title="面试题1.  不用额外变量交换两个整数的值"></a>面试题1.  不用额外变量交换两个整数的值</h5><h5 id="面试题2-不用做任何比较判断找出两个数中较大的数"><a href="#面试题2-不用做任何比较判断找出两个数中较大的数" class="headerlink" title="面试题2.  不用做任何比较判断找出两个数中较大的数"></a>面试题2.  不用做任何比较判断找出两个数中较大的数</h5><h5 id="面试题3-只用位运算不用算术运算实现整数的加减乘除运算（"><a href="#面试题3-只用位运算不用算术运算实现整数的加减乘除运算（" class="headerlink" title="面试题3.  只用位运算不用算术运算实现整数的加减乘除运算（"></a>面试题3.  只用位运算不用算术运算实现整数的加减乘除运算（</h5><h5 id="面试题4-整数的二进制数表达中有多少个1"><a href="#面试题4-整数的二进制数表达中有多少个1" class="headerlink" title="面试题4. 整数的二进制数表达中有多少个1"></a>面试题4. 整数的二进制数表达中有多少个1</h5><h5 id="面试题5-在其他数都出现偶数次的数组中找到出现奇数次的数（"><a href="#面试题5-在其他数都出现偶数次的数组中找到出现奇数次的数（" class="headerlink" title="面试题5.  在其他数都出现偶数次的数组中找到出现奇数次的数（"></a>面试题5.  在其他数都出现偶数次的数组中找到出现奇数次的数（</h5><h5 id="面试题6-在其他数都出现k次的数组中找到只出现一次的数"><a href="#面试题6-在其他数都出现k次的数组中找到只出现一次的数" class="headerlink" title="面试题6.  在其他数都出现k次的数组中找到只出现一次的数"></a>面试题6.  在其他数都出现k次的数组中找到只出现一次的数</h5><h4 id="数组和矩阵"><a href="#数组和矩阵" class="headerlink" title="数组和矩阵"></a>数组和矩阵</h4><h5 id="面试题1-转圈打印矩阵"><a href="#面试题1-转圈打印矩阵" class="headerlink" title="面试题1.  转圈打印矩阵"></a>面试题1.  转圈打印矩阵</h5><h5 id="面试题2-将正方形矩阵顺时针转动90°"><a href="#面试题2-将正方形矩阵顺时针转动90°" class="headerlink" title="面试题2.  将正方形矩阵顺时针转动90°"></a>面试题2.  将正方形矩阵顺时针转动90°</h5><h5 id="面试题3-“之”字形打印矩阵"><a href="#面试题3-“之”字形打印矩阵" class="headerlink" title="面试题3.  “之”字形打印矩阵"></a>面试题3.  “之”字形打印矩阵</h5><h5 id="面试题4-找到无序数组中最小的k个数（O-Nlogk-的方法"><a href="#面试题4-找到无序数组中最小的k个数（O-Nlogk-的方法" class="headerlink" title="面试题4.   找到无序数组中最小的k个数（O(Nlogk)的方法"></a>面试题4.   找到无序数组中最小的k个数（O(Nlogk)的方法</h5><h5 id="面试题5-需要排序的最短子数组长度"><a href="#面试题5-需要排序的最短子数组长度" class="headerlink" title="面试题5.  需要排序的最短子数组长度"></a>面试题5.  需要排序的最短子数组长度</h5><h5 id="面试题6-在数组中找到出现次数大于N-K的数"><a href="#面试题6-在数组中找到出现次数大于N-K的数" class="headerlink" title="面试题6.  在数组中找到出现次数大于N/K的数"></a>面试题6.  在数组中找到出现次数大于N/K的数</h5><h5 id="面试题7-在行列都排好序的矩阵中找指定数"><a href="#面试题7-在行列都排好序的矩阵中找指定数" class="headerlink" title="面试题7.  在行列都排好序的矩阵中找指定数"></a>面试题7.  在行列都排好序的矩阵中找指定数</h5><h5 id="面试题8-最长的可整合子数组的长度"><a href="#面试题8-最长的可整合子数组的长度" class="headerlink" title="面试题8.  最长的可整合子数组的长度"></a>面试题8.  最长的可整合子数组的长度</h5><h5 id="面试题9-不重复打印排序数组中相加和为给定值的所有二元组和三元组"><a href="#面试题9-不重复打印排序数组中相加和为给定值的所有二元组和三元组" class="headerlink" title="面试题9.  不重复打印排序数组中相加和为给定值的所有二元组和三元组"></a>面试题9.  不重复打印排序数组中相加和为给定值的所有二元组和三元组</h5><h5 id="面试题10-未排序正数数组中累加和为给定值的最长子数组长度"><a href="#面试题10-未排序正数数组中累加和为给定值的最长子数组长度" class="headerlink" title="面试题10. 未排序正数数组中累加和为给定值的最长子数组长度"></a>面试题10. 未排序正数数组中累加和为给定值的最长子数组长度</h5><h5 id="面试题11-未排序数组中累加和为给定值的最长子数组系列问题"><a href="#面试题11-未排序数组中累加和为给定值的最长子数组系列问题" class="headerlink" title="面试题11.  未排序数组中累加和为给定值的最长子数组系列问题"></a>面试题11.  未排序数组中累加和为给定值的最长子数组系列问题</h5><h5 id="面试题12-未排序数组中累加和小于或等于给定值的最长子数组长度"><a href="#面试题12-未排序数组中累加和小于或等于给定值的最长子数组长度" class="headerlink" title="面试题12.  未排序数组中累加和小于或等于给定值的最长子数组长度"></a>面试题12.  未排序数组中累加和小于或等于给定值的最长子数组长度</h5><h5 id="面试题13-计算数组的小和"><a href="#面试题13-计算数组的小和" class="headerlink" title="面试题13.  计算数组的小和"></a>面试题13.  计算数组的小和</h5><h5 id="面试题14-自然数数组的排序"><a href="#面试题14-自然数数组的排序" class="headerlink" title="面试题14.  自然数数组的排序"></a>面试题14.  自然数数组的排序</h5><h5 id="面试题15-奇数下标都是奇数或者偶数下标都是偶数"><a href="#面试题15-奇数下标都是奇数或者偶数下标都是偶数" class="headerlink" title="面试题15.  奇数下标都是奇数或者偶数下标都是偶数"></a>面试题15.  奇数下标都是奇数或者偶数下标都是偶数</h5><h5 id="面试题16-子数组的最大累加和问题"><a href="#面试题16-子数组的最大累加和问题" class="headerlink" title="面试题16.  子数组的最大累加和问题"></a>面试题16.  子数组的最大累加和问题</h5><h5 id="面试题17-子矩阵的最大累加和问题"><a href="#面试题17-子矩阵的最大累加和问题" class="headerlink" title="面试题17.  子矩阵的最大累加和问题"></a>面试题17.  子矩阵的最大累加和问题</h5><h5 id="面试题18-在数组中找到一个局部最小的位置"><a href="#面试题18-在数组中找到一个局部最小的位置" class="headerlink" title="面试题18.  在数组中找到一个局部最小的位置"></a>面试题18.  在数组中找到一个局部最小的位置</h5><h5 id="面试题19-数组中子数组的最大累乘积"><a href="#面试题19-数组中子数组的最大累乘积" class="headerlink" title="面试题19.  数组中子数组的最大累乘积"></a>面试题19.  数组中子数组的最大累乘积</h5><h5 id="面试题20-打印N个数组整体最大的Top-K"><a href="#面试题20-打印N个数组整体最大的Top-K" class="headerlink" title="面试题20.  打印N个数组整体最大的Top  K"></a>面试题20.  打印N个数组整体最大的Top  K</h5><h5 id="面试题21-边界都是1的最大正方形大小"><a href="#面试题21-边界都是1的最大正方形大小" class="headerlink" title="面试题21.  边界都是1的最大正方形大小"></a>面试题21.  边界都是1的最大正方形大小</h5><h5 id="面试题22-不包含本位置值的累乘数组"><a href="#面试题22-不包含本位置值的累乘数组" class="headerlink" title="面试题22.  不包含本位置值的累乘数组"></a>面试题22.  不包含本位置值的累乘数组</h5><h5 id="面试题23-数组的partition调整"><a href="#面试题23-数组的partition调整" class="headerlink" title="面试题23.  数组的partition调整"></a>面试题23.  数组的partition调整</h5><h5 id="面试题24-求最短通路值"><a href="#面试题24-求最短通路值" class="headerlink" title="面试题24.  求最短通路值"></a>面试题24.  求最短通路值</h5><h5 id="面试题25-数组中未出现的最小正整数"><a href="#面试题25-数组中未出现的最小正整数" class="headerlink" title="面试题25. 数组中未出现的最小正整数"></a>面试题25. 数组中未出现的最小正整数</h5><h5 id="面试题26-数组排序之后相邻数的最大差值"><a href="#面试题26-数组排序之后相邻数的最大差值" class="headerlink" title="面试题26.  数组排序之后相邻数的最大差值"></a>面试题26.  数组排序之后相邻数的最大差值</h5><h5 id="面试题27-做项目的最大收益问题"><a href="#面试题27-做项目的最大收益问题" class="headerlink" title="面试题27.  做项目的最大收益问题"></a>面试题27.  做项目的最大收益问题</h5><h5 id="面试题28-分金条的最小花费"><a href="#面试题28-分金条的最小花费" class="headerlink" title="面试题28.  分金条的最小花费"></a>面试题28.  分金条的最小花费</h5><h5 id="面试题29-大楼轮廓问题"><a href="#面试题29-大楼轮廓问题" class="headerlink" title="面试题29.  大楼轮廓问题"></a>面试题29.  大楼轮廓问题</h5><h5 id="面试题30-加油站良好出发点问题"><a href="#面试题30-加油站良好出发点问题" class="headerlink" title="面试题30.  加油站良好出发点问题"></a>面试题30.  加油站良好出发点问题</h5><h5 id="面试题31-容器盛水问题"><a href="#面试题31-容器盛水问题" class="headerlink" title="面试题31.  容器盛水问题"></a>面试题31.  容器盛水问题</h5><h5 id="绳子最多能覆盖的点个数"><a href="#绳子最多能覆盖的点个数" class="headerlink" title="绳子最多能覆盖的点个数"></a>绳子最多能覆盖的点个数</h5><p>题目：给定一个有序数组arr，代表数轴上从左到右有n个点a[0],a[1]…,a[n-1]，给定一根长度为L的绳子，求绳子最多能覆盖其中的几个点。</p><p>解法：试每一个点都作为绳子的末尾或开头。再利用有序二分法，时间时间复杂度O(NlogN)；滑动窗口双指针法，时间复杂度O(N)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CoverMaxPoint</span><span class="params">(self, nums, long)</span>:</span></span><br><span class="line">res = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">nearest = self.nearestIndex(nums, i, nums[i]-long)</span><br><span class="line">res = max(res, i-nearest+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nearestIndex</span><span class="params">(self, nums, R, value)</span>:</span></span><br><span class="line">L = <span class="number">0</span></span><br><span class="line">index = R </span><br><span class="line"><span class="keyword">while</span> L &lt; index:</span><br><span class="line">mid = (L+index)//<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> nums[mid] &gt;= value:</span><br><span class="line">index = mid</span><br><span class="line">R = mid - <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">L = mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CoverMaxPoint2</span><span class="params">(self, nums, long)</span>:</span></span><br><span class="line">L = <span class="number">0</span></span><br><span class="line">R = <span class="number">0</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> R &lt; len(nums):</span><br><span class="line"><span class="keyword">if</span> nums[R] - nums[L] &lt;= long:</span><br><span class="line">R += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">L += <span class="number">1</span></span><br><span class="line">res = max(res, R-L)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="面试题1-从5随机到7随机及其扩展"><a href="#面试题1-从5随机到7随机及其扩展" class="headerlink" title="面试题1.  从5随机到7随机及其扩展"></a>面试题1.  从5随机到7随机及其扩展</h5><h5 id="面试题2-一行代码求两个数的最大公约数"><a href="#面试题2-一行代码求两个数的最大公约数" class="headerlink" title="面试题2.  一行代码求两个数的最大公约数"></a>面试题2.  一行代码求两个数的最大公约数</h5><h5 id="面试题3-有关阶乘的两个问题"><a href="#面试题3-有关阶乘的两个问题" class="headerlink" title="面试题3.  有关阶乘的两个问题"></a>面试题3.  有关阶乘的两个问题</h5><h5 id="面试题4-判断一个点是否在矩形内部"><a href="#面试题4-判断一个点是否在矩形内部" class="headerlink" title="面试题4.  判断一个点是否在矩形内部"></a>面试题4.  判断一个点是否在矩形内部</h5><h5 id="面试题5-判断一个点是否在三角形内部"><a href="#面试题5-判断一个点是否在三角形内部" class="headerlink" title="面试题5.  判断一个点是否在三角形内部"></a>面试题5.  判断一个点是否在三角形内部</h5><h5 id="面试题6-折纸问题"><a href="#面试题6-折纸问题" class="headerlink" title="面试题6.  折纸问题"></a>面试题6.  折纸问题</h5><h5 id="面试题7-能否完美地拼成矩形"><a href="#面试题7-能否完美地拼成矩形" class="headerlink" title="面试题7.  能否完美地拼成矩形"></a>面试题7.  能否完美地拼成矩形</h5><h5 id="面试题8-蓄水池算法"><a href="#面试题8-蓄水池算法" class="headerlink" title="面试题8.  蓄水池算法"></a>面试题8.  蓄水池算法</h5><h5 id="面试题9-设计有-setAll-功能的哈希表"><a href="#面试题9-设计有-setAll-功能的哈希表" class="headerlink" title="面试题9.  设计有 setAll 功能的哈希表"></a>面试题9.  设计有 setAll 功能的哈希表</h5><h5 id="面试题10-最大的-leftMax-与-rightMax-之差的绝对值"><a href="#面试题10-最大的-leftMax-与-rightMax-之差的绝对值" class="headerlink" title="面试题10.  最大的 leftMax 与 rightMax 之差的绝对值"></a>面试题10.  最大的 leftMax 与 rightMax 之差的绝对值</h5><h5 id="面试题11-设计LRU缓存结构"><a href="#面试题11-设计LRU缓存结构" class="headerlink" title="面试题11.  设计LRU缓存结构"></a>面试题11.  设计LRU缓存结构</h5><h5 id="面试题12-LFU缓存结构设计"><a href="#面试题12-LFU缓存结构设计" class="headerlink" title="面试题12.  LFU缓存结构设计"></a>面试题12.  LFU缓存结构设计</h5><h5 id="面试题13-设计-RandomPool-结构"><a href="#面试题13-设计-RandomPool-结构" class="headerlink" title="面试题13.  设计 RandomPool 结构"></a>面试题13.  设计 RandomPool 结构</h5><h5 id="面试题14-并查集的实现"><a href="#面试题14-并查集的实现" class="headerlink" title="面试题14.  并查集的实现"></a>面试题14.  并查集的实现</h5><h5 id="面试题15-调整-0-x-区间上的数出现的概率"><a href="#面试题15-调整-0-x-区间上的数出现的概率" class="headerlink" title="面试题15.  调整[0,x)区间上的数出现的概率"></a>面试题15.  调整[0,x)区间上的数出现的概率</h5><h5 id="面试题16-路径数组变为统计数组"><a href="#面试题16-路径数组变为统计数组" class="headerlink" title="面试题16.  路径数组变为统计数组"></a>面试题16.  路径数组变为统计数组</h5><h5 id="面试题17-正数数组的最小不可组成和"><a href="#面试题17-正数数组的最小不可组成和" class="headerlink" title="面试题17.  正数数组的最小不可组成和"></a>面试题17.  正数数组的最小不可组成和</h5><h5 id="面试题18-累加出整个范围所有的数最少还需几个数"><a href="#面试题18-累加出整个范围所有的数最少还需几个数" class="headerlink" title="面试题18.  累加出整个范围所有的数最少还需几个数"></a>面试题18.  累加出整个范围所有的数最少还需几个数</h5><h5 id="面试题19-一种字符串和数字的对应关系"><a href="#面试题19-一种字符串和数字的对应关系" class="headerlink" title="面试题19.  一种字符串和数字的对应关系"></a>面试题19.  一种字符串和数字的对应关系</h5><h5 id="面试题20-1到n中1出现的次数"><a href="#面试题20-1到n中1出现的次数" class="headerlink" title="面试题20.  1到n中1出现的次数"></a>面试题20.  1到n中1出现的次数</h5><h5 id="面试题21-从N个数中等概率打印M个数"><a href="#面试题21-从N个数中等概率打印M个数" class="headerlink" title="面试题21.  从N个数中等概率打印M个数"></a>面试题21.  从N个数中等概率打印M个数</h5><h5 id="面试题22-判断一个数是否是回文数"><a href="#面试题22-判断一个数是否是回文数" class="headerlink" title="面试题22.  判断一个数是否是回文数"></a>面试题22.  判断一个数是否是回文数</h5><h5 id="面试题23-在有序旋转数组中找到最小值"><a href="#面试题23-在有序旋转数组中找到最小值" class="headerlink" title="面试题23.  在有序旋转数组中找到最小值"></a>面试题23.  在有序旋转数组中找到最小值</h5><h5 id="面试题24-在有序旋转数组中找到一个数"><a href="#面试题24-在有序旋转数组中找到一个数" class="headerlink" title="面试题24.  在有序旋转数组中找到一个数"></a>面试题24.  在有序旋转数组中找到一个数</h5><h5 id="面试题25-数字的英文表达和中文表达"><a href="#面试题25-数字的英文表达和中文表达" class="headerlink" title="面试题25.  数字的英文表达和中文表达"></a>面试题25.  数字的英文表达和中文表达</h5><h5 id="面试题26-分糖果问题"><a href="#面试题26-分糖果问题" class="headerlink" title="面试题26.  分糖果问题"></a>面试题26.  分糖果问题</h5><h5 id="面试题27-一种消息接收并打印的结构设计"><a href="#面试题27-一种消息接收并打印的结构设计" class="headerlink" title="面试题27.  一种消息接收并打印的结构设计"></a>面试题27.  一种消息接收并打印的结构设计</h5><h5 id="面试题28-随时找到数据流的中位数"><a href="#面试题28-随时找到数据流的中位数" class="headerlink" title="面试题28.  随时找到数据流的中位数"></a>面试题28.  随时找到数据流的中位数</h5><h5 id="面试题29-在两个长度相等的排序数组中找到上中位数"><a href="#面试题29-在两个长度相等的排序数组中找到上中位数" class="headerlink" title="面试题29.  在两个长度相等的排序数组中找到上中位数"></a>面试题29.  在两个长度相等的排序数组中找到上中位数</h5><h5 id="面试题30-在两个排序数组中找到第k小的数"><a href="#面试题30-在两个排序数组中找到第k小的数" class="headerlink" title="面试题30.  在两个排序数组中找到第k小的数"></a>面试题30.  在两个排序数组中找到第k小的数</h5><h5 id="面试题31-两个有序数组间相加和的Top-k问题"><a href="#面试题31-两个有序数组间相加和的Top-k问题" class="headerlink" title="面试题31.  两个有序数组间相加和的Top  k问题"></a>面试题31.  两个有序数组间相加和的Top  k问题</h5><h5 id="面试题32-出现次数的Top-k问题"><a href="#面试题32-出现次数的Top-k问题" class="headerlink" title="面试题32.  出现次数的Top  k问题"></a>面试题32.  出现次数的Top  k问题</h5><h5 id="面试题33-Manacher-算法"><a href="#面试题33-Manacher-算法" class="headerlink" title="面试题33.  Manacher 算法"></a>面试题33.  Manacher 算法</h5><h5 id="面试题34-KMP算法"><a href="#面试题34-KMP算法" class="headerlink" title="面试题34.  KMP算法"></a>面试题34.  KMP算法</h5><h5 id="面试题35-丢棋子问题"><a href="#面试题35-丢棋子问题" class="headerlink" title="面试题35.  丢棋子问题"></a>面试题35.  丢棋子问题</h5><h5 id="面试题36-画匠问题"><a href="#面试题36-画匠问题" class="headerlink" title="面试题36.  画匠问题"></a>面试题36.  画匠问题</h5><h5 id="面试题37-邮局选址问题"><a href="#面试题37-邮局选址问题" class="headerlink" title="面试题37. 邮局选址问题"></a>面试题37. 邮局选址问题</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;小知识点&quot;&gt;&lt;a href=&quot;#小知识点&quot; class=&quot;headerlink&quot; title=&quot;小知识点&quot;&gt;&lt;/a&gt;小知识点&lt;/h4&gt;&lt;h5 id=&quot;异或运算&quot;&gt;&lt;a href=&quot;#异或运算&quot; class=&quot;headerlink&quot; title=&quot;异或运算&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Python算法题" scheme="http://pl741.github.io/categories/Python%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="算法与数据结构——程序员代码面试指南" scheme="http://pl741.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>算法面试题</title>
    <link href="http://pl741.github.io/2019/11/29/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://pl741.github.io/2019/11/29/算法面试题/</id>
    <published>2019-11-29T02:17:00.000Z</published>
    <updated>2020-05-23T13:41:11.833Z</updated>
    
    <content type="html"><![CDATA[<h4 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h4><h5 id="4-22-剑指offer简单题："><a href="#4-22-剑指offer简单题：" class="headerlink" title="4/22 剑指offer简单题："></a>4/22 剑指offer简单题：</h5><ol><li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">面试题27. 二叉树的镜像</a></li><li><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题28. 对称的二叉树</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">面试题32 - II. 从上到下打印二叉树 II</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">面试题55 - I. 二叉树的深度</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">面试题54. 二叉搜索树的第k大节点</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题55 - II. 平衡二叉树</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - I. 二叉搜索树的最近公共祖先</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - II. 二叉树的最近公共祖先</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener">面试题58 - I. 翻转单词顺序</a></li><li><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">面试题11. 旋转数组的最小数字</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题53 - II. 0～n-1中缺失的数字</a> ⭐</li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题03. 数组中重复的数字</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">面试题04. 二维数组中的查找</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">面试题06. 从尾到头打印链表</a></li><li><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">面试题25. 合并两个排序的链表</a> ⭐</li><li><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">面试题22. 链表中倒数第k个节点</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">面试题24. 反转链表</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">面试题18. 删除链表的节点</a></li><li><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题58 - II. 左旋转字符串</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">面试题52. 两个链表的第一个公共节点</a>  ⭐⭐</li><li><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">面试题59 - I. 滑动窗口的最大值</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">面试题40. 最小的k个数</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">面试题53 - I. 在排序数组中查找数字 I</a></li></ol><h5 id="4-24"><a href="#4-24" class="headerlink" title="4/24"></a>4/24</h5><ol><li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8. 字符串转换整数 (atoi)</a>  /  <a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">面试题67. 把字符串转换成整数</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a>  ⭐（两种方法）</li><li><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/" target="_blank" rel="noopener">面试题 10.01. 合并排序的数组</a>  /  <a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a></li><li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></li><li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a>   ⭐</li></ol><h5 id="4-25"><a href="#4-25" class="headerlink" title="4/25"></a>4/25</h5><ol><li><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个有序数组的中位数</a>  ⭐⭐</li><li>两个有序数组找第k大  ⭐<br>a. O(m + n) 的解法比较直观，直接merge 两个数组，然后求第k 大的元素；<br>b. 可以用一个计数器，记录当前已经找到第m 大的元素了。同时使用两个指针pA 和pB，分别指向A 和B 数组的第一个元素，使用类似于merge sort 的原理，如果数组A 当前元素小，那么pA++，同时m++；如果数组B 当前元素小，那么pB++，同时m++。最终当m 等于k 的时候，就得到了我们的答案，O(k)时间，O(1) 空间。但是，当k 很接近m + n 的时候，这个方法还是O(m + n) 的。<br>c. 可以考虑从 k 入手。如果每次都能够删除一些一定在第k 大元素之前的元素，那么只需要进行k 次。 由于A 和B 都是有序的，类似于二分查找。假设 A 和 B 的元素个数都大于k/2，将A 的第 k/2 个元素（即A[k/2-1]）和 B 的第 k/2个元素（即B[k/2-1]）进行比较，有以下三种情况（为了简化这里先假设k 为偶数，所得到的结论对于k 是奇数也是成立的）：<br>A[k/2-1] &lt; B[k/2-1]，意味着A[0] 到A[k/2-1] 的肯定在的top k 元素的范围内，换句话说，A[k/2-1] 不可能大于第k 大元素。删除A 数组的这k/2 个元素。<br>A[k/2-1] &gt; B[k/2-1] 时，可以删除B 数组的k/2 个元素。<br>当A[k/2-1] == B[k/2-1] 时，说明找到了第k 大的元素，直接返回A[k/2-1] 或B[k/2-1]即可。<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Find_kth</span><span class="params">(self, nums1, nums2, k)</span>:</span></span><br><span class="line">m = len(nums1)</span><br><span class="line">n = len(nums2)</span><br><span class="line"><span class="keyword">if</span> m &gt; n:</span><br><span class="line">nums1, nums2, m, n = nums2, nums1, n, m</span><br><span class="line">imin = <span class="number">0</span></span><br><span class="line">imax = min(m, k)</span><br><span class="line"><span class="keyword">while</span> imin &lt;= imax:</span><br><span class="line">i = (imax + imin) // <span class="number">2</span></span><br><span class="line">j = k - i</span><br><span class="line"><span class="keyword">if</span> j &gt; n <span class="keyword">or</span> (i &lt; min(m, k) <span class="keyword">and</span> nums2[j<span class="number">-1</span>] &gt; nums1[i]):</span><br><span class="line">imin = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &lt; n <span class="keyword">and</span> nums1[i<span class="number">-1</span>] &gt; nums2[j]:</span><br><span class="line">imax = i - <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span>:<span class="keyword">return</span> nums2[j<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">elif</span> j == <span class="number">0</span>: <span class="keyword">return</span> nums1[i<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">else</span>:<span class="keyword">return</span> max(nums1[i<span class="number">-1</span>], nums2[j<span class="number">-1</span>])</span><br><span class="line">print(Solution().Find_kth([<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>], <span class="number">6</span>))</span><br></pre></td></tr></table></figure></div></div></li></ol><h5 id="4-28"><a href="#4-28" class="headerlink" title="4/28"></a>4/28</h5><ol><li><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></li><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a>  ⭐</li></ol><h5 id="4-29"><a href="#4-29" class="headerlink" title="4/29"></a>4/29</h5><ol><li><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">面试题09. 用两个栈实现队列</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137. 只出现一次的数字 II</a>   ⭐</li><li><a href="https://blog.csdn.net/hanyajun0123/article/details/84320469" target="_blank" rel="noopener">圆环回原点问题</a>  ⭐ <div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">GetSteps</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">   <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">   <span class="keyword">if</span> k % <span class="number">2</span> ==<span class="number">0</span>:</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(k+<span class="number">1</span>)]</span><br><span class="line">   dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">   dp[i][j] = dp[i<span class="number">-1</span>][(j<span class="number">-1</span>+n)%n] + dp[i<span class="number">-1</span>][(j+<span class="number">1</span>)%n]</span><br><span class="line">   <span class="keyword">return</span> dp[k][<span class="number">0</span>]</span><br><span class="line">   print(Solution().GetSteps(<span class="number">10</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure></div></div>   </li><li><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">543. 二叉树的直径</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/smallest-k-lcci/" target="_blank" rel="noopener">面试题 17.14. 最小K个数</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">面试题36. 二叉搜索树与双向链表</a>  ⭐</li></ol><h5 id="4-30"><a href="#4-30" class="headerlink" title="4/30"></a>4/30</h5><ol><li><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></li><li><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a>  ⭐ 完全二叉树最右的节点可复用以上思想</li><li><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">572. 另一个树的子树</a>  ⭐</li></ol><h5 id="5-1"><a href="#5-1" class="headerlink" title="5/1"></a>5/1</h5><ol><li><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">面试题10- I. 斐波那契数列</a></li><li><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">面试题10- II. 青蛙跳台阶问题</a></li><li><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">面试题21. 调整数组顺序使奇数位于偶数前面</a></li><li><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">面试题15. 二进制中1的个数</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener">面试题17. 打印从1到最大的n位数</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">面试题29. 顺时针打印矩阵</a> ⭐</li><li><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">面试题30. 包含min函数的栈</a></li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题39. 数组中出现次数超过一半的数字</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">面试题42. 连续子数组的最大和</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank" rel="noopener">面试题50. 第一个只出现一次的字符</a></li><li><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">面试题57. 和为s的两个数字</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">面试题57 - II. 和为s的连续正数序列</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">面试题60. n个骰子的点数</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">面试题61. 扑克牌中的顺子</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></li></ol><h5 id="5-2"><a href="#5-2" class="headerlink" title="5/2"></a>5/2</h5><ol><li><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a> </li><li><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></li><li><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></li><li><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></li><li><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a>  ⭐</li></ol><h5 id="5-3"><a href="#5-3" class="headerlink" title="5/3"></a>5/3</h5><ol><li><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></li><li><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">461. 汉明距离</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">581. 最短无序连续子数组</a>    ⭐</li><li><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">617. 合并二叉树</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">538. 把二叉搜索树转换为累加树</a>    ⭐</li><li><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">125. 验证回文串</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题07. 重建二叉树</a></li><li><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题32 - I. 从上到下打印二叉树</a></li></ol><h5 id="5-4"><a href="#5-4" class="headerlink" title="5/4"></a>5/4</h5><ol><li><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">面试题32 - III. 从上到下打印二叉树 III</a>    ⭐</li><li><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">面试题12. 矩阵中的路径</a></li><li><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">面试题13. 机器人的运动范围</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">面试题14- I. 剪绳子</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/" target="_blank" rel="noopener">面试题14- II. 剪绳子 II</a>   ⭐</li></ol><h5 id="5-6"><a href="#5-6" class="headerlink" title="5/6"></a>5/6</h5><ol><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a>    ⭐</li><li><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">面试题26. 树的子结构</a></li><li><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">面试题31. 栈的压入、弹出序列</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">面试题33. 二叉搜索树的后序遍历序列</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">73. 矩阵置零</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. 二叉树中的最大路径和</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" target="_blank" rel="noopener">面试题 01.07. 旋转矩阵</a>   ⭐</li></ol><h5 id="5-7"><a href="#5-7" class="headerlink" title="5/7"></a>5/7</h5><ol><li><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">面试题35. 复杂链表的复制</a></li><li><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题37. 序列化二叉树</a>    ⭐</li><li><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">面试题59 - II. 队列的最大值</a></li><li><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">面试题45. 把数组排成最小的数</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题56 - I. 数组中数字出现的次数</a></li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">面试题56 - II. 数组中数字出现的次数 II</a>   ⭐</li></ol><h5 id="5-8"><a href="#5-8" class="headerlink" title="5/8"></a>5/8</h5><ol><li><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">面试题38. 字符串的排列</a>     ⭐</li><li><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">面试题67. 把字符串转换成整数</a>    ⭐</li><li><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题46. 把数字翻译成字符串</a>    ⭐</li><li><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题48. 最长不含重复字符的子字符串</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题20. 表示数值的字符串</a>    ⭐</li></ol><h5 id="5-9"><a href="#5-9" class="headerlink" title="5/9"></a>5/9</h5><ol><li><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">面试题47. 礼物的最大价值</a></li><li><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">面试题63. 股票的最大利润</a></li><li><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">面试题16. 数值的整数次方</a>    ⭐</li><li><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">面试题19. 正则表达式匹配</a>    ⭐</li><li><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">面试题41. 数据流中的中位数</a>   ⭐ heappushpop(a,x)在弹出最小值之前将x推送到a上 </li></ol><h5 id="5-10"><a href="#5-10" class="headerlink" title="5/10"></a>5/10</h5><ol><li><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题43. 1～n整数中1出现的次数</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题44. 数字序列中某一位的数字</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">面试题49. 丑数</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">面试题64. 求1+2+…+n</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">面试题65. 不用加减乘除做加法</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener">面试题66. 构建乘积数组</a>   ⭐</li></ol><h5 id="5-15"><a href="#5-15" class="headerlink" title="5/15"></a>5/15</h5><ol><li><a href="https://leetcode-cn.com/problems/one-away-lcci/" target="_blank" rel="noopener">面试题 01.05. 一次编辑</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/" target="_blank" rel="noopener">面试题 01.07. 旋转矩阵</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/zero-matrix-lcci/" target="_blank" rel="noopener">面试题 01.08. 零矩阵</a></li><li><a href="https://leetcode-cn.com/problems/partition-list-lcci/" target="_blank" rel="noopener">面试题 02.04. 分割链表</a>    ⭐</li><li><a href="https://leetcode-cn.com/problems/sum-lists-lcci/" target="_blank" rel="noopener">面试题 02.05. 链表求和</a></li><li><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">445. 两数相加 II</a>  ⭐</li></ol><h5 id="5-16"><a href="#5-16" class="headerlink" title="5/16"></a>5/16</h5><ol><li><a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">844. 比较含退格的字符串</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></li><li><a href="https://leetcode-cn.com/problems/shuffle-an-array/" target="_blank" rel="noopener">384. 打乱数组</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-lcci/" target="_blank" rel="noopener">面试题 02.08. 环路检测</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/stack-of-plates-lcci/" target="_blank" rel="noopener">面试题 03.03. 堆盘子</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/sort-of-stacks-lcci/" target="_blank" rel="noopener">面试题 03.05. 栈排序</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/route-between-nodes-lcci/" target="_blank" rel="noopener">面试题 04.01. 节点间通路</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/list-of-depth-lcci/" target="_blank" rel="noopener">面试题 04.03. 特定深度节点链表</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">395. 至少有K个重复字符的最长子串</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 四数相加 II</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/" target="_blank" rel="noopener">面试题 04.05. 合法二叉搜索树</a></li><li><a href="https://leetcode-cn.com/problems/successor-lcci/" target="_blank" rel="noopener">面试题 04.06. 后继者</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/first-common-ancestor-lcci/" target="_blank" rel="noopener">面试题 04.08. 首个共同祖先</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/check-subtree-lcci/" target="_blank" rel="noopener">面试题 04.10. 检查子树</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/paths-with-sum-lcci/" target="_blank" rel="noopener">面试题 04.12. 求和路径</a>  ⭐  <a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. 路径总和 III</a></li><li><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II</a>  ⭐</li></ol><h5 id="5-17"><a href="#5-17" class="headerlink" title="5/17"></a>5/17</h5><ol><li><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">230. 二叉搜索树中第K小的元素</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">238. 除自身以外数组的乘积</a></li><li><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240. 搜索二维矩阵 II</a></li><li><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a> </li><li><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">328. 奇偶链表</a>  ⭐ </li><li><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/" target="_blank" rel="noopener">334. 递增的三元子序列</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a></li><li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a>  ⭐</li></ol><h5 id="5-18"><a href="#5-18" class="headerlink" title="5/18"></a>5/18</h5><ol><li><a href="https://leetcode-cn.com/problems/bianry-number-to-string-lcci/" target="_blank" rel="noopener">面试题 05.02. 二进制数转字符串</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/closed-number-lcci/" target="_blank" rel="noopener">面试题 05.04. 下一个数</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/robot-in-a-grid-lcci/" target="_blank" rel="noopener">面试题 08.02. 迷路的机器人</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/power-set-lcci/" target="_blank" rel="noopener">面试题 08.04. 幂集</a>   ⭐</li></ol><h5 id="5-19"><a href="#5-19" class="headerlink" title="5/19"></a>5/19</h5><ol><li><a href="https://leetcode-cn.com/problems/recursive-mulitply-lcci/" target="_blank" rel="noopener">面试题 08.05. 递归乘法</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/permutation-i-lcci/" target="_blank" rel="noopener">面试题 08.07. 无重复字符串的排列组合</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/permutation-ii-lcci/" target="_blank" rel="noopener">面试题 08.08. 有重复字符串的排列组合</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/bracket-lcci/" target="_blank" rel="noopener">面试题 08.09. 括号</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/brick-wall/" target="_blank" rel="noopener">554. 砖墙</a>   ⭐</li></ol><h5 id="5-20"><a href="#5-20" class="headerlink" title="5/20"></a>5/20</h5><ol><li><a href="https://leetcode-cn.com/problems/group-anagrams-lcci/" target="_blank" rel="noopener">面试题 10.02. 变位词组</a>  ⭐</li><li><a href="https://leetcode-cn.com/problems/search-rotate-array-lcci/" target="_blank" rel="noopener">面试题 10.03. 搜索旋转数组</a>  ⭐  <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></li><li><a href="https://leetcode-cn.com/problems/sorted-matrix-search-lcci/" target="_blank" rel="noopener">面试题 10.09. 排序矩阵查找</a></li></ol><h5 id="5-21"><a href="#5-21" class="headerlink" title="5/21"></a>5/21</h5><ol><li><a href="https://leetcode-cn.com/problems/peaks-and-valleys-lcci/" target="_blank" rel="noopener">面试题 10.11. 峰与谷</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/swap-numbers-lcci/" target="_blank" rel="noopener">面试题 16.01. 交换数字</a></li><li><a href="https://leetcode-cn.com/problems/words-frequency-lcci/" target="_blank" rel="noopener">面试题 16.02. 单词频率</a></li><li><a href="https://leetcode-cn.com/problems/tic-tac-toe-lcci/" target="_blank" rel="noopener">面试题 16.04. 井字游戏</a>   ⭐</li><li><a href="https://leetcode-cn.com/problems/smallest-difference-lcci/" target="_blank" rel="noopener">面试题 16.06. 最小差</a>   ⭐</li></ol><h5 id="5-22"><a href="#5-22" class="headerlink" title="5/22"></a>5/22</h5><ol><li><a href="https://leetcode-cn.com/problems/operations-lcci/" target="_blank" rel="noopener">面试题 16.09. 运算</a></li><li><a href="https://leetcode-cn.com/problems/living-people-lcci/" target="_blank" rel="noopener">面试题 16.10. 生存人数</a></li><li><a href="https://leetcode-cn.com/problems/bisect-squares-lcci/" target="_blank" rel="noopener">面试题 16.13. 平分正方形</a></li><li><a href="https://leetcode-cn.com/problems/best-line-lcci/" target="_blank" rel="noopener">面试题 16.14. 最佳直线</a></li><li><a href="https://leetcode-cn.com/problems/sub-sort-lcci/" target="_blank" rel="noopener">面试题 16.16. 部分排序</a></li></ol><h5 id="5-23"><a href="#5-23" class="headerlink" title="5/23"></a>5/23</h5><ol><li><a href="https://leetcode-cn.com/problems/pattern-matching-lcci/" target="_blank" rel="noopener">面试题 16.18. 模式匹配</a></li><li><a href="https://leetcode-cn.com/problems/pond-sizes-lcci/" target="_blank" rel="noopener">面试题 16.19. 水域大小</a></li><li><a href="https://leetcode-cn.com/problems/t9-lcci/" target="_blank" rel="noopener">面试题 16.20. T9键盘</a></li><li><a href="https://leetcode-cn.com/problems/sum-swap-lcci/" target="_blank" rel="noopener">面试题 16.21. 交换和</a></li><li><a href="https://leetcode-cn.com/problems/langtons-ant-lcci/" target="_blank" rel="noopener">面试题 16.22. 兰顿蚂蚁</a></li><li><a href="https://leetcode-cn.com/problems/pairs-with-sum-lcci/" target="_blank" rel="noopener">面试题 16.24. 数对和</a></li><li><a href="https://leetcode-cn.com/problems/lru-cache-lcci/" target="_blank" rel="noopener">面试题 16.25. LRU缓存</a></li><li><a href="https://leetcode-cn.com/problems/calculator-lcci/" target="_blank" rel="noopener">面试题 16.26. 计算器</a></li><li><a href="https://leetcode-cn.com/problems/find-longest-subarray-lcci/" target="_blank" rel="noopener">面试题 17.05.  字母与数字</a></li><li><a href="https://leetcode-cn.com/problems/number-of-2s-in-range-lcci/" target="_blank" rel="noopener">面试题 17.06. 2出现的次数</a></li><li><a href="https://leetcode-cn.com/problems/baby-names-lcci/" target="_blank" rel="noopener">面试题 17.07. 婴儿名字</a></li><li><a href="https://leetcode-cn.com/problems/circus-tower-lcci/" target="_blank" rel="noopener">面试题 17.08. 马戏团人塔</a></li><li><a href="https://leetcode-cn.com/problems/get-kth-magic-number-lcci/" target="_blank" rel="noopener">面试题 17.09. 第 k 个数</a></li><li><a href="https://leetcode-cn.com/problems/find-closest-lcci/" target="_blank" rel="noopener">面试题 17.11. 单词距离</a></li><li><a href="https://leetcode-cn.com/problems/re-space-lcci/" target="_blank" rel="noopener">面试题 17.13. 恢复空格</a></li></ol><h5 id="5-24"><a href="#5-24" class="headerlink" title="5/24"></a>5/24</h5><ol><li><a href="https://leetcode-cn.com/problems/longest-word-lcci/" target="_blank" rel="noopener">面试题 17.15. 最长单词</a></li><li><a href="https://leetcode-cn.com/problems/multi-search-lcci/" target="_blank" rel="noopener">面试题 17.17. 多次搜索</a></li><li><a href="https://leetcode-cn.com/problems/shortest-supersequence-lcci/" target="_blank" rel="noopener">面试题 17.18. 最短超串</a></li><li><a href="https://leetcode-cn.com/problems/word-transformer-lcci/" target="_blank" rel="noopener">面试题 17.22. 单词转换</a></li><li><a href="https://leetcode-cn.com/problems/max-black-square-lcci/" target="_blank" rel="noopener">面试题 17.23. 最大黑方阵</a></li><li><a href="https://leetcode-cn.com/problems/divide-two-integers/" target="_blank" rel="noopener">29. 两数相除</a></li><li><a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. 有效的数独</a></li><li><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/" target="_blank" rel="noopener">341. 扁平化嵌套列表迭代器</a></li><li><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. 前 K 个高频元素</a></li><li><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">378. 有序矩阵中第K小的元素</a></li><li><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/" target="_blank" rel="noopener">380. 常数时间插入、删除和获取随机元素</a></li><li><a href="https://leetcode-cn.com/problems/wiggle-sort-ii/" target="_blank" rel="noopener">324. 摆动排序 II</a>  ⭐  （未作）</li><li><a href="https://leetcode-cn.com/problems/game-of-life/" target="_blank" rel="noopener">289. 生命游戏</a>   ⭐  （未作）</li><li><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数</a>  ⭐（未作）</li><li><a href="https://leetcode-cn.com/problems/rank-from-stream-lcci/" target="_blank" rel="noopener">面试题 10.10. 数字流的秩</a>（未作）</li><li><a href="https://leetcode-cn.com/problems/boolean-evaluation-lcci/" target="_blank" rel="noopener">面试题 08.14. 布尔运算</a>  （未作）</li><li><a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">面试题 08.11. 硬币</a>  （未做）</li><li><a href="https://leetcode-cn.com/problems/draw-line-lcci/" target="_blank" rel="noopener">面试题 05.08. 绘制直线</a>  （未做）</li></ol><h5 id="5-25"><a href="#5-25" class="headerlink" title="5/25"></a>5/25</h5><ol><li><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></li><li><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">48. 旋转图像</a></li><li><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组</a></li><li><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></li><li><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a></li></ol><h5 id="5-26"><a href="#5-26" class="headerlink" title="5/26"></a>5/26</h5><ol><li><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></li><li><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></li><li><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></li><li><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a></li><li><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></li></ol><h5 id="5-27"><a href="#5-27" class="headerlink" title="5/27"></a>5/27</h5><ol><li><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. 二叉树的锯齿形层次遍历</a></li><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></li></ol><h5 id="5-28"><a href="#5-28" class="headerlink" title="5/28"></a>5/28</h5><ol><li><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a></li><li><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. 单词接龙</a></li><li><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. 被围绕的区域</a></li><li><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a></li><li><a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">134. 加油站</a></li></ol><h5 id="5-29"><a href="#5-29" class="headerlink" title="5/29"></a>5/29</h5><ol><li><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. 复制带随机指针的链表</a></li><li><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">139. 单词拆分</a></li><li><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></li><li><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a></li><li><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a></li></ol><h5 id="5-30"><a href="#5-30" class="headerlink" title="5/30"></a>5/30</h5><ol><li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子数组</a></li><li><a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="noopener">162. 寻找峰值</a></li><li><a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/" target="_blank" rel="noopener">166. 分数到小数</a></li><li><a href="https://leetcode-cn.com/problems/largest-number/" target="_blank" rel="noopener">179. 最大数</a></li><li><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></li><li><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></li><li><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. 实现 Trie (前缀树)</a></li><li><a href="https://leetcode-cn.com/problems/course-schedule-ii/" target="_blank" rel="noopener">210. 课程表 II</a></li><li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></li><li><a href="https://leetcode-cn.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">227. 基本计算器 II</a></li></ol><h4 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h4><ol><li><a href="https://leetcode-cn.com/problems/bst-sequences-lcci/" target="_blank" rel="noopener">面试题 04.09. 二叉搜索树序列</a></li><li><a href="https://leetcode-cn.com/problems/eight-queens-lcci/" target="_blank" rel="noopener">面试题 08.12. 八皇后</a></li><li><a href="https://leetcode-cn.com/problems/pile-box-lcci/" target="_blank" rel="noopener">面试题 08.13. 堆箱子</a></li><li><a href="https://leetcode-cn.com/problems/intersection-lcci/" target="_blank" rel="noopener">面试题 16.03. 交点</a></li><li><a href="https://leetcode-cn.com/problems/english-int-lcci/" target="_blank" rel="noopener">面试题 16.08. 整数的英语表示</a></li><li><a href="https://leetcode-cn.com/problems/missing-two-lcci/" target="_blank" rel="noopener">面试题 17.19. 消失的两个数字</a></li><li><a href="https://leetcode-cn.com/problems/continuous-median-lcci/" target="_blank" rel="noopener">面试题 17.20. 连续中值</a></li><li><a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/" target="_blank" rel="noopener">面试题 17.21. 直方图的水量</a></li><li><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/" target="_blank" rel="noopener">面试题 17.24. 最大子矩阵</a></li><li><a href="https://leetcode-cn.com/problems/word-rectangle-lcci/" target="_blank" rel="noopener">面试题 17.25. 单词矩阵</a></li><li><a href="https://leetcode-cn.com/problems/sparse-similarity-lcci/" target="_blank" rel="noopener">面试题 17.26. 稀疏相似度</a></li><li><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></li><li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></li><li><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. 缺失的第一个正数</a></li><li><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">44. 通配符匹配</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></li><li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></li><li><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85. 最大矩形</a></li><li><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. 最长连续序列</a></li><li><a href="https://leetcode-cn.com/problems/word-break-ii/" target="_blank" rel="noopener">140. 单词拆分 II</a></li><li><a href="https://leetcode-cn.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">149. 直线上最多的点数</a></li><li><a href="https://leetcode-cn.com/problems/word-search-ii/" target="_blank" rel="noopener">212. 单词搜索 II</a></li><li><a href="https://leetcode-cn.com/problems/the-skyline-problem/" target="_blank" rel="noopener">218. 天际线问题</a></li><li><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></li><li><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a></li><li><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. 二叉树的序列化与反序列化</a></li><li><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/" target="_blank" rel="noopener">301. 删除无效的括号</a></li><li><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></li><li><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a></li><li><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></li></ol><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><h5 id="1-交叉熵"><a href="#1-交叉熵" class="headerlink" title="1. 交叉熵"></a>1. 交叉熵</h5><p>$X$ 离散型随机变量，概率分布函数 $p(x)=Pr(X=x),x\in \chi $</p><p>$X=x_{0}$ 的<font color="red">信息量</font>为 $I(x_{0}) = -log(p(x_{0}))$ ，事件发生概率越大，携带信息量越少。</p><p><font color="red">熵</font>：所有可能取值的信息量的期望（$E[I(x)]$），是对一个随机变量的确定性的度量。熵越大，变量的取值越不确定。<br>$X$ 的熵：$H(X)=E_{p}\log \frac{1}{p(x)} = -\sum_{x \in \mathcal{X}}p(x)\log p(x)$ ；<br>若 $p(x)$ 是连续型随机变量则熵为：$H(X)=-\int_{x \in \mathcal{X}}p(x)\log p(x) dx$ ，约定$p(x) \to 0$时，$p(x) \log p(x) \to 0$<br>当$X$为$0-1$分布时，熵与概率 $p$ 的关系为抛物线。</p><p><font color="red">互信息</font>：两个随机变量 $X,Y$ 的互信息为 $X,Y$ 的联合分布和各自独立分布乘积的相对熵：</p><script type="math/tex; mode=display">I(X, Y)=\sum_{x, y} p(x, y) \log \frac{p(x, y)}{p(x) p(y)}</script><p><font color="red">相对熵</font>：又称为KL散度，KL距离，是两个随机分布间距离的度量，记为 $D_{KL}(p||q)$。度量当真实分布为 $p$ 时，假设分布 $q$ 的无效性。</p><script type="math/tex; mode=display">\begin{array}{l}{D_{K L}(p \| q)=E_{p}\left[\log \frac{p(x)}{q(x)}\right]=\sum_{x \in \mathcal{X}} p(x) \log \frac{p(x)}{q(x)}} \\ {=\sum_{x \in \mathcal{X}}[p(x) \log p(x)-p(x) \log q(x)]} \\ {=\sum_{x \in \mathcal{X}} p(x) \log p(x)-\sum_{x \in \mathcal{X}} p(x) \log q(x)} \\ {=-H(p)-\sum_{x \in \mathcal{X}} p(x) \log q(x)} \\ {=-H(p)+E_{p}[-\log q(x)]} \\ {=H_{p}(q)-H(p)}\end{array}</script><p>为保证连续性，约定 $0 \log \frac{0}{0} = 0$，$0 \log \frac{0}{q} = 0$，$p \log \frac{p}{0} = \infty$<br>当 $p=q时$，$D_{KL}(p||q)=0$。$H_{p}(q)$ 表示在 $p$ 分布下，使用 $q$ 进行编码需要的 bit 数。<br>$D_{KL}(p||q)$ 表示在真实分布为 $p$ 的前提下，使用 $q$ 分布进行编码相对于使用真实分布 $p$ 进行编码（最优编码）所多出来的 bit 数。且有 $D_{KL}(p||q) \ne D_{KL}(q||p)$ ，同时 $D_{KL}(p||q)$ 必大于等于 0。</p><p><font color="red">交叉熵</font>： 深度学习中的概念，一般用来求目标与预测值之间的差距，假设有两个分布 $p，q$ 则它们在给定样本集上的交叉熵为： </p><script type="math/tex; mode=display">C E H(p, q)=E_{p}[-\log q]=-\sum_{x \in \mathcal{X}} p(x) \log q(x)=H(p)+D_{K L}(p \| q)</script><p>当 $p$ 已知时，$H(p)$ 可看作常数，此时交叉熵与KL距离在行为上是等价的，都反应了分布 $p, q$ 的相似程度，且都将在$p=q$ 时取得最小值 $H(p)$。<br>当需要评估label和predicts之间的差距时，可使用KL散度，即$D_{KL}(y||\hat y)$，由于KL散度中的 $−H(y)$不变，故在优化过程中，只需要关注交叉熵就可以。所以一般在机器学习中直接用交叉熵做loss，进行评估模型。<br>特别的，在logistic regression中，<br>$p$: 真实样本分布，服从参数为 $p$ 的 $0-1$分布，即 $X∼B(1,p)$<br>$q$: 待估计的模型，服从参数为 $q$ 的 $0-1$ 分布，即 $X∼B(1,q)$</p><script type="math/tex; mode=display">\begin{array}{l}{C E H(p, q)} \\ {=-\sum_{x \in \mathcal{X}} \mathbf{p}(\mathbf{x}) \log \mathbf{q}(\mathbf{x})} \\ {=-\left[P_{p}(x=1) \log P_{q}(x=1)+P_{p}(x=0) \log P_{q}(x=0)\right]} \\ {=-[p \log q+(1-p) \log (1-q)]} \\ {=-\left[\mathbf{y} \log \mathbf{h}_{\theta}(x)+(1-\mathbf{y}) \log \left(1-\mathbf{h}_{\theta}(x)\right)\right]}\end{array}</script><p>对所有训练样本取均值：$-\frac{1}{m} \sum_{i=1}^{m}\left[y^{(i)} \log h_{\theta}\left(x^{(i)}\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right]$</p><h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><h5 id="1-LR"><a href="#1-LR" class="headerlink" title="1. LR"></a>1. LR</h5><p>线性回归：$z=\theta_{0} + \theta_{1}x_{1} + \theta_{2}x_{2} + \ldots + \theta_{n}x_{n}=\theta^{T}x$</p><p>逻辑回归是在线性回归基础上，在特征到结果的映射中加入了一层逻辑函数 $g(z)$（可将连续值映射到0和1），$g(z)$ 为sigmoid 函数：$g(z)=\frac {1}{1+e^{-z}}$，则：$h_{\theta}(x)=g\left(\theta^{T} x\right)=\frac{1}{1+e^{-\theta^{T} x}}$<br>sigmoid函数求导：</p><script type="math/tex; mode=display">\begin{aligned} g^{\prime}(z) &=\frac{d}{d z} \frac{1}{1+e^{-z}} \\ &=\frac{1}{\left(1+e^{-z}\right)^{2}}\left(e^{-z}\right) \\ &=\frac{1}{\left(1+e^{-z}\right)^{2}} \cdot\left(1-\frac{1}{\left(1+e^{-z}\right)}\right) \\ &=g(z)(1-g(z)) \end{aligned}</script><p>逻辑回归用来分类 $0/1$ 问题，假设二值满足伯努利分布：$P(y=1|x; \theta)=h_{\theta}(x)$，$P(y=0|x; \theta)=1-h_{\theta}(x)$ 可以写成如下形式：$p(y|x; \theta)=(h_{\theta}(x))^{y}(1-h_{\theta}(x))^{1-y}$<br>对于训练数据集，特征数据 $x=\{x_{1}, x_{2}, \ldots, x_{m} \}$ 和对应的分类数据 $y=\{y_{1}, y_{2}, \ldots , y_{m}\}$。构建逻辑回归模型，最典型的构建方法是应用极大似然估计。 假设m个样本相互独立，极大似然函数为：</p><script type="math/tex; mode=display">\begin{aligned} L(\theta) &=p(\vec{y} | X ; \theta) \\ &=\prod_{i=1}^{m} p\left(y^{(i)} | x^{(i)} ; \theta\right) \\ &=\prod_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)\right)^{y^{(i)}}\left(1-h_{\theta}\left(x^{(i)}\right)\right)^{1-y^{(i)}} \end{aligned}</script><script type="math/tex; mode=display">\begin{aligned} \ell(\theta) &=\log L(\theta) \\ &=\sum_{i=1}^{m} y^{(i)} \log h\left(x^{(i)}\right)+\left(1-y^{(i)}\right) \log \left(1-h\left(x^{(i)}\right)\right) \end{aligned}</script><p>使用梯度上升方法求最大值，则 $\theta:=\theta+\alpha \nabla_{\theta} \ell(\theta)$</p><script type="math/tex; mode=display">\begin{aligned} \frac{\partial}{\partial \theta_{j}} \ell(\theta) &=\left(y \frac{1}{g\left(\theta^{T} x\right)}-(1-y) \frac{1}{1-g\left(\theta^{T} x\right)}\right) \frac{\partial}{\partial \theta_{j}} g\left(\theta^{T} x\right) \\ &=\left(y \frac{1}{g\left(\theta^{T} x\right)}-(1-y) \frac{1}{1-g\left(\theta^{T} x\right)}\right) g\left(\theta^{T} x\right)\left(1-g\left(\theta^{T} x\right) \frac{\partial}{\partial \theta_{j}} \theta^{T} x\right.\\ &=\left(y\left(1-g\left(\theta^{T} x\right)\right)-(1-y) g\left(\theta^{T} x\right)\right) x_{j} \\ &=\left(y-h_{\theta}(x)\right) x_{j} \end{aligned}</script><p>对于一个训练样本 $(x, y)$ ，采用随机梯度上升规则，随机梯度上升更新规则为：$\theta_{j}:=\theta_{j}+\alpha\left(y^{(i)}-h_{\theta}\left(x^{(i)}\right)\right) x_{j}^{(i)}$<br>对数损失函数（逻辑回归中采用的损失函数）：$L(Y, P(Y|X))=- \log P(Y|X)$<br>逻辑回归的对数似然损失函数cost function：</p><script type="math/tex; mode=display">\operatorname{cost}\left(h_{\theta}(x), y\right)=\left\{\begin{array}{ll}{-\log \left(h_{\theta}(x)\right)} & {\text { if } y=1} \\ {-\log \left(1-h_{\theta}(x)\right)} & {\text { if } y=0}\end{array}\right.</script><p>当 $y=1$ 时，假定这个样本为正类。如果此时 $h_{θ}(x)=1$,则单对这个样本而言的cost=0,表示这个样本的预测完全准确。但如果此时预测的概率 $h_{θ}(x)=0$，那么 $cost→∞$。直观解释的话，由于此时样本为一个正样本，但是预测的结果$P(y=1|x;θ)=0$, 也就是说预测 $y=1$ 的概率为0，那么此时就要对损失函数加一个很大的惩罚项。<br>将以上两个表达式合并为一个，则单个样本的损失函数可以描述为：</p><script type="math/tex; mode=display">\operatorname{cost}\left(h_{\theta}(x), y\right)=-y_{i} \log \left(h_{\theta}(x)\right)-\left(1-y_{i}\right) \log \left(1-h_{\theta}(x)\right)</script><p>全体样本的损失函数可以表示为：</p><script type="math/tex; mode=display">\operatorname{cost}\left(h_{\theta}(x), y\right)=\sum_{i=1}^{m}-y_{i} \log \left(h_{\theta}(x)\right)-\left(1-y_{i}\right) \log \left(1-h_{\theta}(x)\right)</script><h4 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h4><p>参考： <a href="https://mp.weixin.qq.com/s/vVDAB2U7478yOXUT9ByjFw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vVDAB2U7478yOXUT9ByjFw</a> </p><p>RNN中存在梯度消失问题（反向传播过程中），梯度：用来更新神经网络权重的值（$new\ weight = weight - learning\ rate * gradient$），梯度消失：随着时间推移，梯度在传播时会下降，当梯度值很小时，学习将停止。</p><p>克服短期记忆问题的解决方案：LSTM 和 GRU，引入称为“门”的内部机制。</p><img src="/2019/11/29/算法面试题/1.png"><p>RNN 中每个 cell 单元计算隐藏状态：</p><img src="/2019/11/29/算法面试题/2.gif"><p>激活函数 Tanh：调节流经网络的值，且 Tanh 函数的输出值在（-1， 1）区间。</p><img src="/2019/11/29/算法面试题/3.gif"><p>LSTM 核心概念：单元状态（传递相关信息的通道）和各种门结构（决定记住或遗忘那些相关信息）</p><p>Sigmoid：门结构中包含此函数，函数的输出区间为（0， 1），有助于更新或遗忘数据。</p><img src="/2019/11/29/算法面试题/4.gif"><p>LSTM 单元中三种调节信息流的门结构：遗忘门，输入门和输出门</p><p>遗忘门：先前隐藏状态信息和当前输入信息同时输入到 Sigmoid 函数，输出值越接近 0 表示越应该忘记。</p><img src="/2019/11/29/算法面试题/5.gif"><p>输入门：更新单元状态，先前隐藏状态信息和当前输入信息同时输入到 Sigmoid 函数和 Tanh 函数，并将 Tanh 输出和Sigmoid 输出相乘， Sigmoid 输出将决定在 Tanh 输出中哪些信息重要且需要进行保留。 </p><img src="/2019/11/29/算法面试题/6.gif"><p>单元状态： 先前的单元状态和遗忘向量逐点相乘， 然后把它和输入门的输出值逐点相加，把神经网络发现的新信息更新到单元状态中，这样就得到了新的单元状态。 </p><img src="/2019/11/29/算法面试题/7.gif"><p>输出门：  决定在当前输入中哪些重要信息需要被添加 ，决定下个隐藏状态的值，隐藏状态中包含了先前输入的相关信息。 首先把先前的隐藏状态和当前输入传递给Sigmoid函数；接着把新得到的单元状态传递给 Tanh 函数；然后把 Tanh 输出和 Sigmoid 输出相乘，以确定隐藏状态应携带的信息；最后把隐藏状态作为当前单元输出，把新的单元状态和新的隐藏状态传输给下个时间步。</p><img src="/2019/11/29/算法面试题/8.gif"> <p>GRU 门控循环单元，去除单元状态，使用隐藏状态传递信息，含有两种门结构：更新门（ 类似 LSTM 中的遗忘门和输入门，决定要丢弃哪些信息和添加哪些新信息）和重置门（ 决定丢弃先前信息的程度 ）</p><h4 id="面试中涉及到的算法题："><a href="#面试中涉及到的算法题：" class="headerlink" title="面试中涉及到的算法题："></a>面试中涉及到的算法题：</h4><ol><li>剑指offer：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener">面试题53 - I. 在排序数组中查找数字 I</a></li><li>LeetCode: <a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></li><li>最短路径</li><li>最小的k个数</li><li>完全二叉树的节点个数</li><li>LeetCode: 判断一颗二叉树是否为搜索二叉树 <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></li><li>完全二叉树最右的节点</li><li>找出数组中所有和为traget的组合</li></ol><h4 id="什么时候使用归一化什么时候使用标准化"><a href="#什么时候使用归一化什么时候使用标准化" class="headerlink" title="什么时候使用归一化什么时候使用标准化"></a>什么时候使用归一化什么时候使用标准化</h4><h4 id="项目相关问题"><a href="#项目相关问题" class="headerlink" title="项目相关问题"></a>项目相关问题</h4><ol><li><strong>LSTM公式</strong></li><li><strong>RNN为什么出现梯度消失及BPTT的推导</strong></li><li><strong>GBDT和随机森林有什么区别</strong></li><li><strong>GBDT的原理，如何做分类和回归</strong></li><li><strong>随机森林的随机体现在哪方面</strong></li><li><strong>GBDT+LR是怎么做的?</strong></li><li><strong>XGBOOst和GBDT的区别</strong></li><li><strong>boosting和bagging的区别</strong></li><li><strong>bagging为什么能减小方差？</strong></li><li><strong>随即森林的随机体现在哪些方面</strong></li><li><strong>AdaBoost是如何改变样本权重</strong></li><li><strong>GBDT分类树拟合的是什么？</strong> </li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol><li><strong>Wide &amp;Deep的原理</strong></li><li><strong>数据之间如果不是独立同分布的会怎样</strong> </li><li><strong>AUC的原理介绍一下</strong></li><li><strong>神经网络里面的损失函数有哪些</strong></li><li><strong>机器学习中常见的激活函数有哪些？为什么通常需要零均值？</strong></li><li><strong>DeepFM介绍</strong></li><li><strong>FM推导</strong></li><li><strong>L1和L2有什么区别，从数学角度解释L2为什么能提升模型的泛化能力。</strong></li><li><strong>深度学习中，L2和dropout有哪些区别？</strong></li><li><strong>L1正则化有哪些好处</strong></li><li><strong>如果有一万个地理坐标，转换成1-10000的数，可以用决策树么？</strong></li><li><strong>CART分类树和ID3以及C4.5有什么区别？</strong></li><li><strong>early stop对参数有什么影响</strong> </li></ol><h4 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h4><ol><li><p><strong>推导逻辑回归的损失函数以及推导梯度更新公式</strong></p></li><li><p><strong>介绍一下深度学习常用来缓解过拟合的手段（至少5个）</strong> </p></li><li><p><strong>推荐系统常用的召回策略</strong> </p></li><li><p><strong>说一下LR， LR推导 </strong></p></li><li><p><strong>决策树分裂准则</strong></p></li><li><p><strong>信息熵与信息增益公式推导 </strong></p></li><li><p><strong>模型评价标准</strong></p></li><li><p><strong>svm、LR、xgb的损失函数</strong> </p></li><li><p><strong>LR和boost的区别，这次吸取前面的教训，先是细说了LR是什么，怎么推导来的，然后说Boost是什么，干什么用，以Adaboost和GDBT简单举例，最后说二者联系和区别</strong></p></li><li><p><strong>LR和SVM， LR和SVM训练目标的区别  </strong></p></li><li><p><strong>手写BP算法,伪代码</strong></p></li><li><p><strong>LR/Boost和朴素贝叶斯的区别</strong></p></li><li><p><strong>xgboost和随机森林</strong></p></li><li><p><strong>过拟合,  过拟合模型，和额外很大量数据，怎么判断这些数据有没有用？想到了采样，但是一时没想起来具体怎么办，最后面试官说，可以采样了用过拟合的模型去跑跑看误差 </strong></p></li><li><p><strong>知道什么参数范数惩罚？我答L1，L2是主要的，我还在别人的论文里见过Frobenius做参数软共享的。进而问我L1和L2的区别</strong> </p></li><li><p><strong>介绍一下你对推荐算法的了解</strong></p></li><li><p><strong>XGBoost的原理</strong></p></li><li><p><strong>XGBoost相比与GBDT的速度优势和效果优势的原因</strong></p></li><li><p><strong>线性模型和决策树模型对特征选择特征利用有哪些区别</strong></p></li><li><p><strong>决策树和线性模型哪个更好在线更新</strong></p></li><li><p><strong>过拟合出现的原因和解决方法</strong></p></li><li><p><strong>Dropout和BN不能解决过拟合吗</strong></p><p><img src="//pl741.github.io/2019/11/29/算法面试题/Users\warrior\AppData\Roaming\Typora\typora-user-images\image-20200419190033621.png" alt="image-20200419190033621"></p></li><li><p><strong>boosting和bagging的区别</strong><br> 1）样本选择上：<br> Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的.<br> Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化.而权值是根据上一轮的分类结果进行调整.<br> 2）样例权重：<br> Bagging：使用均匀取样，每个样例的权重相等<br> Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大.<br> 3）预测函数：<br> Bagging：所有预测函数的权重相等.<br> Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重.<br> 4）并行计算：<br> Bagging：各个预测函数可以并行生成<br> Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果.</p></li><li><p><strong>bagging为什么能减小方差</strong><br> 参考博客：<a href="https://blog.csdn.net/shenxiaoming77/article/details/53894973" target="_blank" rel="noopener">https://blog.csdn.net/shenxiaoming77/article/details/53894973</a></p><p><img src="//pl741.github.io/2019/11/29/算法面试题/Users\warrior\AppData\Roaming\Typora\typora-user-images\image-20200419190210473.png" alt="image-20200419190210473"></p><p>可能不懂的地方看下面的公式就知道了：</p><p><img src="//pl741.github.io/2019/11/29/算法面试题/Users\warrior\AppData\Roaming\Typora\typora-user-images\image-20200419190232946.png" alt="image-20200419190232946"></p></li><li><p><strong>交叉熵损失函数，0-1分类的交叉熵损失函数的。什么是凸函数？0-1分类如果用平方损失为什么用交叉熵而不是平方损失？</strong><br> 这里我们只回答最后一个问题，也就是说逻辑回归为什么不用平方损失？有两点原因：<br> 1）平方损失函数非凸函数。为什么非凸？凸函数二阶导数大于等于0，证明一下即可。<br> 2）但是会在h(wx)接近0和1的地方梯度很小，不容易学习。</p></li><li><p><strong>快速排序的过程以及最好和最坏情况</strong> </p></li><li><strong>hashmap以及如何解决冲突，红黑树以及平衡搜索树等</strong> </li><li><strong>常用的排序算法</strong> </li><li><strong>打印所有子集</strong></li><li><strong>打印螺旋矩阵</strong></li><li><strong>翻转列表前k个</strong></li><li><strong>字符串出现第k多的字符</strong></li><li><strong>覆盖字符串所有字符的最小子串,Leetcode第76题</strong></li><li><strong>字符串子串问题基本都是滑动窗口</strong></li><li><strong>找出0-1矩阵里，全1组成的最大矩形面积</strong></li><li><strong>矩阵上找路径或者覆盖，直接上DP，我刷过对应的medium难度最大正方形，顺着思路就写了，但是代码写的太丑不简练</strong></li><li><strong>问我有一个地理坐标，怎么从我所有的几千万几百万个poi中快速查询到离它最近的几个。我是想答分治、分层索引之类的，但是面试官实际是在问，怎么设计数据结构能最快，怎么把x,y这样的坐标对存成key，没答上让他满意的答案。</strong></li><li><strong>链表、字符串、迭代、dfs、堆、树、动态规划</strong></li></ol><h4 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h4><ol><li><p><strong>top(k) return sorted(A)[::-1][:k]?</strong></p></li><li><p><strong>算法题leetcode113</strong></p></li><li><p><strong>数据分布改变时，AUC有什么影响</strong></p></li><li><p><strong>auc的定义和计算方法</strong></p></li><li><p><strong>auc实际上衡量的是什么能力</strong></p></li><li><p><strong>roc曲线是否会出现先增后减的情况</strong></p></li><li><p><strong>过拟合怎么解决</strong></p></li><li><p><strong>方差和偏差</strong></p></li><li><p><strong>样本不均衡的处理方法</strong><br>权重调整，采样，对样本不均衡不敏感的指标，数据生成，对于正负样本极不均衡的还可以将问题转换成单类学习问题或者异常检测问题。<br>面试官补充：对样本不均衡不敏感的模型，比如SVM，XGB. 然后讨论了一波为什么XGB对样本不均衡不敏感</p></li><li><p><strong>dropout的原理、作用以及训练测试时的不同</strong></p></li><li><p><strong>BN的原理、作用以及训练测试时的不同</strong></p></li><li><p><strong>二叉搜索树求第2小</strong></p></li><li><p><strong>为什么数组排序都用快排不用归并</strong></p></li><li><p><strong>为什么数组排序都用快排不用归并</strong></p></li><li><p>口述SVM整个过程<br>重复的twosum<br>极大似然估计，条件，样本独立同分布<br>如果有2组独立同分布的数据，但模型分布不一样，怎么解决？EM算法，混合高斯模型<br>链表快排<br>合并两个排序链表并删除重复值</p><p>快排</p></li></ol><h4 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h4><ol><li>字符串转int </li><li>快排</li><li>最长上升子序列 (两个帖子上看到过)</li><li>2^n个数组，每个数组长度都是m，每个都是有序，合并成一个有序的数组 </li><li>链表合并</li><li>链表反转</li><li>链表转化，1-&gt;2-&gt;3-&gt;4-&gt;5-&gt; -&gt;7转化为1-&gt;7-&gt;2-&gt;6-&gt;3-&gt;5-&gt;4 </li><li>找出该节点二叉树中序遍历的下一个节点，如果树有父节点，在空间复杂度O（1）的情况下找出来</li><li>海量数据找出第K个（~40g数据） </li><li>一道经典的DP问题，接着让我介绍DP和递归的区别，以及详细介绍了根本的原因 </li></ol><p>给一个检索词，怎么给出库中相似度高的标签<br>根据你的项目问了问：<br>项目做什么的？<br>你怎么优化的？<br>你的参数是怎么初始化的。全部为0？随机初始化？高斯分布中随机取点？<br>比赛做了哪些工程<br>在京东有许多的不同的消费群体，我们如何找到学生群体并把他介绍给我们的用户。 </p><p>介绍BN层<br>归一化的作用<br>了解哪些机器学习方法<br>推导逻辑回归过程<br>正则化是怎么防止过拟合的？<br>L1正则化和L2正则化的区别？<br>介绍一下XGboost。<br>LSTM和GRU区别<br>rf和gbdt的区别<br>GBDT原理<br>boosting和bagging怎么减小偏差的</p><p>介绍一下决策树原理。介绍一下ID3、CART，逻辑树，描述一下交叉熵，通过交叉熵做loss 怎样体现，输入x1 x2 输出y1，y2 交叉熵如何计算，比如y1和y1’越接近loss为何越小 ，讲讲lr，svm（中间穿插提问，lr损失，svm损失，核函数，作用……） ，了解过svm？有哪些常用的核函数？介绍常用的loss，正负样本差异很大时怎么做（特征：归一化，样本上：采样：具体如何采样？？）， 出个题：概率题 （贝叶斯相关）  a,b丢硬币吃苹果，问吃到的概率 ，全连接层的定义 ，relu 好处 relu后面为0是为了什么（面试官说是为了解决梯度发散问题，小于0时梯度为负，而且可能负得越来越大），这个问题是这样解释吗？如果relu的左半轴为负那么它的梯度不是还是定值吗只是为负了….，常见的分类算法以及评估指标</p><p>卷积参数量计算，尺寸计算<br>ADAM算法比SGD优化好在哪儿？<br>是否用过时间序列相关的模型<br>如果自己写一个LR的话，要包含哪些模块（我只说到了训练部分，面试官补充了还有分类预测的模块）<br>Followup：接着问了我在做特征工程时很多的实际操作。<br>如何评估我们的聚类结果，以及如何提升<br>还问了如何Embedding的具体操作<br>python 参数 <em> 和 *</em> 区别 </p><p>  京东的了解 京东的竞争对手有哪些，京东有什么优势，还问跟阿里的比较， 中台 ， 京东和淘宝的商业模式区别？  身边人对你的评价？  自己的缺点 ， 为什么要考研 </p><p>京东的了解：京东是“中国最大的自营式电商企业”，以及“中国第二大B2C电商”（ B2C电子商务指的是企业针对个人开展的电子商务活动的总称 ）旗下有京东商城，京东金融（京东数科）主要产品有 <a href="https://baike.baidu.com/item/京东众筹" target="_blank" rel="noopener">京东众筹</a>、<a href="https://baike.baidu.com/item/京东白条" target="_blank" rel="noopener">京东白条</a>。 ，</p><p>自我介绍：您好，我是北京邮电大学研二学生潘琳，这次应聘的岗位是算法工程师暑期实习生，研究生期间在实验室的研究方向是机器学习，主要完成了两个相关的工作，第一个是自己参与的kaggle的一个比赛，主要是预测城市主要交通路口的红绿灯等待时间。第二个项目是实验室与一个牛场的合作项目，主要是基于牛场提供的奶牛数据进行发情检查，在这个项目中我主要承担了后期奶牛发情检测算法实现的工作，同时承担了部分的前期调研工作。以上这两个项目是与本次应聘的岗位密切相关的项目。</p><p>我认为我是一个责任心强，乐于助人，适应能力和自理能力较强的一个人（从初中开始住校），同时逻辑思维能力好。学习能力强（实验室在机器学习人工智能领域的基础相对薄弱，项目从无到有独立完成）。</p><p> 读研究生最大的收获是什么呢？ </p><p>  （2）如果做一项工作，大部分是由你完成的，但是被同事邀功，你怎么办？（注意分条作答条理清呀～我：如果同事已经邀功成功，那要自我反省，为什么自己做了大部分工作，却可以被别人邀功？还没有邀功成功，那要为自己争取一下。）</p><h4 id="微软"><a href="#微软" class="headerlink" title="微软"></a>微软</h4><p><a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">第一题leetcode137，写通用解法，要求时间复杂度O(n)，空间复杂度O(1)</a></p><p>介绍bagging和boosting</p><p>两个有序数组找第k大</p><p>写快排，问时间复杂度和空间复杂度, 输出排序后对应元素的原下标 </p><p>O（1）实现两个链表排序</p><p>编辑距离</p><p>如何判断两个链表是不是有交点 </p><p>一个BST树的某节点删除， BST 的类定义，实现 delete </p><p>最简单版的股票问题 </p><p>在排序数组中用二分查找找到某数字的第一个位置 </p><p>用栈模拟队列</p><p>最小栈，空间优化</p><p>算法题 1：原地移动数组，使得元素对应顺序不变，0 值移动到末尾，LeetCode 283</p><p>算法题 2：二叉树直径，LeetCode 543</p><p>lc79题，撕出来以后让写测试用例 </p><p>BST转双向链表（写代码，剑指offer原题）</p><p>lc原题：组合数的和，dfs回溯+剪枝。  </p><p>旋转数组找target，给n构造全部括号。</p><p>算法题：给一个数组 <code>A = [2, 4, 8, 3]</code> 输出一个数组 B，其中 <code>B[i]</code> 值为 A 中小于 <code>A[i]</code> 的元素值之和，B 应该为 <code>[0, 5, 9, 2]</code>（小于 2 的有 [0]，小于 4 的有 [2, 3] …） </p><p>求数组最大值时，从前往后遍历，候选值会被更新若干次，求这个次数的数学期望（说思路，我算出来是1+1/2 +…+ 1/n） </p><p>大数加法 </p><p>模型融合的时候，如果每个分类器正确率为0.5，投票法能不能得到正确率0.95</p><p>蓄水池采样及证明 </p><p>给定二维平面一些点，问用一个半径为1的圆最多可框住多少个点（说思路：每两个点确定两个对称的圆，当然两点距离不能超过直径2）</p><p><a href="https://blog.csdn.net/hanyajun0123/article/details/84320469" target="_blank" rel="noopener">第二题长度为n的环，走k步，从原点到原点有多少种走法</a></p><p>网易游戏面试：Python 进程和线程，不知道函数的参数有多少个时如何处理，C++ namespace 意义</p><h5 id="华为："><a href="#华为：" class="headerlink" title="华为："></a>华为：</h5><p>样本不平衡的理解，rebalance的具体做法，采样的不同的方法</p><p>MSE和交叉熵的区别</p><p>池化层的作用</p><p>1*1卷积的作用</p><p>写交叉熵</p><p>深度学习的特点，和机器学习的不同，dl和ml的输入数据有什么不同。</p><p> 实现浮点数转字符串：repr()函数可以将浮点数无损转换为字符串,也可能引入无效位<br>str(）函数会有精度损失 </p><p> 手撕了一道代码题leetcode第五道最大回文子串 </p><p> 数组连续序列的最大和 </p><p>算法题：给一个字符串，找出出现次数最多的字符。如果存在几个出现次数相同的字符，返回最早出现的字符</p><p> python编程：字符串大小写对换 </p><p> 手写动态规划路径，机器人走路那个 </p><p>手撕代码  “?”退格 比如  AAB？CC =AACC</p><p> 白纸手写代码  把扑克牌打乱 </p><p>手撕代码：树形运算节点，找出同时最大内存分配。</p><h4 id="概率题："><a href="#概率题：" class="headerlink" title="概率题："></a>概率题：</h4><ol><li><p><strong>50个红球和50个篮球，放入两个箱子，怎么样放置才能使拿到红球的概率最大？</strong></p><p>两个箱子概率是1/2，选中某个箱子后又有选择的是不是红球的概率，所以最大概率就是一个红球放在一个箱子里，其余的99个球全放到另一个箱子。这样概率=0.5+0.5*（49/99）约等于0.75，这样为最大概率。 </p></li><li><p><strong>从一副52张扑克牌中随机抽两种，颜色相等的概率</strong> （$C_{4}^1 C_{13}^2/C_{52}^2$）</p></li><li><p><strong>54张牌，分成6份，每份9张牌，大小王在一起的概率</strong></p><p>无论大王在那个位置，此时小王与大王在一起的位置一共8个，共53个位置可选，概率为 $8/53$</p></li><li><p><strong>52张牌去掉大小王，分成26*2两堆，从其中一堆取4张牌为4个a的概率</strong> </p><p>直觉告诉我分不分堆没有关系，这样想的话，答案是：$\frac{C_4^4}{C_{52}^{4}}$</p><p>考虑分堆的话：</p><p>1 先求分两堆，4张A出现在同一堆的概率： $ \frac{C_2^1 C_4^4 C_{48}^{22} C_{26}^{26}}{C_{52}^{26}C_{26}^{26}}$</p><p>2 在这两堆中，选中4张A同时出现的那一堆：$ \frac{1}{2}\frac{C_2^1 C_4^4 C_{48}^{22} C_{26}^{26}}{C_{52}^{26}C_{26}^{26}}$</p><p>3 从选中的这堆中，选4张牌出来是A的概率：$ \frac{1}{2}\frac{C_2^1 C_4^4 C_{48}^{22} C_{26}^{26}}{C_{52}^{26}C_{26}^{26}} \frac{C_{4}^{4}}{C_{26}^{4}}$</p></li><li><p><strong>一枚硬币，扔了一亿次都是正面朝上，再扔一次反面朝上的概率是多少？</strong></p><p>贝叶斯：有理由相信硬币的两面都是正面；频率学派：50%</p></li><li><p><strong>一对夫妻有2个孩子，求一个孩子是女孩的情况下，另一个孩子也是女孩的概率</strong> </p><p>一个家庭中有两个小孩只有四种可能{男， 男}，{男，女}， {女， 女}， {女， 男}，记事件A为：其中一个是女孩，事件B：另一个也是女孩，$P(A)=3/4$ ，$P(AB)=1/4$，求$P(B|A) = P(AB)/P(A)=1/3$</p></li><li><p><strong>已知N枚真硬币，M枚假硬币（两面都是国徽），取一枚硬币抛R次都是国徽，问真硬币的概率？</strong></p><img src="/2019/11/29/算法面试题/9.png"></li><li><p><strong>有8个箱子，现在有一封信，这封信放在这8个箱子中每一个的概率均为4/5, 不放在任何一个箱子的概率为1/5, 现在我打开1号箱子发现是空的，求下面7个箱子中含有这封信的概率？</strong></p><p>事件A：放信封事件，事件B：1号为空</p><script type="math/tex; mode=display">p(A|B) = \frac{p(AB)}{p(B)} = \frac{p(B|A)p(A)}{p(B|A)p(A) + p(B| \hat A)p(\hat A)}</script></li><li><p><strong>某城市发生了一起汽车撞人逃跑事件，该城市只有两种颜色的车，蓝20%绿80%，事发时现场有一个目击者，他指证是蓝车，但是根据专家在现场分析，当时那种条件能看正确的可能性是80%，那么，肇事的车是蓝车的概率是多少？</strong></p><p>事件A：肇事的车是蓝车，事件B：目击者指证蓝车，求$P(A|B)$，$P(A|B) = P(B|A)P(A)/P(B)$，$P(A)=0.2$，$P(B|A)=0.8$，计算$P(B)=P(A)P(B|A)+P(A^-)P(B|A^-)$， $P(A^-)=1-0.2$ ，关键是最后一项 $P(B|A^-)$ ，即肇事的车是绿车的条件下，目击者指正该车为蓝车的概率， 这一概率就是目击者看错的概率0.2。 $P(A|B)=(0.2<em>0.2)/(0.2</em>0.8+0.2*0.8)=0.5$</p></li><li><p><strong>有种癌症，早期的治愈率为0.8，中期的治愈率为0.5，晚期的治愈率为0.2.若早期没治好就会转为中期，中期没治好就会变成晚期。现在有一个人被诊断为癌症早期，然后被治愈了，问他被误诊为癌症的概率是多少？</strong></p><p>$p(cur|早) = 0.8$</p><p>$p(cur|中) = 0.2 * 0.5 = 0.1$</p><p>$p(cur|晚) = 0.2 <em> 0.5 </em> 0.2 = 0.02$</p></li><li><p><strong>100人坐飞机，第一个乘客在座位中随便选一个坐下，第100人正确坐到自己坐位的概率是？</strong></p><p>等价于这个描述：2-99号乘客登机后如果发现1号(疯子)坐在本属于自己的位子上，就会请疯子离开，然后疯子再随机找个空座。(就是平时大家在一票一座的交通工具上对号入座时的方式)这样到100号登机时，2-99号都在自己座位上，1号疯子在自己座位上和100号乘客座位上概率相同，所以是1/2。另外这个结果和总乘客数无关，可以由100推广至任意k。 </p></li><li><p><strong>一个国家重男轻女，只要生了女孩就继续生，直到生出男孩为止，问这个国家的男女比例？</strong>(每个孩子出生男女概率是50%，所以每次出生的男女比例是相同的。假设这个国家有n对夫妇，那么n对夫妇将生下n个男孩，这n个男孩是这样生下的，假设生男生女的概率是50%，那么n/2个男孩是第一胎生下的，同时将有 n/2个女孩生下，n/2对生女孩的夫妇将继续生，其中n/4的夫妇生下男孩，n/4的夫妇继续生下女孩，然后是n/8的夫妇顺利得到男孩，又有n/8的 夫妇生下女孩，依此类推，这个国家将生下n/2 + n/4 + n/8 + …的女孩，所以男女比例是n : (n/2 + n/4 + n/8 + …) = n : n = 1 : 1)</p></li><li><p><strong>某个一直函数返回0/1，0的概率为p，写一函数返回两数概率相等。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        a = f()</span><br><span class="line">        b = f()</span><br><span class="line">        <span class="keyword">if</span> a == <span class="number">0</span> <span class="keyword">and</span> b == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> a == <span class="number">1</span> <span class="keyword">and</span> b== <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>给你一个函数，这个函数是能得出1-5之间的随机数的，概率相同。现在求1-7之间随机函数，你如何做 </strong></p><p>要生成一个1-7的随机数，等可能概率。首先，考虑第一个问题：等可能概率。随机数是等概率的事件，就是1，2，3，4，5 出现的概率应该是相同的，而不是其中某一种概率大一点。看这个公式 $5<em>(x-1)+x$（x是1-5的随机数）那么 $5</em>(x-1)$会是等可能的0，5，10，15，20, x会是等可能的1，2，3，4，5；那么这个值就是等可能的0-25。<br>然后，考虑第二个问题：如何产生1-7？产生1-7最直观的方法就是：对7取模加一；但是0-25对7取模最后结果0-6产生的概率不一样；很简单，如果大于21，再随机一次就好了。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random7</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">5</span> * (random5()<span class="number">-1</span>) + random5()</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">21</span>:</span><br><span class="line">        <span class="keyword">return</span> random7()</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">7</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>X是一个以p的概率产生1,1-p的概率产生0的随机变量，利用X等概率生成1~n的数 </strong></p><p> 调用n次，每次出一个位，这样每个的概率都是 $p*(1-p)^n$ </p></li><li><p><strong>给你一个硬币，你如何获得2/3的概率 </strong></p><p>把这枚硬币扔两次，以下情况出现的概率相等：1. 正正，2. 正反，3.反正，4.反反，如果出现第4种情况则相当于采样失败，继续实验，如果在1~3种情况中出现1~2的情况则是一个2/3的概率</p></li><li><p><strong>一个袋子里有100个黑球和100个白球，每次随机拿出两个球丢掉，如果丢掉的是不同颜色的球，则从其他地方补充一个白球到袋子里，如果颜色相同，则补充一个黑球到袋子里。问：最后一个球是黑球和白球的概率分别为多大？</strong> ( 使用(黑球个数, 白球个数)来表示桶中黑球和白球的个数变动，正数表示增加，负数表示减少，根据规则找规律：<br>1、如果每次从桶里面拿出两个白球，则应放入一个黑球：(0, -2) + (1, 0) = (1, -2)；<br>2、如果每次从桶里面拿出两个黑球，则应放入一个黑球：(-2, 0) + (1, 0) = (-1, 0)；<br>3、如果每次从桶里面拿出一个白球和一个黑球，则应放入一个白球：(-1, -1) + (0, 1) = (-1, 0)；</p><pre><code>从以上各种情况可以看出以下规律：</code></pre><p>1）每次都会减少一个球，那么最后的结果肯定是桶内只剩一个球，要么是白球，要么是黑球；<br>2）每次拿球后，白球的数目要么不变，要么两个两个地减少；</p><pre><code>所以从上面的分析可以得知，最后不可能只剩下一个白球，那么必然就只能是黑球了。 )</code></pre></li><li><p><strong>一个公交站在1分钟内有车经过概率是p，问3分钟内有车经过概率</strong>（$1-(1-p)^3$）</p></li><li><p><strong>某段公路上1小时有车通过的概率是0.96，半小时有车通过的概率是多少 </strong></p><p>设半个小时有车经过的概率是p，那么一个小时内没有车经过的概率为$(1-p)^2$,那么一个小时内有车经过的概率为$1-(1-p)^2 = 0.96$， p=0.8 </p></li><li><p><strong>某大公司有这么一个规定：只要有一个员工过生日，当天所有员工全部放假一天。但在其余时候，所有员工都没有假期，必须正常上班。这个公司需要雇用多少员工，才能让公司一年内所有员工的总工作时间期望值最大？</strong>($E=n*(1-1/365)^n$，求导可得 $n=365$。 </p><p>一个人，对于任意一天，过生日的概率是 $1 / 365$, 不过生日的概率是 $ 364 / 365$</p><p>n个人，对于任意一天，没任何人过生日的概率是$(364 / 365)^n$ </p><p>n个人，对于任意一天，有人过生日的概率是 $1 - (364/ 365)^n$ </p><p>那么365天里有人过生日的期望天数是 $365(1 - (364 / 365)^n)$天，</p><p>则n个人，365天，每个人工作的期望天数是 $365 - 365(1 - (364 / 365)^n) = 365(364 /365)^n$ 从而所有人的期望工作天数的和为：$365n(364 / 365)^n$，求导数，导数不小于0，递增。)</p></li><li><p><strong>两人轮流扔硬币，扔出正面获胜，求：先扔者获胜的概率</strong> ( 设甲先抛。设甲胜率为x。则第一次甲抛了反面后，乙胜率为0.5x，从而甲胜率+乙胜率=x+0.5x=1，从而x=2/3。 )</p></li><li><p><strong>a b c 分别循环投掷硬币，直到正面出现胜利，求a b c获胜的概率</strong> ( $P(B) = 1/2<em>P(A)$; $P(C) = 1/4 </em> P(A)$; $P(A) + P(B) + P(C) = 1;$<br>得$P(A) = 4/7, P(B) = 2/7, P(C) = 1/7 $)</p></li><li><p><strong>硬币正反概率是1/2,一直抛硬币,直到连续两次正面停止，问期望次数</strong> </p><p>设期望为E，当开局抛到两次正面时，$0.5<em>0.5</em>2$</p><p>当开局抛到了反面时，需要重新抛，此时的期望分量时：$0.5*(E+1)$</p><p>当开局抛到了正面，但是紧接着抛到了反面，此时有需要重新抛，期望分量为：$0.5<em>0.5</em>(E+2)$</p><p>所以有：</p><script type="math/tex; mode=display">E = 0.5 * 0.5 * 2 + 0.5 *(E + 1) + 0.5* 0.5 *(E+2)</script><p>求解E=6</p></li><li><p><strong>扔骰子，最多扔两次，第一次扔完可以自行决定要不要扔第二次，取最后一次扔色子的结果为准，求：尽可能得到最大点数的数学期望 </strong></p><p> 对于扔一次骰子，他的期望是$\frac{1}{6} (1 + 2 ,\cdots, + 6) = 3.5$ ，那么此时的扔骰子的策略为，当我扔到1-3时，继续抛，当我扔到4-6时，停止。在选择继续抛的时候，之前的结果作废，此时相当于抛一次骰子。他的期望为3.5。当只投一次的时候，只会在[4, 5, 6]之间，他的期望是5，所以最终的期望是，（5+3.5）/2 = 4.25 </p></li><li><p><strong>给定二维平面一些点，问用一个半径为1的圆最多可框住多少个点</strong></p><p>枚举任意两点为弦的圆，然后再枚举其它点是否在圆内。用到了两个函数，atan2反正切函数</p></li><li><p><strong>求数组最大值时，从前往后遍历，候选值会被更新若干次，求这个次数的数学期望 </strong></p><p>对长为n的数组A，设该期望值为e(n)，则道e(1) = 1.考虑数组中最大的那个数max的位置：<br>a）max在第 i 位。p = 1/n，这时update的次数期望值为：1+e(n-1).<br>b）max不在第 i 位。p=(n-1)/n，这时update的次数期望值为：e(n-1).</p><script type="math/tex; mode=display">e(n) = (1+e(n-1))*1/n + e(n-1)*(n-1)/n</script><script type="math/tex; mode=display">= 1/n + e(n-1)</script><script type="math/tex; mode=display">= 1/n+1/(n-1)+e(n-1)</script><script type="math/tex; mode=display">=...= 1/n + 1/(n-1) + ... + 1/2 + e(1)= 1/n + 1/(n-1) + ... + 1</script><p>n=1，s[1]=1;<br>n=2, s[2]=1/2 + 1/2<em> (s[1] + 1); …..,<br>n = i 时 , s[i] = 1/i + 1/i</em>(s[1] + 1) + … + 1/i * (s[i - 1] + 1),<br>需要注意的是，当最大数在第 i 位时，更新次数不是 i，实际上是前 i-1 个更新次数的期望+1 </p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;刷题&quot;&gt;&lt;a href=&quot;#刷题&quot; class=&quot;headerlink&quot; title=&quot;刷题&quot;&gt;&lt;/a&gt;刷题&lt;/h4&gt;&lt;h5 id=&quot;4-22-剑指offer简单题：&quot;&gt;&lt;a href=&quot;#4-22-剑指offer简单题：&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://pl741.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法面试题" scheme="http://pl741.github.io/tags/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-Python</title>
    <link href="http://pl741.github.io/2019/11/08/%E5%89%91%E6%8C%87offer-Python/"/>
    <id>http://pl741.github.io/2019/11/08/剑指offer-Python/</id>
    <published>2019-11-08T03:51:07.000Z</published>
    <updated>2020-05-14T13:45:48.497Z</updated>
    
    <content type="html"><![CDATA[<p>参考：动图来自牛客网（ <a href="https://www.nowcoder.com/discuss/198840?type=1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/198840?type=1</a> ）和 RUNOOB.COM</p><h5 id="面试题-3-1：数组中重复的数字"><a href="#面试题-3-1：数组中重复的数字" class="headerlink" title="面试题 3.1：数组中重复的数字"></a>面试题 3.1：数组中重复的数字</h5><p>长度为n的数组，所有数字都在0~n-1的范围内，找出数组中任意重复的数字。</p><p>三种方法：</p><ol><li>首先将所有数字排序，然后从头到尾扫描排序后的数组。时间复杂度为$O(nlogn)$</li><li>利用哈希表，从头到尾扫描数组，每一个数字利用$O(1)$的时间检查数字是否在哈希表中，如果没有则加入，如果存在表明此数字重复。时间复杂度$O(n)$，空间复杂度$O(n)$。</li><li>利用从0~n-1个共n个数字这一特点，若无重复数字，排序后数字 $i$ 在数组下标 $i$ 的位置上。从头开始扫描数组$arr$，记扫描到下标为 $i$ 的数字$arr[i]$为 $m$，比较 $i==m $，若相等，$i+1$，若不等则比较$arr[m]$和$m$， 若相等，找到重复数字，若不等则交换数组 $i, m$位置上的数。每个数字最多交换两次就能找到属于自己的位置。时间复杂度$O(n)$， 空间复杂度$O(1)$。<img src="/2019/11/08/剑指offer-Python/1.gif"> </li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> numbers == <span class="literal">None</span> <span class="keyword">or</span> len(numbers) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            <span class="keyword">if</span> numbers[i] &lt; <span class="number">0</span> <span class="keyword">or</span> numbers[i] &gt; len(numbers) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            <span class="keyword">while</span> numbers[i] != i:</span><br><span class="line">                <span class="keyword">if</span> numbers[i] == numbers[numbers[i]]:</span><br><span class="line">                    duplication[<span class="number">0</span>] = numbers[i]</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp = numbers[i]</span><br><span class="line">                    numbers[i] = numbers[temp]</span><br><span class="line">                    numbers[temp] = temp</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-3-2-：不修改数组找出重复的数字"><a href="#面试题-3-2-：不修改数组找出重复的数字" class="headerlink" title="面试题 3.2 ：不修改数组找出重复的数字"></a>面试题 3.2 ：不修改数组找出重复的数字</h5><p>长度为$n+1$的数组，所有数字都在1~n的范围内，不修改数组找出数组中任意重复的数字。</p><p>两种解决方法：</p><ol><li>利用一个辅助数组，从头扫描原数组，将数字 $i$ 放入新数组下标为 $i$ 的位置。时间复杂度$O(n)$，空间复杂度$O(n)$。</li><li>二分查找变形：1~n范围内只有n个数字，一定含有重复数字，某范围内数字的个数是解决问题的关键。首先把1~n的数字从中间数字分开前半部分1~m，后半部分m+1~n， 查看1~m范围上数字的个数，若大于m，有重复，再将1~m范围的数字二分，否则检查m+1~n范围的数字个数。时间复杂度$O(nlogn)$, 空间复杂度$O(1)$。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> numbers == <span class="literal">None</span> <span class="keyword">or</span> len(numbers) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        start = <span class="number">1</span></span><br><span class="line">        end = len(numbers)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> end &gt;= start:</span><br><span class="line">            middle = (end-start) // <span class="number">1</span> + start</span><br><span class="line">            count = self.countRange(numbers, start, middle)</span><br><span class="line">            <span class="keyword">if</span> end == start:</span><br><span class="line">                <span class="keyword">if</span> count &gt; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; middle - start + <span class="number">1</span>:</span><br><span class="line">                end = middle</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = middle + <span class="number">1</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countRange</span><span class="params">(numbers, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> numbers == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            <span class="keyword">if</span> start&lt;= numbers[i] <span class="keyword">and</span> numbers[i] &lt;= end:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-4：-二维数组中的查找"><a href="#面试题-4：-二维数组中的查找" class="headerlink" title="面试题 4： 二维数组中的查找"></a>面试题 4： 二维数组中的查找</h5><p>一个二维数组其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在二维数组中。 </p><ol><li>从右上角开始或者从左下角开始。从右上角开始，若大于要找的数，去掉一列，若小于要找的数，去掉一行。<img src="/2019/11/08/剑指offer-Python/2.gif"></li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> array == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        m = len(array)</span><br><span class="line">        n = len(array[<span class="number">0</span>])</span><br><span class="line">        row = <span class="number">0</span>  <span class="comment"># 注意m和row的取值，row的取值为0-m-1</span></span><br><span class="line">        col = n - <span class="number">1</span> </span><br><span class="line">        <span class="keyword">while</span> row &lt; m <span class="keyword">and</span> col &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> target &gt; array[row][col]:</span><br><span class="line">                row += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> target &lt; array[row][col]:</span><br><span class="line">                col -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-5：-替换空格"><a href="#面试题-5：-替换空格" class="headerlink" title="面试题 5： 替换空格"></a>面试题 5： 替换空格</h5><p>把字符串中的每个空格替换成“%20”</p><p>两种解决方法：</p><ol><li>创建一个新的字符串，在新的字符串上做替换，需要足够的内存</li><li>在原字符串上替换，可能会覆盖修改在该字符串后面的内存，准备两个指针<font color="red">从后向前</font>替换，  $P1$ 指向字符串原来的末尾位置，$P2$ 指向字符串替换后的末尾位置 ，将$P1 $和$P2$从后向前遍历，当 $P1$遇到空格时，  $P1$向前移动一格，  $P2$写入%20（注意逆序写入02%）  否则就在$P2$位置填充$P1$内容，当$P1$与$P2$相等，所有空格替换完成。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s == null:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        s = list(s)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">' '</span>: count += <span class="number">1</span></span><br><span class="line">        p1 = len(s) - <span class="number">1</span></span><br><span class="line">        s += [<span class="literal">None</span>] * count * <span class="number">2</span></span><br><span class="line">        p2 = len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &gt;= <span class="number">0</span> :</span><br><span class="line">            <span class="keyword">if</span> s[p1] == <span class="string">' '</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">'0'</span>, <span class="string">'2'</span>, <span class="string">'%'</span>]:</span><br><span class="line">                    s[p2] = i</span><br><span class="line">                    p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s[p2] = s[p1]</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            p1 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-6：-从尾到头打印链表"><a href="#面试题-6：-从尾到头打印链表" class="headerlink" title="面试题 6： 从尾到头打印链表"></a>面试题 6： 从尾到头打印链表</h5><ol><li>允许修改链表结构：改变链表的方向，</li><li>不允许修改链表结构：后进先出——栈结构</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> listNode:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            result.append(listNode.val)</span><br><span class="line">            listNode = listNode.next</span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-7：-重建二叉树"><a href="#面试题-7：-重建二叉树" class="headerlink" title="面试题 7： 重建二叉树"></a>面试题 7： 重建二叉树</h5><p>输入某二叉树的前序遍历和中序遍历（输入的前序遍历和中序遍历的结果中不含重复数字），重建该二叉树并输出头节点。</p><ol><li>前序遍历中，第一个数字是二叉树的头节点，此数字在中序遍历中处于中间位置，且位于左边的是左树上的节点。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        val = tin.index(pre[<span class="number">0</span>])</span><br><span class="line">        root.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:val+<span class="number">1</span>], tin[<span class="number">0</span>:val])</span><br><span class="line">        root.right = self.reConstructBinaryTree(pre[val+<span class="number">1</span>:], tin[val+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-8：-二叉树的下一个节点"><a href="#面试题-8：-二叉树的下一个节点" class="headerlink" title="面试题 8：  二叉树的下一个节点"></a>面试题 8：  二叉树的下一个节点</h5><p>给定一棵二叉树和其中一个节点，获取中序遍历的下一个节点。（树节点的结构中含有指向父节点的指针）</p><ol><li>节点有右子树：节点的下一个节点为右子树的最左节点。</li><li>节点无右子树且此节点为其父节点的左子节点：其父节点即为下一个节点；</li><li>节点无右子树且此节点为其父节点的右子节点：向上追溯，直到找到一个节点为其父节点的左子节点，父节点即为下一个节点。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeLinkNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pNode:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        rightTree = pNode.right</span><br><span class="line">        <span class="keyword">if</span> rightTree != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> rightTree.left != <span class="literal">None</span>:</span><br><span class="line">                rightTree = rightTree.left</span><br><span class="line">            <span class="keyword">return</span> rightTree</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> pNode.next != <span class="literal">None</span> <span class="keyword">and</span> pNode.next.left != pNode:</span><br><span class="line">                pNode = pNode.next</span><br><span class="line">            <span class="keyword">return</span> pNode.next</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-9-1：-用两个栈实现队列"><a href="#面试题-9-1：-用两个栈实现队列" class="headerlink" title="面试题 9.1： 用两个栈实现队列"></a>面试题 9.1： 用两个栈实现队列</h5><p>实现 appendTail 和 deleteHead 分别完成在队列尾部插入结点和在队列头部删除节点。</p><ol><li>头部删除一个节点：若stack2为空，将stack1中所有元素依次弹出存入stack2中，并将stack2栈顶弹出；若stack2不为空，直接弹出stack2的栈顶。</li><li>尾部插入一个节点：压入stack1即可。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">            <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stack2.pop()</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-9-2：-用两个队列实现一个栈"><a href="#面试题-9-2：-用两个队列实现一个栈" class="headerlink" title="面试题 9.2： 用两个队列实现一个栈"></a>面试题 9.2： 用两个队列实现一个栈</h5><p>实现栈的压入和弹出</p><ol><li>栈的弹出：找出两个队列中不为空的，保留最后一个元素，前面所有元素放入另一个为空的队列中，并将最后一个元素弹出。</li><li>栈的压入：当两个队列都为空时，插入其中一个队列，若有一个队列不为空，插入队尾。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.queue1 = []</span><br><span class="line">        self.queue2 = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.queue1:</span><br><span class="line">            self.queue.append(node)</span><br><span class="line">        <span class="keyword">elif</span> self.queue2:</span><br><span class="line">            self.queue2.append(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.queue1.append(nodde)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.queue1 <span class="keyword">and</span> <span class="keyword">not</span> self.queue2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.queue1:</span><br><span class="line">            <span class="keyword">while</span> len(self.queue1) != <span class="number">1</span>:</span><br><span class="line">                self.queue2.append(self.queue1.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> self.queue1.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> len(self.queue2) != <span class="number">1</span>:</span><br><span class="line">                self.queue1.append(elf.queue2.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> self.queue2.pop()</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-10-1-：斐波那契数列"><a href="#面试题-10-1-：斐波那契数列" class="headerlink" title="面试题 10.1 ：斐波那契数列"></a>面试题 10.1 ：斐波那契数列</h5><p>求斐波那契数列的第n项。</p><script type="math/tex; mode=display">f(n)=\left\{\begin{array}{rl}{0} & {n=0} \\ {1} & {n=1} \\ {f(n-1)+f(n-2)} & {n>1}\end{array}\right.</script><ol><li>递归方法：但有严重的效率问题，原因是会重复计算很多节点，造成其时间复杂度以 n 的指数的方式递增。</li><li>for循环：避免重复计算，将已经计算过的数列中间项保存起来。从下往上计算，时间复杂度$O(n)$。</li><li>利用两个数学公式，时间复杂度为$O(\log n)$，但不实用，且隐含的时间常数较大。<script type="math/tex; mode=display">\left[\begin{array}{l}{f(n)} & {f(n-1)} \\ {f(n-1)} & {f(n-2)}\end{array}\right]=\left[\begin{array}{ll}{1} & {1} \\ {1} & {0}\end{array}\right]^{n-1}</script><script type="math/tex; mode=display">a^{n}=\left\{\begin{array}{ll}{a^{n / 2} \cdot a^{n / 2}} & {n为偶数} \\ {a^{(n-1) / 2} \cdot a^{(n-1) / 2} \cdot a} & {n为奇数}\end{array}\right.</script></li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        <span class="keyword">elif</span> n &lt;=<span class="number">39</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">                result = a + b</span><br><span class="line">                a = b</span><br><span class="line">                b = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-10-2-：青蛙跳台阶问题"><a href="#面试题-10-2-：青蛙跳台阶问题" class="headerlink" title="面试题 10.2 ：青蛙跳台阶问题"></a>面试题 10.2 ：青蛙跳台阶问题</h5><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。该青蛙跳上一个 n 级的台阶共有多少种跳法（先后次序不同算不同的结果）。<br>$n=1$时只有一种跳法；$n=2$时，两种跳法（每次跳一个台阶 / 一次跳两个台阶）；$n&gt;2$时，第一跳有两种不同的选择，跳一个台阶（剩下$n-1$个台阶）或跳两个台阶（剩下$n-2$个台阶）。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">while</span> len(res) &lt; number:</span><br><span class="line">                res.append(res[<span class="number">-1</span>] + res[<span class="number">-2</span>])</span><br><span class="line">            <span class="keyword">return</span> res[number<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-10-3-：变态跳台阶"><a href="#面试题-10-3-：变态跳台阶" class="headerlink" title="面试题 10.3 ：变态跳台阶"></a>面试题 10.3 ：变态跳台阶</h5><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级…也可以跳上n级。该青蛙跳上一个 n 级的台阶总共有多少种跳法。<br>$n= 1$, 则剩下跳法是f(n-1)；$n=2$级，则剩下跳法是$f(n-2)$；所以$f(n)=f(n-1)+f(n-2)+…+f(1)$<br>因为$f(n-1)=f(n-2)+f(n-3)+…+f(1)$，所以$f(n)=2*f(n-1)$，则$f(n)=2^{n-1}$种跳法。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> number<span class="number">-1</span> &gt; <span class="number">0</span>:</span><br><span class="line">            res = res * <span class="number">2</span></span><br><span class="line">            number = number <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-10-4-：矩形覆盖"><a href="#面试题-10-4-：矩形覆盖" class="headerlink" title="面试题 10.4 ：矩形覆盖"></a>面试题 10.4 ：矩形覆盖</h5><p>可以用$2 <em> 1$的小矩形横着或者竖着去覆盖更大的矩形。请问用n个$2 </em>1$的小矩形无重叠地覆盖一个$2 * n$的大矩形，总共有多少种方法？ </p><ol><li>若横着放，则剩下的部分为$n-1$</li><li>若竖着放，则剩下的部分为$n-2$</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        res_1 = <span class="number">1</span></span><br><span class="line">        res_2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> number - <span class="number">1</span> &gt; <span class="number">0</span>:</span><br><span class="line">            res = res_1 + res_2</span><br><span class="line">            res_1 = res_2</span><br><span class="line">            res_2 = res</span><br><span class="line">            number = number - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-11：旋转数组的最小数字"><a href="#面试题-11：旋转数组的最小数字" class="headerlink" title="面试题 11：旋转数组的最小数字"></a>面试题 11：旋转数组的最小数字</h5><p>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 ( 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。)</p><ol><li>遍历数组：时间复杂度$O(N)$</li><li><p>二分法：旋转后的数组划分为两个排序的子数组，且前面子数组元素都大于或者等于后面子数组的元素，最小元素为分界线。<br>步骤：</p><ol><li>使用两个指针分别指向数组的开始$P_{1}$和结尾$P_{2}$，</li><li>若第一个数字小于最后一个数字：说明第一个数即为最小元素。</li><li><p>若第一个数大于或等于最后一个数：找到$P_{1}$和$P_{2}$中间位置的数，若此数大于$P_{1}$所指的数，则$P_{1}=\frac {P_{1}+P_{2}}{2}$，若此数小于或等于$P_{2}$所指的数，则$P_{2}=\frac {P_{1}+P_{2}}{2}$，如此循环直到$P_{1}$和$P_{2}$相邻时，$P_{2}$所指的数字即为最小元素。</p><p>特殊情况：若$P_{1}$位置上的数等于$P_{2}$位置上的数且等于它们中间的数字时：需采用顺序查找的方法进行查找</p></li></ol></li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        p1 = <span class="number">0</span></span><br><span class="line">        p2 = len(rotateArray)<span class="number">-1</span></span><br><span class="line">        mid = p1</span><br><span class="line">        <span class="keyword">while</span> rotateArray[p1] &gt;= rotateArray[p2]:</span><br><span class="line">            <span class="keyword">if</span> p2 - p1 == <span class="number">1</span>:</span><br><span class="line">                mid = p2</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            mid = (p1+p2)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[p1] == rotateArray[mid] <span class="keyword">and</span> rotateArray[p2] == rotateArray[mid]:</span><br><span class="line">                <span class="keyword">return</span> self.minValue(rotateArray, p1, p2)</span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid] &gt;= rotateArray[p1]:</span><br><span class="line">                p1 = mid</span><br><span class="line">            <span class="keyword">elif</span> rotateArray[mid] &lt;= rotateArray[p2]:</span><br><span class="line">                p2 = mid</span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minValue</span><span class="params">(self, rotateArray, p1, p2)</span>:</span></span><br><span class="line">        res = rotateArray[p1]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(p1+<span class="number">1</span>, p2+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> rotateArray[i] &lt; res:</span><br><span class="line">                res = rotateArray[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-12：矩阵中的路径"><a href="#面试题-12：矩阵中的路径" class="headerlink" title="面试题 12：矩阵中的路径"></a>面试题 12：矩阵中的路径</h5><p>判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。<br>路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 </p><ol><li>回溯法：回溯法算法适合使用递归实现<br>路径不能重复进入矩阵的格子，需要定义和字符矩阵大小一样的布尔值矩阵，标识路径是否已经进入了每个格子。<font color="red">通常在二维矩阵上找路径的问题都可以应用回溯法解决。</font></li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">and</span> rows &lt; <span class="number">1</span> <span class="keyword">and</span> cols &lt; <span class="number">1</span> <span class="keyword">and</span> path==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        visited = [<span class="number">0</span>] * (rows * cols)</span><br><span class="line">        pathLength = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> self.hasPathCore(matrix, rows, cols, row, col, path, pathLength, visited):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathCore</span><span class="params">(self, matrix, rows, cols, row, col, path, pathLength, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == pathLength:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        hasPath = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> row &gt;= <span class="number">0</span> <span class="keyword">and</span> row &lt; rows <span class="keyword">and</span> col &gt;= <span class="number">0</span> <span class="keyword">and</span> col &lt; cols <span class="keyword">and</span> matrix[row*cols+col]== path[pathLength] <span class="keyword">and</span> <span class="keyword">not</span> visited[row*cols+col]:</span><br><span class="line">            pathLength += <span class="number">1</span></span><br><span class="line">            visited[row*cols+col] = <span class="number">1</span></span><br><span class="line">            hasPath = self.hasPathCore(matrix, rows, cols, row<span class="number">-1</span>, col, path, pathLength, visited) \</span><br><span class="line">                    <span class="keyword">or</span> self.hasPathCore(matrix, rows, cols, row+<span class="number">1</span>, col, path, pathLength, visited) \</span><br><span class="line">                    <span class="keyword">or</span> self.hasPathCore(matrix, rows, cols, row, col<span class="number">-1</span>, path, pathLength, visited) \</span><br><span class="line">                    <span class="keyword">or</span> self.hasPathCore(matrix, rows, cols, row, col+<span class="number">1</span>, path, pathLength, visited)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> hasPath:</span><br><span class="line">                pathLength -= <span class="number">1</span></span><br><span class="line">                visited[row*cols+col] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> hasPath</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-13：-机器人的运动范围"><a href="#面试题-13：-机器人的运动范围" class="headerlink" title="面试题 13： 机器人的运动范围"></a>面试题 13： 机器人的运动范围</h5><p>地上有一个 m 行和 n 列的方格。一个机器人从坐标$(0,0)$的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。 请问该机器人能够达到多少个格子？ （回溯法）<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> threshold &lt; <span class="number">0</span> <span class="keyword">and</span> rows &lt; <span class="number">1</span> <span class="keyword">and</span> cols &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        visited = [<span class="number">0</span>] * (rows * cols)</span><br><span class="line">        count = self.movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCountCore</span><span class="params">(self, threshold, rows, cols, row, col, visited)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.check(threshold, rows, cols, row, col, visited):</span><br><span class="line">            visited[row*cols + col] = <span class="number">1</span></span><br><span class="line">            count = <span class="number">1</span> + self.movingCountCore(threshold, rows, cols, row+<span class="number">1</span>, col, visited)\</span><br><span class="line">                    + self.movingCountCore(threshold, rows, cols, row<span class="number">-1</span>, col, visited)\</span><br><span class="line">                    + self.movingCountCore(threshold, rows, cols, row, col<span class="number">-1</span>, visited)\</span><br><span class="line">                    + self.movingCountCore(threshold, rows, cols, row, col+<span class="number">1</span>, visited)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, threshold, rows, cols, row, col, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> row &gt;= <span class="number">0</span> <span class="keyword">and</span> row &lt; rows <span class="keyword">and</span> col &gt;= <span class="number">0</span> <span class="keyword">and</span> col &lt; cols <span class="keyword">and</span> <span class="keyword">not</span> visited[row * cols + col] <span class="keyword">and</span> self.getDigitSum(row) + self.getDigitSum(col) &lt;= threshold:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDigitSum</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">            sum += number % <span class="number">10</span></span><br><span class="line">            number /= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题-14：-剪绳子"><a href="#面试题-14：-剪绳子" class="headerlink" title="面试题 14： 剪绳子"></a>面试题 14： 剪绳子</h5><p>给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（m、n都是整数，$n&gt;1$并且$m&gt;1$），每段绳子的长度记为$k[0],k[1],…,k[m]$。请问$k[0]<em>k[1]</em>…*k[m]$可能的最大乘积是多少？ </p><ol><li><p>动态规划：时间复杂度$O(n^{2})$，空间复杂度$O(n)$，可以应用动态规划求解的问题的三个特点：</p><ol><li>求一个问题的最优解</li><li>整体问题的最优解依赖各个子问题的最优解</li><li>大问题可分解为若干小问题，小问题之间还有相互重叠的更小的子问题</li></ol><p><font color="red">从上往下分析问题，从下往上求解问题。</font><br>定义$f(n)=max(f(i)*f(n-i))其中0&lt;i&lt;n$，当$n=0, 1, 2, 3$时$f(n)&lt;n$为特例，需单独处理。</p></li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> number == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> number == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        res = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>, number+<span class="number">1</span>):</span><br><span class="line">            res_max = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, int(i/<span class="number">2</span>)+<span class="number">1</span>):</span><br><span class="line">                product = res[j] * res[i-j]</span><br><span class="line">                <span class="keyword">if</span> product &gt; res_max:</span><br><span class="line">                    res_max = product</span><br><span class="line">            res.append(res_max)</span><br><span class="line">        <span class="keyword">return</span> res[number]</span><br></pre></td></tr></table></figure></div></div><ol><li>贪婪算法：时间复杂度$O(1)$，空间复杂度$O(1)$<br>每一步做出一个贪婪选择，基于这个选择，确定能够得到最优解。<br>策略：当$n\ge 5$时，尽可能多地剪长度为3地绳子，当剩下地绳子的长度为4时，将绳子剪成长度为2的绳子。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> number == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> number == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        num_3 = int(number / <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">if</span> number - num_3 * <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">            num_3 -= <span class="number">1</span></span><br><span class="line">        num_2 = (number - num_3 * <span class="number">3</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">3</span> ** num_3) * (<span class="number">2</span> ** num_2)</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-15：二进制中-1-的个数"><a href="#面试题-15：二进制中-1-的个数" class="headerlink" title="面试题 15：二进制中 1 的个数"></a>面试题 15：二进制中 1 的个数</h5><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 </p><ol><li>右移法：判断整数二进制表示中最右边一位是否为 1（和 1 做“与运算”，输出为 1 表示最右位为 1)，之后整数右移，继续判断。注意：不能利用除 2 代替位运算（效率低）且当整数为负数时会出现死循环。</li><li>避免死循环：不右移输入数字，每次左移 1 ，依次循环，循环的次数等于整数二进制的位数。</li><li>把一个整数减去1，再和原整数做“与运算”，会把该整数最右边的1变成0。那么一个整数的二进制中表示中有多少个1，就可以进行多少次这样的操作。  <font color="red">把一个整数减去 1 之后再和原来的整数做“位与”运算，得到的结果相当于把整数的二进制表示中最右边的 1 变成 0。</font></li></ol><img src="/2019/11/08/剑指offer-Python/3.png"><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span> :</span><br><span class="line">      n = n &amp; <span class="number">0xffffffff</span>  <span class="comment"># 负数采用补码的形式</span></span><br><span class="line">      <span class="keyword">while</span> n:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        n = (n - <span class="number">1</span>) &amp; n</span><br><span class="line">      <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></div></div><p>相关题目：</p><ol><li>判别一个整数是不是 2 的整数次方：如果是，则它的二进制表示中有且仅有一位为 1，其他所有位为 0。</li><li>修改 m 的二进制表示中的多少位能得到 n：先将两个数异或，统计异或结果中 1 的个数（位数）。</li></ol><h5 id="面试题-16：数值的整数次方"><a href="#面试题-16：数值的整数次方" class="headerlink" title="面试题 16：数值的整数次方"></a>面试题 16：数值的整数次方</h5><p>考虑代码的完整性：</p><ol><li>输入的指数小于 1 时（零或负数）：当指数为负数时，可先对指数求绝对值，计算出次方结果后取倒数。当底数为 0 且指数为负数时，出现对 0 求倒数，需处理异常出错情况。</li><li>0 的 0 次方没有数学意义，输出为 0 或 1 均可。</li><li>利用公式实现时间复杂度为 $O(\log n)$ ：<script type="math/tex; mode=display">a^{n}=\left\{\begin{array}{ll}{a^{n / 2} \cdot a^{n / 2}} & {n为偶数} \\ {a^{(n-1) / 2} \cdot a^{(n-1) / 2} \cdot a} & {n为奇数}\end{array}\right.</script></li><li>其他细节问题：右移运算——&gt; 除2，位与运算——&gt; 求余 <font color="red">判断 num 为奇数还是偶数：【num & 0x1 】为 1 表明为奇数，即二进制的最低位为1。</font></li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.g_InvalidInput = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> base == <span class="number">0.0</span> <span class="keyword">and</span> exponent &lt; <span class="number">0</span>:</span><br><span class="line">            self.g_InvalidInput = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">if</span> exponent &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.PowerWithUnsignedExponent(base, exponent)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> / self.PowerWithUnsignedExponent(base, -exponent)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> exponent == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> exponent == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> base</span><br><span class="line">        res = self.PowerWithUnsignedExponent(base, exponent&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        res *= res</span><br><span class="line">        <span class="keyword">if</span> exponent &amp; <span class="number">0x1</span>:</span><br><span class="line">            res *= base</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-17：-打印从-1-到最大的-n-位数"><a href="#面试题-17：-打印从-1-到最大的-n-位数" class="headerlink" title="面试题 17： 打印从 1 到最大的 n 位数"></a>面试题 17： 打印从 1 到最大的 n 位数</h5><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。 </p><ol><li>n 的范围：当 n 很大时，最大 n 位数为整型或长整型是否都会溢出？<br>解决办法：需要表达一个大数，可使用字符串或者数组<ol><li>字符串表示大数：字符串中每个字符都是‘0’~‘9’之间的某个字符，表示数字中的一位。数字最大是 n 位的，需要一个长度为 n的字符串，实际数字不够 n 位时，字符串前半部分补0。需完成两件事情：a. 在字符串表达的数字上模拟加法；（只有在达到最大的 n 位十进制数时 +1 操作会在第一个字符上出现进位）b. 打印字符串表达的数字，补位 0 不应该打印出来。</li><li>数字全排列：把数字的每一位都从 0 到 9 排序一遍。</li></ol></li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintToMaxOfNDigits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        number = [<span class="string">'0'</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">            number[<span class="number">0</span>] = str(i) </span><br><span class="line">            self.PrintToMaxOfNDigitsRecursively(number, n, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintToMaxOfNDigitsRecursively</span><span class="params">(self, number, length, index)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == length - <span class="number">1</span>:</span><br><span class="line">            self.PrintNumber(number, length)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">            number[index+<span class="number">1</span>] = str(i)</span><br><span class="line">            self.PrintToMaxOfNDigitsRecursively(number, length, index+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintNumber</span><span class="params">(self, number, length)</span>:</span></span><br><span class="line">        <span class="comment"># print(number)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">if</span> number[i] != <span class="string">'0'</span>:</span><br><span class="line">                print(<span class="string">''</span>.join(number[i:]))</span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure></div></div><p>补充：实现在字符串表示的数字上加 1 ，并在越界是返回</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Increment</span><span class="params">(number)</span>:</span></span><br><span class="line">    isOverflow = <span class="literal">False</span></span><br><span class="line">    nTakeOver = <span class="number">0</span></span><br><span class="line">    nLength = len(number)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nLength<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        nSum = int(number[i]) - int(<span class="string">'0'</span>) + nTakeOver</span><br><span class="line">        <span class="keyword">if</span> i == nLength - <span class="number">1</span>:  <span class="comment"># 个位+1</span></span><br><span class="line">            nSum += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nSum &gt;= <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                isOverflow = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nSum -= <span class="number">10</span></span><br><span class="line">                nTakeOver = <span class="number">1</span></span><br><span class="line">                number[i] = str(int(<span class="string">'0'</span>) + nSum)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            number[i] = str(int(<span class="string">'0'</span>) + nSum)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> isOverflow</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-18-1-：删除链表的节点"><a href="#面试题-18-1-：删除链表的节点" class="headerlink" title="面试题 18.1 ：删除链表的节点"></a>面试题 18.1 ：删除链表的节点</h5><p>给定单向链表的头指针和一个节点指针，在$O(1)$时间内删除该节点。</p><ol><li>从链表的头节点开始，顺序遍历查找要删除的节点，并删除。时间复杂度$O(n)$。</li><li>找到要删除节点的下一个节点，并用下一个节点的内容复制到要删除节点上，再删除下一个节点。<br>特殊情况：要删除的节点位与链表的尾部——采用顺序遍历，并删除的方法。链表中只有一个节点，删除链表的头节点（也是尾节点）—— 删除节点后需将链表的头设为None<br>时间复杂度为$O(1)$<br>以上基于一种假设：要删除的节点的确在链表中，判断节点是否在链表中需要$O(n)$时间复杂度。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        三个循环的顺序很重要，若 node.next == None 先判断，那个删除含有多个节点的链表的头节点时将出错，最后记得返回链表的头节点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> node.next != <span class="literal">None</span>:</span><br><span class="line">            next_node = node.next</span><br><span class="line">            node.val = next_node.val</span><br><span class="line">            node.next = next_node.next</span><br><span class="line">        <span class="keyword">elif</span> head == node:</span><br><span class="line">            head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 节点为链表的尾节点</span></span><br><span class="line">            pre_node = head</span><br><span class="line">            <span class="keyword">while</span> pre_node.next != node:</span><br><span class="line">                pre_node = pre_node.next</span><br><span class="line">            pre_node.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-18-2：-删除链表中重复的节点"><a href="#面试题-18-2：-删除链表中重复的节点" class="headerlink" title="面试题 18.2： 删除链表中重复的节点"></a>面试题 18.2： 删除链表中重复的节点</h5><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。</p><ol><li>从头遍历整个链表，删除重复节点。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        head = ListNode(<span class="number">-1</span>)</span><br><span class="line">        head.next = pHead</span><br><span class="line">        pre_node = head</span><br><span class="line">        <span class="keyword">while</span> pHead <span class="keyword">and</span> pHead.next:</span><br><span class="line">            <span class="keyword">if</span> pHead.val == pHead.next.val:</span><br><span class="line">                val = pHead.val</span><br><span class="line">                <span class="keyword">while</span> pHead <span class="keyword">and</span> pHead.val == val:</span><br><span class="line">                    pHead = pHead.next</span><br><span class="line">                pre_node.next = pHead</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre_node = pHead</span><br><span class="line">                pHead = pHead.next</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure></div></div><ol><li>将链表元素保存在列表中，并删除重复元素后再组成新链表。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication2</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> pHead != <span class="literal">None</span>:</span><br><span class="line">            res.append(pHead.val)</span><br><span class="line">            pHead = pHead.next</span><br><span class="line">        res=list(filter(<span class="keyword">lambda</span> c:res.count(c)==<span class="number">1</span>,res))</span><br><span class="line">        </span><br><span class="line">        newList=ListNode(<span class="number">0</span>)</span><br><span class="line">        pre=newList</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">            node=ListNode(i)</span><br><span class="line">            pre.next=node</span><br><span class="line">            pre=pre.next</span><br><span class="line">        <span class="keyword">return</span> newList.next</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-19：正则表达式匹配"><a href="#面试题-19：正则表达式匹配" class="headerlink" title="面试题 19：正则表达式匹配"></a>面试题 19：正则表达式匹配</h5><p>匹配包括 “.” 和 “ <em> ”的正则表达式，模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 </p><p>当模式中的字符为 “ <em> ”时，存在多种匹配方式 a. 模式上向后移动两个字符，字符串不动（” </em> “前的字符与字符串字符不匹配 / ” <em> “前的字符前的个数可为0个）；b. 字符串向后移动一个字符，模式向后移动两个字符（” </em> “前的字符与字符串字符匹配，向后继续）；  c. 字符串向后移动一个字符，模式不动（” * “前的字符可以匹配任意多个字符）。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s, pattern都是字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, s, pattern)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.matchCore(s, pattern)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matchCore</span><span class="params">(self, list_s, list_pat)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list_s  <span class="keyword">and</span> <span class="keyword">not</span> list_pat:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> list_s <span class="keyword">and</span> <span class="keyword">not</span> list_pat:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(list_pat) &gt; <span class="number">1</span> <span class="keyword">and</span> list_pat[<span class="number">1</span>]== <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">if</span> list_s <span class="keyword">and</span> (list_s[<span class="number">0</span>] == list_pat[<span class="number">0</span>] <span class="keyword">or</span> list_pat[<span class="number">0</span>] == <span class="string">'.'</span>):</span><br><span class="line">                <span class="keyword">return</span> self.matchCore(list_s[<span class="number">1</span>:], list_pat[<span class="number">2</span>:]) <span class="keyword">or</span> self.matchCore(list_s[<span class="number">1</span>:], list_pat) <span class="keyword">or</span> self.matchCore(list_s, list_pat[<span class="number">2</span>:])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.matchCore(list_s, list_pat[<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">if</span> list_s <span class="keyword">and</span> (list_s[<span class="number">0</span>] == list_pat[<span class="number">0</span>] <span class="keyword">or</span> list_pat[<span class="number">0</span>] == <span class="string">'.'</span>):</span><br><span class="line">            <span class="keyword">return</span> self.matchCore(list_s[<span class="number">1</span>:], list_pat[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-20：-表示数值的字符串"><a href="#面试题-20：-表示数值的字符串" class="headerlink" title="面试题 20： 表示数值的字符串"></a>面试题 20： 表示数值的字符串</h5><p>判断字符串是否表示数值（包括整数和小数）。</p><p>表示数值的字符串遵循模式 $ A[.[B]][e|EC]$ 或者 $.B[e|EC]$  其中 A 为整数部分，B 为小数部分，C 为指数部分。A 部分不是必需的，但如果A部分不存在，即整数部分不存在，那么小数部分不能为空。A 和 C都可以以 ‘+’ 、‘-’ 或 ‘0~9’ 开头，B 只能以 ‘0~9’ 。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        s = s + <span class="string">'\0'</span></span><br><span class="line">        numeric, index = self.scanInteger(s, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> s[index] == <span class="string">'.'</span>:</span><br><span class="line">            index += <span class="number">1</span> </span><br><span class="line">            numeric, index = self.scanUnsignedInteger(s, index) <span class="keyword">or</span> numeric</span><br><span class="line">        <span class="keyword">if</span> s[index] == <span class="string">'e'</span> <span class="keyword">or</span> s[index] == <span class="string">'E'</span>:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            numeric_, index = self.scanInteger(s, index)</span><br><span class="line">            numeric = numeric <span class="keyword">and</span> numeric_</span><br><span class="line">        <span class="keyword">return</span> numeric <span class="keyword">and</span> s[index] == <span class="string">'\0'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scanInteger</span><span class="params">(self, s, index)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s[index] == <span class="string">'+'</span> <span class="keyword">or</span> s[index] == <span class="string">'-'</span>:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.scanUnsignedInteger(s, index)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scanUnsignedInteger</span><span class="params">(self, s, index)</span>:</span></span><br><span class="line">        before = index</span><br><span class="line">        number = [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>]</span><br><span class="line">        <span class="keyword">while</span> s[index]!=<span class="string">'\0'</span> <span class="keyword">and</span> s[index] <span class="keyword">in</span> number:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> index &gt; before, index</span><br></pre></td></tr></table></figure></div></div><p>其他方法：</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> len(s)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        alist=[i.lower() <span class="keyword">for</span> i <span class="keyword">in</span> s]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'e'</span> <span class="keyword">in</span> alist:</span><br><span class="line">            index=alist.index(<span class="string">'e'</span>)</span><br><span class="line">            front=alist[:index]</span><br><span class="line">            behind=alist[index+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">in</span> behind <span class="keyword">or</span> len(behind)==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            isfront=self.isDigit(front)</span><br><span class="line">            isbehind=self.isDigit(behind)</span><br><span class="line">            <span class="keyword">return</span> isfront <span class="keyword">and</span> isbehind</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isDigit(alist)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isDigit</span><span class="params">(self,alist)</span>:</span></span><br><span class="line">        dotNum=<span class="number">0</span></span><br><span class="line">        allow_num = [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>,</span><br><span class="line">                     <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'.'</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(alist)):</span><br><span class="line">            <span class="keyword">if</span> alist[i] <span class="keyword">not</span> <span class="keyword">in</span> allow_num:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> alist[i]==<span class="string">'.'</span>:</span><br><span class="line">                dotNum += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> alist[i] <span class="keyword">in</span> <span class="string">'+-'</span> <span class="keyword">and</span> i!=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> dotNum&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-21：调整数组顺序使奇数位于偶数前面"><a href="#面试题-21：调整数组顺序使奇数位于偶数前面" class="headerlink" title="面试题 21：调整数组顺序使奇数位于偶数前面"></a>面试题 21：调整数组顺序使奇数位于偶数前面</h5><p>输入一个整数数组，调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 （保持稳定性）</p><ol><li>不考虑时间复杂度：从头扫描数组，遇到偶数时，拿出数字，并将位与这个数字之后的所有数字前移一位，在数组末尾放入此数。时间复杂度 $O(n^{2})$。</li><li>利用指针，但无法维持稳定性：扫描整个数组，若发现偶数出现在奇数前面，交换顺序。两个指针 $P_{1}$ （指向数组第一个数字）和 $P_{2}$ （指向数组最后一个数字），当 $P_{2}$ 指向奇数，且 $P_{1}$ 指向奇数时，$P_{1}$ 向后移动，直到 $P_{1}$ 指向偶数，交换两个指针所指的数字；之后 $P_{1}$ 一直向后移动直到碰到下一个偶数，$P_{2}$ 一直向前移动，直到碰到下一个奇数，当 $P_{2}$ 所指的位置在$P_{1}$ 前面时，表示已经将所有的奇数放在偶数前面了。时间复杂度 $O(n)$，空间复杂度 $O(1)$ 。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array <span class="keyword">or</span> len(array)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array</span><br><span class="line">        p1 = <span class="number">0</span></span><br><span class="line">        p2 = len(array) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; p2:</span><br><span class="line">            <span class="keyword">while</span> p1 &lt; p2 <span class="keyword">and</span> array[p1] % <span class="number">2</span>:</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> p1 &lt; p2 <span class="keyword">and</span> <span class="keyword">not</span> array[p2] % <span class="number">2</span>:</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p1 &lt; p2:</span><br><span class="line">                temp = array[p1]</span><br><span class="line">                array[p1] = array[p2]</span><br><span class="line">                array[p2] = temp</span><br><span class="line">        <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure></div></div><ol><li>不考虑空间复杂度：分配两个数组，一个用来存放奇数，另一个存放偶数，扫描数组，若数字为奇数或偶数放入不同的数组中，最后合并数组。时间复杂度 $O(n)$， 空间复杂度 $O(n)$。 </li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array <span class="keyword">or</span> len(array)==<span class="number">1</span>: </span><br><span class="line">            <span class="keyword">return</span> array</span><br><span class="line">        odd = []</span><br><span class="line">        even = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                odd.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                even.append(i)</span><br><span class="line">        <span class="keyword">return</span> odd + even</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-22：链表中倒数第-k-个节点"><a href="#面试题-22：链表中倒数第-k-个节点" class="headerlink" title="面试题 22：链表中倒数第 $k$ 个节点"></a>面试题 22：链表中倒数第 $k$ 个节点</h5><p>输入一个链表，输出该链表中倒数第 $k$ 个节点。 从 1 开始计数，即链表的尾节点是倒数第 1 个节点。</p><ol><li>两遍链表遍历法：第一遍遍历链表获取链表的长度 $n$，通过 $n-k+1$ 计算出倒数第 $k$ 个节点的位置，第二次遍历找到倒数第 $k$ 个节点。</li><li>一遍链表遍历法（利用两个指针）：两个指针 $P_{1}$ 和 $P_{2}$，开始时 $P_{1}$ 先向前遍历，$P_{1}$ 向前从头节点开始向前走 $k-1$ 步，走到第 $k$ 个节点时， $P_{2}$ 开始向前遍历，两个指针同时向前遍历，等到  $P_{1}$ 走到链表尾部时， $P_{2}$ 所处的位置即为链表中倒数第 $k$ 个节点。<br>特殊情况： （1）输入头节点为空；（2）输入参数 $k$ 为 0【链表的尾节点是倒数第 1 个节点】；（3）输入以 $head$ 为头节点的链表的节点总数小于 $k$。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> head== <span class="literal">None</span> <span class="keyword">or</span> k == <span class="number">0</span>: <span class="comment"># 特殊情况（1）和（2）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        p1 = head</span><br><span class="line">        p2 = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> p1.next != <span class="literal">None</span>:  <span class="comment"># 特殊情况（3）</span></span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        p2 = head</span><br><span class="line">        <span class="keyword">while</span> p1.next != <span class="literal">None</span>:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        <span class="keyword">return</span> p2</span><br></pre></td></tr></table></figure></div></div><p>相关题目：<br>求链表的中间节点（若链表中节点的总数为奇数，返回中间节点；若链表中的节点总数为偶数，则返回中间节点中的任意一个）：快慢指针（快指针一次走两步，慢指针一次走一步）。</p><h5 id="面试题-23：链表中环的入口节点"><a href="#面试题-23：链表中环的入口节点" class="headerlink" title="面试题 23：链表中环的入口节点"></a>面试题 23：链表中环的入口节点</h5><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 </p><ol><li>哈希表：遍历链表，若节点不在哈希表中，放入哈希表；若节点在哈希表中，则第一个已经存在于哈希表中的节点即为入环节点。若链表走到空，则链表无环。时间复杂度 $O(n)$， 空间复杂度 $O(n)$。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> pHead != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> pHead <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="keyword">return</span> pHead</span><br><span class="line">            hashmap[pHead] = <span class="number">1</span></span><br><span class="line">            pHead = pHead.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div></div><ol><li>快慢指针：快指针一次走两步，慢指针一次走一步，若快指针走到空，则表明链表无环，若快慢指针相遇，则链表有环；快慢指针相遇后，慢指针保持原地，快指针返回链表头节点，此时快指针变为一次走一步，当两个指针再次相遇时，相遇节点为入环节点。（两指针相遇后，慢指针所处的位置刚好是从头节点开始的第 $n$ 个节点，其中 $n$ 是链表环中的节点个数，此时两个指针同时向前移动，快指针指向环入口时，慢指针已经绕环一圈了。）时间复杂度 $O(n)$，空间复杂度 $o(1)$。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span> <span class="keyword">or</span> pHead.next == <span class="literal">None</span>: <span class="comment"># 头节点为空，或链表中只有一个节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pFast = pHead</span><br><span class="line">        pSlow = pHead</span><br><span class="line">        <span class="keyword">while</span> pFast != <span class="literal">None</span> <span class="keyword">and</span> pFast.next != <span class="literal">None</span>:</span><br><span class="line">            pFast = pFast.next.next</span><br><span class="line">            pSlow = pSlow.next</span><br><span class="line">            <span class="keyword">if</span> pFast == pSlow:</span><br><span class="line">                pFast = pHead</span><br><span class="line">                <span class="keyword">while</span> pFast != pSlow:</span><br><span class="line">                    pSlow = pSlow.next</span><br><span class="line">                    pFast = pFast.next</span><br><span class="line">                <span class="keyword">return</span> pFast</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-24：反转链表"><a href="#面试题-24：反转链表" class="headerlink" title="面试题 24：反转链表"></a>面试题 24：反转链表</h5><p>输入一个链表，反转链表后，输出新链表的表头。<br>注意：反转后链表出现断裂（需要事前保存当前节点的前一个节点和后一个节点），并注意头节点的反转，即反转后原头节点为新链表的尾节点。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pHead.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        pre_node = <span class="literal">None</span></span><br><span class="line">        beh_node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead != <span class="literal">None</span>:</span><br><span class="line">            beh_node = pHead.next</span><br><span class="line">            pHead.next = pre_node</span><br><span class="line">            pre_node = pHead</span><br><span class="line">            pHead = beh_node</span><br><span class="line">        <span class="keyword">return</span> pre_node</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-25：合并两个排序的链表"><a href="#面试题-25：合并两个排序的链表" class="headerlink" title="面试题 25：合并两个排序的链表"></a>面试题 25：合并两个排序的链表</h5><p>输入两个递增排序的链表，合并两个链表，并使新链表中的节点仍然是递增排序的。注意：考虑输入的指针为空指针的情况。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br><span class="line">        <span class="keyword">if</span> pHead2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        merge = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pHead1.val &lt; pHead2.val:</span><br><span class="line">            merge = pHead1</span><br><span class="line">            merge.next = self.Merge(pHead1.next, pHead2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            merge = pHead2</span><br><span class="line">            merge.next = self.Merge(pHead1, pHead2.next)</span><br><span class="line">        <span class="keyword">return</span> merge</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-26：树的子结构"><a href="#面试题-26：树的子结构" class="headerlink" title="面试题 26：树的子结构"></a>面试题 26：树的子结构</h5><p>输入两棵二叉树A，B，判断B是不是A的子结构。（PS：约定空树不是任意一个树的子结构）<br>步骤：</p><ol><li>在树 A 中找到和树 B 的根节点的值一样的节点 R。</li><li>判断树 A 中以 R 为根节点的子树是不是包含和树 B 一样的结构。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> pRoot1 <span class="keyword">and</span> pRoot2:</span><br><span class="line">            <span class="keyword">if</span> pRoot1.val == pRoot2.val:</span><br><span class="line">                res = self.SubTreeCore(pRoot1, pRoot2)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">                res = self.HasSubtree(pRoot1.left, pRoot2)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">                res = self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SubTreeCore</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pRoot2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> pRoot1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> pRoot1.val != pRoot2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.SubTreeCore(pRoot1.left, pRoot2.left) <span class="keyword">and</span> self.SubTreeCore(pRoot1.right, pRoot2.right)</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-27：-二叉树的镜像"><a href="#面试题-27：-二叉树的镜像" class="headerlink" title="面试题 27： 二叉树的镜像"></a>面试题 27： 二叉树的镜像</h5><p>先前序遍历树的每个节点，若遍历到的节点有子节点，则交换其两个子节点。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        temp = root.right</span><br><span class="line">        root.right = root.left</span><br><span class="line">        root.left = temp</span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">        self.Mirror(root.left)</span><br><span class="line">        <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">        self.Mirror(root.right)</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-28：对称的二叉树"><a href="#面试题-28：对称的二叉树" class="headerlink" title="面试题 28：对称的二叉树"></a>面试题 28：对称的二叉树</h5><p>判断一棵树是不是对称的。若二叉树和镜像完全一样，则是对称的。<br>针对前序遍历定义一种对称的遍历算法：先遍历父节点，再遍历它的右子节点，最后遍历左子节点。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.isSymmetricalCore(pRoot, pRoot)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetricalCore</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> pRoot1 == <span class="literal">None</span> <span class="keyword">and</span> pRoot2 == <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> pRoot1 == <span class="literal">None</span> <span class="keyword">or</span> pRoot2 == <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> pRoot1.val != pRoot2.val:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> self.isSymmetricalCore(pRoot1.left, pRoot2.right) <span class="keyword">and</span> self.isSymmetricalCore(pRoot1.right, pRoot2.left)</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-29：-顺时针打印矩阵"><a href="#面试题-29：-顺时针打印矩阵" class="headerlink" title="面试题 29： 顺时针打印矩阵"></a>面试题 29： 顺时针打印矩阵</h5><p>按照从外向里以顺时针的顺序依次打印出每一个数字。</p><ol><li>对于一个 rows <em> cols​ 的矩阵：循环继续的条件为 ​clos &gt; startX </em> 2 且 rows &gt; startY * 2​。</li><li>打印步骤：<ol><li>第一步：必不可少。</li><li>第二步：终止行号 &gt; 起始行号</li><li>第三步：终止行号 &gt; 起始行号 且 终止列号 &gt; 起始列号</li><li>第四步：终止行号 - 1 &gt; 起始行号 且 终止列号 &gt; 起始列号</li></ol></li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> matrix == <span class="literal">None</span> <span class="keyword">or</span> len(matrix) &lt;= <span class="number">0</span> <span class="keyword">or</span> len(matrix[<span class="number">0</span>]) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        rows = len(matrix)</span><br><span class="line">        cols = len(matrix[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> (cols &gt; start * <span class="number">2</span> <span class="keyword">and</span> rows &gt; start * <span class="number">2</span>):</span><br><span class="line">        self.printMatrixCore(matrix, rows, cols, start, res)</span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrixCore</span><span class="params">(slef, matrix, rows, cols, start, res)</span>:</span></span><br><span class="line">    endY = rows - <span class="number">1</span> - start</span><br><span class="line">    endX = cols - <span class="number">1</span> - start</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start, endX+<span class="number">1</span>):</span><br><span class="line">    res.append(matrix[start][i])</span><br><span class="line">    <span class="keyword">if</span> endY &gt; start:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start+<span class="number">1</span>, endY+<span class="number">1</span>):</span><br><span class="line">    res.append(matrix[i][endX])</span><br><span class="line">    <span class="keyword">if</span> endY &gt; start <span class="keyword">and</span> endX &gt; start:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(endX<span class="number">-1</span>, start<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    res.append(matrix[endY][i])</span><br><span class="line">    <span class="keyword">if</span> endX &gt; start <span class="keyword">and</span> endY<span class="number">-1</span> &gt; start:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(endY<span class="number">-1</span>, start, <span class="number">-1</span>):</span><br><span class="line">    res.append(matrix[i][start])</span><br></pre></td></tr></table></figure></div></div><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> matrix == []:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        l, t, r, b = <span class="number">0</span>, <span class="number">0</span>, len(matrix[<span class="number">0</span>])<span class="number">-1</span>, len(matrix)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[t][i])</span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t &gt; b: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(t, b+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][r])</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> r &lt; l: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(r, l<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[b][i])</span><br><span class="line">            b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> b &lt; t: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, t<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[i][l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div><p>还有另外一种及其简单的做法：旋转矩阵</p><h5 id="面试题-30：包含min函数的栈"><a href="#面试题-30：包含min函数的栈" class="headerlink" title="面试题 30：包含min函数的栈"></a>面试题 30：包含min函数的栈</h5><p>定义栈的数据结构，实现一个能够得到栈中所含最小元素的 min 函数（时间复杂度应为$O(1)$）。</p><ol><li>若每次压入新元素时，将栈里的所有元素排序，调整让最小的元素位于栈顶。不能保证最后压入栈的元素最先出栈，数据结构不是栈了。X</li><li>在栈中添加一个成员变量存放最小元素，当最小元素弹出后，就不知道下一个最小元素在哪儿了。因此，必须将次小元素保存。X</li><li>利用辅助数组，每次将最小元素放入辅助栈。√</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minstack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">        <span class="keyword">if</span> self.minstack == [] <span class="keyword">or</span> node &lt; self.min():</span><br><span class="line">            self.minstack.append(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.minstack.append(self.min())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.stack == [] <span class="keyword">or</span> self.minstack == []:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.minstack.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.minstack[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-31：栈的压入，弹出序列"><a href="#面试题-31：栈的压入，弹出序列" class="headerlink" title="面试题 31：栈的压入，弹出序列"></a>面试题 31：栈的压入，弹出序列</h5><p>输入两个整数序列，第一个序列表示栈的压入顺序，判断第二个序列是否为该栈的弹出顺序。<br>解决方式1：</p><ol><li>若下一个需要弹出的元素刚好是栈顶元素，则直接弹出。</li><li>若下一个需要弹出的元素不是栈顶元素，则将压栈序列中还没有压入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。</li><li>若所有数字都压入辅助栈仍没有找到下一个需弹出的数字，则序列不是一个弹出序列。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pushV == <span class="literal">None</span> <span class="keyword">or</span> popV == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> popV:</span><br><span class="line">            <span class="keyword">if</span> stack != [] <span class="keyword">and</span> stack[<span class="number">-1</span>] == i:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">elif</span> stack == [] <span class="keyword">or</span> stack[<span class="number">-1</span>] != i:</span><br><span class="line">                <span class="keyword">if</span> index &gt; len(pushV) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">while</span> index &lt; len(pushV) - <span class="number">1</span> <span class="keyword">and</span> pushV[index] != i:</span><br><span class="line">                        stack.append(pushV[index])</span><br><span class="line">                        index += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> pushV[index] == i:</span><br><span class="line">                        index += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></div></div><p>解决方法2：</p><ol><li>将数据从pushV中压入stack的过程中，若压入数据与popV出栈的栈顶元素一样，就从pushv和popv中同时弹出，不压入stack。</li><li>等到pushV中元素全弹出来之后，判断stack中出栈元素和popV中出栈元素是否一致，当popV中元素全部弹出，说明是弹出序列。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> popV:</span><br><span class="line">            <span class="keyword">if</span> pushV <span class="keyword">and</span> pushV[<span class="number">0</span>] == popV[<span class="number">0</span>]:</span><br><span class="line">                pushV.pop(<span class="number">0</span>)</span><br><span class="line">                popV.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] == popV[<span class="number">0</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">                popV.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span> pushV:</span><br><span class="line">                stack.append(pushV.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-32-1-：不分行从上到下打印二叉树"><a href="#面试题-32-1-：不分行从上到下打印二叉树" class="headerlink" title="面试题 32.1 ：不分行从上到下打印二叉树"></a>面试题 32.1 ：不分行从上到下打印二叉树</h5><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。【广度优先遍历】<br>每次打印一个节点时，若节点有子节点，则将该节点的子节点放入队列的末尾，下面从队列的头部取出节点，重复前面的操作，直到队列中所有节点都打印完成。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        res_val = []</span><br><span class="line">        res.append(root)</span><br><span class="line">        <span class="keyword">while</span> res:</span><br><span class="line">            root = res.pop(<span class="number">0</span>)</span><br><span class="line">            res_val.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">                res.append(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">                res.append(root.right)</span><br><span class="line">        <span class="keyword">return</span> res_val</span><br></pre></td></tr></table></figure></div></div><font color="red">注意：广度优先遍历有向图或树均需用到队列。</font><h5 id="面试题-32-2-：分行从上到下打印二叉树"><a href="#面试题-32-2-：分行从上到下打印二叉树" class="headerlink" title="面试题 32.2 ：分行从上到下打印二叉树"></a>面试题 32.2 ：分行从上到下打印二叉树</h5><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。另需两个变量保存当前层节点和下一层节点。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pRoot == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        res_val = []</span><br><span class="line">        res.append(pRoot)</span><br><span class="line">        <span class="keyword">while</span> res:</span><br><span class="line">            curstack, nextstack = [], []</span><br><span class="line">            <span class="keyword">for</span> re <span class="keyword">in</span> res:</span><br><span class="line">                curstack.append(re.val)</span><br><span class="line">                <span class="keyword">if</span> re.left  != <span class="literal">None</span>:</span><br><span class="line">                    nextstack.append(re.left)</span><br><span class="line">                <span class="keyword">if</span> re.right != <span class="literal">None</span>:</span><br><span class="line">                    nextstack.append(re.right)</span><br><span class="line">            res_val.append(curstack)</span><br><span class="line">            res = nextstack</span><br><span class="line">        <span class="keyword">return</span> res_val</span><br></pre></td></tr></table></figure></div></div></p><h5 id="面试题-32-3-：之字形打印二叉树"><a href="#面试题-32-3-：之字形打印二叉树" class="headerlink" title="面试题 32.3 ：之字形打印二叉树"></a>面试题 32.3 ：之字形打印二叉树</h5><p>第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<br>需要两个栈：</p><ol><li>若当前打印的是奇数层，则先保存左子节点再保存右子节点到第一个栈里。</li><li>若当前打印的是偶数层，则先保存右子节点再保存左子节点到第二个栈里。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pRoot == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        res_val = []</span><br><span class="line">        res.append(pRoot)</span><br><span class="line">        <span class="keyword">while</span> res:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            curstack, nextstack = [], []</span><br><span class="line">            <span class="keyword">if</span> index % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">while</span> res:</span><br><span class="line">                    root = res.pop()</span><br><span class="line">                    curstack.append(root.val)</span><br><span class="line">                    <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">                        nextstack.append(root.left)</span><br><span class="line">                    <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">                        nextstack.append(root.right)</span><br><span class="line">            <span class="keyword">elif</span> index % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">while</span> res:</span><br><span class="line">                    root  = res.pop()</span><br><span class="line">                    curstack.append(root.val)</span><br><span class="line">                    <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">                        nextstack.append(root.right)</span><br><span class="line">                    <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">                        nextstack.append(root.left)</span><br><span class="line">            res_val.append(curstack)</span><br><span class="line">            res = nextstack</span><br><span class="line">        <span class="keyword">return</span> res_val</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-33：二叉搜索树的后序遍历序列"><a href="#面试题-33：二叉搜索树的后序遍历序列" class="headerlink" title="面试题 33：二叉搜索树的后序遍历序列"></a>面试题 33：二叉搜索树的后序遍历序列</h5><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。【二叉搜索树：左子树节点的值均小于根节点的值，右子树节点的值均大于根节点的值。】<br>后序遍历，最后一个数字为树的根节点的值，数组中前面数字中小于此值的为左子树节点的值，大于此值的为右子树节点的值。递归。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> sequence == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        root = sequence.pop()</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sequence:</span><br><span class="line">            <span class="keyword">if</span> i &gt; root: <span class="keyword">break</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sequence[index:]:</span><br><span class="line">            <span class="keyword">if</span> i &lt; root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; <span class="number">0</span>:</span><br><span class="line">            left = self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line">        right = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; len(sequence)<span class="number">-1</span>:</span><br><span class="line">            right = self.VerifySquenceOfBST(sequence[index:])</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-34：二叉树中和为某一值的路径"><a href="#面试题-34：二叉树中和为某一值的路径" class="headerlink" title="面试题 34：二叉树中和为某一值的路径"></a>面试题 34：二叉树中和为某一值的路径</h5><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br>过程：</p><ol><li>用前序遍历方式访问到某节点，把该节点加入路径，并累加该节点的值；</li><li>若该节点为叶子节点，且路径中节点的值刚好 == 输入整数，打印；</li><li>若该节点不是叶子节点，则继续访问它的子节点；</li><li>当前节点访问结束后，递归回到其父节点。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        self.recur(root, sum)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(self, root, tar)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.path.append(root.val)</span><br><span class="line">        tar -= root.val</span><br><span class="line">        lead_node = (root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> tar == <span class="number">0</span> <span class="keyword">and</span> lead_node:</span><br><span class="line">            self.res.append(list(self.path))</span><br><span class="line">        self.recur(root.left, tar)</span><br><span class="line">        self.recur(root.right, tar)</span><br><span class="line">        self.path.pop()</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-35：复杂链表的复制"><a href="#面试题-35：复杂链表的复制" class="headerlink" title="面试题 35：复杂链表的复制"></a>面试题 35：复杂链表的复制</h5><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点或空），返回结果为复制后复杂链表的 head。<br>以空间换取时间的解法：准备大小为 $O(n)$ 的哈希表，时间复杂度$O(n)$实现</p><ol><li>复制原始链表上的每一个节点N创建N‘，将创建出来的节点用next指针链接起来，同时将&lt;N,N’&gt;的配对信息保存在哈希表中。</li><li>复制链表上的每个节点的random指针，利用哈希表可以在$O(1)$的时间找到random指针指向的节点。<br>不使用哈希表，额外空间复杂度$O(1)$，时间复杂度$O(n)$实现：</li><li>复制原始链表上的每一个节点N创建N‘，把N’节点放在N节点之后，将创建出来的节点用next指针链接起来。</li><li>复制链表上的每个节点的random指针，N‘节点的random指针指向N节点的random节点的next节点。</li><li>将长链表拆分成两个链表：把奇数位置的节点用next指针相连，成为原始链表，偶数位置的节点用next指针相连成为复制的链表。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        self.random = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.CloneNextNode(pHead)</span><br><span class="line">        self.CloneRandomNode(pHead)</span><br><span class="line">        <span class="keyword">return</span> self.ReconnectNode(pHead)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CloneNextNode</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        pNode = pHead</span><br><span class="line">        <span class="keyword">while</span> pNode != <span class="literal">None</span>:</span><br><span class="line">            pClone = RandomListNode(<span class="literal">None</span>)</span><br><span class="line">            pClone.label = pNode.label</span><br><span class="line">            pClone.next = pNode.next</span><br><span class="line">            pNode.next = pClone</span><br><span class="line">            pNode = pClone.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CloneRandomNode</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        pNode = pHead</span><br><span class="line">        <span class="keyword">while</span> pNode != <span class="literal">None</span>:</span><br><span class="line">            pClone = pNode.next</span><br><span class="line">            <span class="keyword">if</span> pNode.random != <span class="literal">None</span>:</span><br><span class="line">                pClone.random = pNode.random.next</span><br><span class="line">            pNode = pClone.next </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReconnectNode</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        pNode = pHead</span><br><span class="line">        pCloneNode = <span class="literal">None</span></span><br><span class="line">        pCloneHead = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pNode != <span class="literal">None</span>:</span><br><span class="line">            pCloneHead = pCloneNode = pNode.next</span><br><span class="line">            pNode.next = pCloneNode.next</span><br><span class="line">            pNode = pNode.next</span><br><span class="line">        <span class="keyword">while</span> pNode != <span class="literal">None</span>:</span><br><span class="line">            pCloneNode.next = pNode.next</span><br><span class="line">            pCloneNode = pCloneNode.next</span><br><span class="line">            pNode.next = pCloneNode.next</span><br><span class="line">            pNode = pNode.next</span><br><span class="line">        <span class="keyword">return</span> pCloneHead</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印复杂链表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Print_ComplicatedList</span><span class="params">(head)</span>:</span></span><br><span class="line">    next_node = head</span><br><span class="line">    <span class="keyword">while</span> next_node != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> next_node.random != <span class="literal">None</span>:</span><br><span class="line">            print(next_node.label,end=<span class="string">''</span>)</span><br><span class="line">            print(<span class="string">'('</span>,end=<span class="string">''</span>)</span><br><span class="line">            print(next_node.random.label, end=<span class="string">''</span>)</span><br><span class="line">            print(<span class="string">')'</span>,end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(next_node.label, end=<span class="string">''</span>)</span><br><span class="line">        next_node = next_node.next</span><br><span class="line">        <span class="keyword">if</span> next_node != <span class="literal">None</span>:</span><br><span class="line">            print( <span class="string">'——&gt;'</span>, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-36：二叉搜素树与双向链表（-）"><a href="#面试题-36：二叉搜素树与双向链表（-）" class="headerlink" title="面试题 36：二叉搜素树与双向链表（**）"></a>面试题 36：二叉搜素树与双向链表（**）</h5><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br>原先指向左子节点的指针调整为链表中指向前一个节点的指针，原先指向右子节点的指针调整为链表中指向后一个节点的指针。中序遍历树中的每一个节点（中序遍历将按照从小到大的顺序遍历二叉搜索树），遍历根节点时，根节点指向的前一个结点是根节点左子树的最大值，指向的后一个节点是根节点右子树的最小值。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pLastNodeInList = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pRootOfTree ==  <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.Core(pRootOfTree, self.pLastNodeInList)</span><br><span class="line">        pHead = self.pLastNodeInList</span><br><span class="line">        <span class="keyword">while</span> pHead != <span class="literal">None</span> <span class="keyword">and</span> pHead.left != <span class="literal">None</span>:</span><br><span class="line">            pHead = pHead.left</span><br><span class="line">        <span class="keyword">return</span> pHead</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Core</span><span class="params">(self, root, pLastNodeInList)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pCurrent = root</span><br><span class="line">        <span class="keyword">if</span> pCurrent.left != <span class="literal">None</span>:</span><br><span class="line">            self.Core(pCurrent.left, self.pLastNodeInList)</span><br><span class="line">        pCurrent.left = self.pLastNodeInList</span><br><span class="line">        <span class="keyword">if</span> self.pLastNodeInList != <span class="literal">None</span>:</span><br><span class="line">            self.pLastNodeInList.right = pCurrent</span><br><span class="line">        self.pLastNodeInList = pCurrent</span><br><span class="line">        <span class="keyword">if</span> pCurrent != <span class="literal">None</span>:</span><br><span class="line">            self.Core(pCurrent.right, self.pLastNodeInList)</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-37：序列化二叉树"><a href="#面试题-37：序列化二叉树" class="headerlink" title="面试题 37：序列化二叉树"></a>面试题 37：序列化二叉树</h5><p>序列化和反序列化二叉树<br>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。<br>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果，重构二叉树。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    flag = <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'#!'</span></span><br><span class="line">        <span class="keyword">return</span> str(root.val) + <span class="string">'!'</span> + self.Serialize(root.left) + self.Serialize(root.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.flag += <span class="number">1</span></span><br><span class="line">        lis = s.split(<span class="string">'!'</span>)</span><br><span class="line">        <span class="keyword">if</span> self.flag &gt;= len(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> lis[self.flag] != <span class="string">'#'</span>:</span><br><span class="line">            root = TreeNode(int(lis[self.flag]))</span><br><span class="line">            root.left = self.Deserialize(s)</span><br><span class="line">            root.right = self.Deserialize(s)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-38：字符串的排序（-）"><a href="#面试题-38：字符串的排序（-）" class="headerlink" title="面试题 38：字符串的排序（*）"></a>面试题 38：字符串的排序（*）</h5><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc，acb，bac，bca，cab和cba。 </p><ol><li>把字符串分成两部分：一部分是字符串的第一个字符，另一部分是第一个字符以后的所有字符</li><li>拿第一个字符和它后面的字符逐个交换</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> ss == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        charList = list(ss)</span><br><span class="line">        charList.sort()</span><br><span class="line">        <span class="keyword">return</span> self.Permuta(charList)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permuta</span><span class="params">(self, charList)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(charList) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> charList</span><br><span class="line">        pStr = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(charList)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> charList[i] == charList[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            temp = self.Permuta(charList[:i]+charList[i+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> temp:</span><br><span class="line">                pStr.append(charList[i]+j)</span><br><span class="line">        <span class="keyword">return</span> pStr</span><br></pre></td></tr></table></figure></div></div><p>扩展题：<br>字符串的所有组合：交换字符串中的两个字符时，得到两种不同的排序，但却是同一种组合。例如输入三个字符a，b，c它们的组合有a、b、c、ab、ac、bc、abc。<br>输入 n 个字符，这  n 个字符能构成长度为1， 2， 3，…，n的组合。求n个字符组成长度为m的组合时：1. 求n-1个字符中长度为m-1的组合（组合中包含第一个字符），2. 求n-1个字符中长度为m的组合（组合中不包含第一个字符）</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 代码功能不全，无法实现当字符串中含有重复字符的时候</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pStr = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Combination</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> ss == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        charList = list(ss)</span><br><span class="line">        charList.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(charList)+<span class="number">1</span>):</span><br><span class="line">            self.pStr.append(self.combin(charList, <span class="number">0</span>, i))</span><br><span class="line">        <span class="keyword">return</span> self.pStr</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combin</span><span class="params">(self, charList, begin, length)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span> <span class="keyword">or</span> len(charList) - begin &lt; length:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(charList, begin, length)</span><br><span class="line">        out = []</span><br><span class="line">        out.append(charList[begin])</span><br><span class="line">        print(out)</span><br><span class="line">        temp = self.combin(charList, begin+<span class="number">1</span>, length<span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">if</span> temp != <span class="literal">None</span>:</span><br><span class="line">            out.pop()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> temp:</span><br><span class="line">                out.append(charList[begin] + j)</span><br><span class="line">        temp2 = self.combin(charList, begin+<span class="number">1</span>, length)</span><br><span class="line">        <span class="keyword">if</span> temp2 != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> temp2:</span><br><span class="line">                out.append(j)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure></div></div><p>相关题目：</p><ol><li>输入一个含有8个数字的数组，判断有没有可能把这8个数字分别放在正方体的8个顶点上，使得正方体上三组相对的面上的4个顶点的和都相等。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补充代码</span></span><br></pre></td></tr></table></figure></div></div><ol><li>在$8<em>8$的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一对角线上。共有多少种符合条件的摆法。<br>扩展提：【N皇后问题】在N</em>N的国际象棋上摆放N个皇后。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补充代码</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-39：数组中出现次数超过一半的数字"><a href="#面试题-39：数组中出现次数超过一半的数字" class="headerlink" title="面试题 39：数组中出现次数超过一半的数字"></a>面试题 39：数组中出现次数超过一半的数字</h5><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组$\{1,2,3,2,2,2,5,4,2\}$。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br>解题方法：</p><ol><li>基于$Partition$函数的时间复杂度为$O(N)$：<br>数组特性：数组中有一个数字出现的次数超过了数组长度的一半，即将数组排序后，位于数组中间的数字一定就是出现次数超过数组长度一半的数字。此数字为统计学上的中位数，即长度为 $n$ 的数组中第 $n/2$ 大的数字。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补充代码</span></span><br></pre></td></tr></table></figure></div></div><ol><li>基于数组特点的时间复杂度为$O(N)$:<br>数组中一个数字出现的次数超过数组长度的一半，即它出现的次数比其他所有数字出现的次数的和还要多。因此可以在遍历数组的时候保存两个值：一是数组中的一个数字，另一个是次数。1. 若遍历到的下一个数字和之前保存的数字相同，次数 $+1$；2. 若不同，次数 $-1$，如果次数减为0，则保存遍历到的下一个数字，并将次数设为1。</li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode—LeetCode补充</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        num = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            count += <span class="number">1</span> <span class="keyword">if</span> i == num <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> count &lt;= <span class="number">0</span>:</span><br><span class="line">                num = i</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure></div></div><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.CheckInvalidArray(numbers):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        result = numbers[<span class="number">0</span>]</span><br><span class="line">        time = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers[<span class="number">0</span>:]:</span><br><span class="line">            <span class="keyword">if</span> time == <span class="number">0</span>:</span><br><span class="line">                result = i</span><br><span class="line">                time = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> result == i:</span><br><span class="line">                time += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                time -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.CheckMoreThanHalf(numbers, result):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CheckInvalidArray</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        isInputInvalid = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> numbers == <span class="literal">None</span> <span class="keyword">or</span> len(numbers) == <span class="number">0</span>:</span><br><span class="line">            isInputInvalid = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> isInputInvalid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CheckMoreThanHalf</span><span class="params">(self, numbers, result)</span>:</span></span><br><span class="line">        time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> i == result:</span><br><span class="line">                time += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> time * <span class="number">2</span> &lt;= len(numbers):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">print(Solution().MoreThanHalfNum_Solution(numbers))</span><br><span class="line">print(Solution().MoreThanHalfNum_Solution(<span class="literal">None</span>))</span><br><span class="line">print(Solution().MoreThanHalfNum_Solution([]))</span><br><span class="line">print(Solution().MoreThanHalfNum_Solution([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]))</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-40：最小的k个数"><a href="#面试题-40：最小的k个数" class="headerlink" title="面试题 40：最小的k个数"></a>面试题 40：最小的k个数</h5><p>输入 $n$ 个整数，找出其中最小的 $K$ 个数。例如输入 $4,5,1,6,2,7,3,8$ 这 $8$ 个数字，则最小的 $4$ 个数字是 $1,2,3,4$。<br>时间复杂度为 $O(N \log N)$ 的解法：把输入的 $n$ 个整数排序，排序后位与最前面的 $k$ 个数就是最小的 $k$ 个数。<br>时间复杂度为 $O(N)$ 的解法：可以修改输入数组时，【基于 $Partition$ 函数】基于数组的第 $k$ 个数字调整，，使得比第 $k$ 个数字小的所有数字都位于数组的左边。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补充代码</span></span><br></pre></td></tr></table></figure></div></div><p>&emsp;&emsp;时间复杂度 $O(N log k)$ 的解法：不可以修改输入数组时，特别适合处理海量数据，创建一个大小为 $k$ 的容器存储最小的 $k$ 个数字，读取输入的 $n$ 个数：【容器中不足 $k$ 个数】，直接将读入的数放入容器中；【容器中满 $k$ 个数】，获得容器中 $k$ 个数字的最大值，若读入的数字 &gt; 最大值，直接舍弃；若读入的数字 &lt; 最大值，用读入的数字替换容器中的最大值。<br>&emsp;&emsp;容器满了之后可能会执行的三个操作 【1】在 $k$ 个整数中找到最大数；【2】有可能在这个容器中删除最大值；【3】有可能要插入一个新的数字。可能用最大堆实现这个容器，在 $O(1)$ 时间内得到已有的 $k$ 个数字中的最大值，$O(\log k)$ 时间内完成删除和插入操作。也可以使用红黑树实现容器，$O(\log k)$ 时间内完成查找、删除和插入操作。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.val &gt; other.val</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(tinput) &lt; k <span class="keyword">or</span> k &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        heapq_num = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tinput:</span><br><span class="line">            <span class="keyword">if</span> len(heapq_num) &lt; k:</span><br><span class="line">                heapq.heappush(heapq_num, MyObject(i))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq_num_max = heapq_num[<span class="number">0</span>].val</span><br><span class="line">                <span class="keyword">if</span> i &lt; heapq_num_max:</span><br><span class="line">                    heapq.heapreplace(heapq_num, MyObject(i))</span><br><span class="line">        <span class="keyword">return</span> [i.val <span class="keyword">for</span> i <span class="keyword">in</span> heapq.nlargest(k, heapq_num)]</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-41：数据流中的中位数"><a href="#面试题-41：数据流中的中位数" class="headerlink" title="面试题 41：数据流中的中位数"></a>面试题 41：数据流中的中位数</h5><p>如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。使用 $Insert()$ 方法读取数据流，使用 $GetMedian()$ 方法获取当前读取数据的中位数。 </p><p>使用数据容器，保存从流中读取到的数据。数据容器的类型有：数组、排序的链表、二叉搜索树、平衡二叉搜素数、大根堆和小根堆</p><p>数组：如果数组没有排序，可以利用 $Partition$ 函数找到数据中的中位数【插入新数据和找到中位数的时间复杂度分别为 $O(1)和O(N)$】；如果在插入新数据时让数组保持排序，则【插入新数据和找到中位数的时间复杂度分别为 $O(N)和O(1)$】。</p><p>排序的链表：【插入新数据和找到中位数的时间复杂度分别为 $O(N)和O(1)$】，定义两个指针指向链表中间的节点。</p><p>二叉搜索树：在二叉树节点中添加一个表示子树节点数据的字段，【插入新数据和找到中位数的平均时间复杂度为 $O(\log N)$】，当最差情况时，二叉搜索树极度不平衡，时间复杂度仍为 $O(N)$。</p><p>$AVL$ 数—平衡二叉搜素树：修改 $AVL$ 的平衡因子为左、右子树节点数目之差，【插入新节点的时间复杂度为 $O(\log N)$，获得所有节点的中位数的时间复杂度为 $O(1)$】，没有现成的函数库，实现难度大。</p><p>大根堆和小根堆：用大根堆实现左边的数据容器，小根堆实现右边的数据容器，当数据量为奇数时，中位数是大根堆的最大值，若数据量为偶数时，中位数是大根堆的最大值和小根堆最小值的平均值，【插入新节点的时间复杂度为 $O(\log N)$，获得所有节点的中位数的时间复杂度为 $O(1)$】。要保证数据平均分配到两个堆中，因此两个堆中数据的数目只差不能超过1，可在数据总数目是偶数时把新数据插入小根堆，否则插入大根堆，同时还要保证大根堆中所有数据都小于小根堆的数据，当数据为偶数时，若要插入小根堆中数据比大根堆中的数据小时，先将数据插入大根堆，再将大根堆中的最大值弹出，插入小根堆，反之做法类似。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.val &gt; other.val</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.min_heap = []</span><br><span class="line">        self.max_heap = []</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.count % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> len(self.min_heap) &gt; <span class="number">0</span> <span class="keyword">and</span> self.min_heap[<span class="number">0</span>] &lt; num:</span><br><span class="line">                value = heapq.heapreplace(self.min_heap, num)</span><br><span class="line">                heapq.heappush(self.max_heap, MaxHeap(value))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(self.max_heap, MaxHeap(num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(self.max_heap) &gt; <span class="number">0</span> <span class="keyword">and</span> self.max_heap[<span class="number">0</span>].val &gt; num:</span><br><span class="line">                value = heapq.heapreplace(self.max_heap, MaxHeap(num)).val</span><br><span class="line">                heapq.heappush(self.min_heap, value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(self.min_heap, num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span><span class="params">(self, x = None)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.count % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.max_heap[<span class="number">0</span>].val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            middle = (self.max_heap[<span class="number">0</span>].val + self.min_heap[<span class="number">0</span>]) / <span class="number">2.0</span></span><br><span class="line">            <span class="keyword">return</span> middle</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-42：连续子数组的最大和"><a href="#面试题-42：连续子数组的最大和" class="headerlink" title="面试题 42：连续子数组的最大和"></a>面试题 42：连续子数组的最大和</h5><p>数组中包含正数和负数，求所有子数组的和的最大值。<br>时间复杂度为 $O(N)$ 的解法：</p><ol><li><p>举例分析数组的规律：<br>如果arr中没有正数，产生的最大累加和一定是数组中的最大值。 如果arr中有正数，从左到右遍历数组，用变量 $cur$ 记录每一步的累加和。当 $cur<0$ 时，此时令 $cur="0$" ，表示重新从下一个数开始累加。当>=0$ 时，每一次累加都可能是最大的累加和，所以用变量 $max$ 全程记录 $cur$ 出现的最大值即可。</0$></p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> array == <span class="literal">None</span> <span class="keyword">or</span> len(array) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cur = array[<span class="number">0</span>]</span><br><span class="line">        max_val = cur</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> cur &lt; <span class="number">0</span>:</span><br><span class="line">                cur = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur += i</span><br><span class="line">            <span class="keyword">if</span> cur &gt; max_val:</span><br><span class="line">                max_val = cur</span><br><span class="line">        <span class="keyword">return</span> max_val</span><br></pre></td></tr></table></figure></div></div></li><li><p>应用动态规划：<br>用函数 $dp[i]$ 表示以第 $i$ 个数字结尾的子数组的最大和，需要求出 $max[dp[i]$。递归公式：</p><script type="math/tex; mode=display">dp[i] = \begin{cases} nums[i], &i=0或者dp[i-1] \le 0\\ dp[i-1]+nums[i] , &i \not=0并且dp[i-1] \gt0\end{cases}</script></li></ol><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            nums[i] += max(<span class="number">0</span>, nums[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> max(nums)</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-43：1-n-整数中-1-出现的次数"><a href="#面试题-43：1-n-整数中-1-出现的次数" class="headerlink" title="面试题 43：1 ~ n  整数中 1 出现的次数"></a>面试题 43：1 ~ n  整数中 1 出现的次数</h5><p>求出 $[1,n]$ 整数的十进制表示中1出现的次数。例如1~13中包含1的数字有1、10、11、12、13，因此共出现6次。</p><p>从数字规律着手： 若 $n=21345$，先把 $1 \sim 21345$ 的所有数字分成两段 $1 \sim 1345$ 和 $1326  \sim 21345$。</p><p>先求 $1326  \sim 21345$ 范围上 1 出现的次数。【1出现在最高位】：1 出现在 $10000 \sim 19999$ 这10000个数字的万位上，共 $10^4$，（如果万位的数字位1，例如求 $n=12345$中 $2346 \sim 12345$ 范围上万位出现 1 的次数，只有 $10000 \sim 12345$ 范围）；【1出现在除最高位之外的其他位中】：最高位（万位）一共有2个选择，其他四位选择其中一位是 1，其他三位可以是 $0 \sim 9$ 这 10 个数字中任意选择。因此 $1326  \sim 21345$ 范围中后 4 位中 1 出现的次数位 2 <em> 4 </em> 10^3 = 80000​。</p><p>再利用递归的方式求 $1 \sim 1345$ 范围中 1 出现的次数。一个数字 n 有 $O(\log n)$位，时间复杂度位 $O(\log n)$。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n &lt;=<span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        num_str = str(n)</span><br><span class="line">        oth_length = len(num_str) - <span class="number">1</span></span><br><span class="line">        numFirstDigit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> int(num_str[<span class="number">0</span>]) &gt; <span class="number">1</span>:</span><br><span class="line">            numFirstDigit = math.pow(<span class="number">10</span>, oth_length)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            numFirstDigit = int(num_str[<span class="number">1</span>:]) + <span class="number">1</span></span><br><span class="line">        numOtherDigit = int(num_str[<span class="number">0</span>]) * oth_length * math.pow(<span class="number">10</span>, oth_length <span class="number">-1</span>)</span><br><span class="line">        numRecursive = self.NumberOf1Between1AndN_Solution(int(num_str[<span class="number">1</span>:]))</span><br><span class="line">        <span class="keyword">return</span> numFirstDigit + numOtherDigit + numRecursive</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-44：数字序列中某一位的数字"><a href="#面试题-44：数字序列中某一位的数字" class="headerlink" title="面试题 44：数字序列中某一位的数字"></a>面试题 44：数字序列中某一位的数字</h5><p>数字以 $0123456789101112131415 \ldots $ 的格式序列化到一个字符序列中，在这个序列中第 5 位是 5， 第13位是 1。</p><p>从数字规律着手：（跳过若干数字，加速过程）例如序列中的第 1001 位，序列的前10位是 $0 \sim 9$ 这10个只有一位的数字，$1001 \gt 10$ 因此这10个数字可以直接跳过。继续从后面紧跟着的序列中找 $10001-10=991$ 位的数字；从 $10 \sim 99$ 这90个两位数共占位 90 <em> 2 = 180​ ，$991 \gt 180$，跳过这90个两位数，继续从后面紧跟着的序列中找 $991-180=881$位的数字；从 $100 \sim 999$ 这900个三位数共占位 3 </em> 900 = 2700​，$881 \lt 2700$，因此第 881 位是一个三位数，由于 881 = 270 * 3+1​，所以第881位的数字为从100往后270个数字即370的第二位数字。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DigitAtIndex</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> num &gt;= <span class="number">0</span> <span class="keyword">and</span> num &lt;= <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        digit = <span class="number">1</span></span><br><span class="line">        num -= <span class="number">10</span></span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            digit += <span class="number">1</span></span><br><span class="line">            count = <span class="number">9</span> * math.pow(<span class="number">10</span>, digit<span class="number">-1</span>) * digit</span><br><span class="line">            origin = num</span><br><span class="line">            num = num - count</span><br><span class="line">        number = int(origin / digit)</span><br><span class="line">        index = int(origin % digit)</span><br><span class="line">        val = number + math.pow(<span class="number">10</span>, digit<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> int(str(val)[index])</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-45：把数组排成最小的数（-）"><a href="#面试题-45：把数组排成最小的数（-）" class="headerlink" title="面试题 45：把数组排成最小的数（**）"></a>面试题 45：把数组排成最小的数（**）</h5><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 </p><p>重新定义比较规则：两个数字 $m$ 和 $n$ 能拼接成数字 $mn$ 和 $nm$，若 $mn \lt nm$，则定义为 $m$ 小于 $n$；若$mn \gt nm$，则定义为 $m$ 大于 $n$；若 $mn = nm$，则定义为 $m$ 等于 $n$；将给出的所有数字按照如上规则进行从小到大排序，并将排序好的数字依次打印出来即可。</p><p>潜在问题【大数问题】： $m$ 和 $n$ 都在 $int$ 型能表达的范围，但拼接出来的数字 $mn$ 和 $nm$ 用 $int$ 型表示可能会溢出。可以把数字转换成字符串来处理，同时可利用字符串大小的比较规则进行比较。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># python2的解法代码：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        string = [str(num) <span class="keyword">for</span> num <span class="keyword">in</span> numbers]</span><br><span class="line">        string.sort(self.theMax,reverse=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(string)</span><br><span class="line">           </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">theMax</span><span class="params">(self,str1,str2)</span>:</span></span><br><span class="line">        str1str2 = str1+str2</span><br><span class="line">        str2str1 = str2+str1</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> str1str2 &gt; str2str1 <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></div></div><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># # python3的解法代码：</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmp</span><span class="params">(self,a,b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> a+b&gt;b+a:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> a+b&lt;b+a:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self,numbers)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        number = list(map(str,numbers))</span><br><span class="line">        number.sort(key=cmp_to_key(self.cmp))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(number).lstrip(<span class="string">'0'</span>) <span class="keyword">or</span> <span class="string">'0'</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-46：把数字翻译成字符串-amp-amp-LeetCode-91-解码方法"><a href="#面试题-46：把数字翻译成字符串-amp-amp-LeetCode-91-解码方法" class="headerlink" title="面试题 46：把数字翻译成字符串 &amp;&amp; LeetCode  91. 解码方法"></a>面试题 46：把数字翻译成字符串 &amp;&amp; LeetCode  91. 解码方法</h5><p>LeetCode: <a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法</a><br>给定一个数字，按照如下规则翻译成字符串：0翻译成“a”，1翻译成“b”，…，25翻译成“z”。一个数字有多种翻译可能，例如12258一共有5种，分别是 $bccfi，bwfi，bczi，mcfi，mzi$。</p><p>递归方法：定义函数 $f(i)$表示从第 $i$ 位数字开始的不同翻译的数目，那么 $f(i) = f(i+1)+g(i, i+1)*f(i+1)$，其中 当第 $i$ 位和 $i+1$ 位两位数字拼接起来的数字在10~25的范围内时，$g(i, i+1)=1$。递归的解法存在重复的子问题（自上而下的解法），不是最佳解。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetTranslationCount</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num_str = str(number)</span><br><span class="line">        <span class="keyword">return</span> self.GetTranslationCountCore(num_str, <span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetTranslationCountCore</span><span class="params">(self, num_str, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(num_str) == i:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i + <span class="number">1</span> &lt; len(num_str) <span class="keyword">and</span> num_str[i] != <span class="string">'0'</span> <span class="keyword">and</span> int(num_str[i:i+<span class="number">2</span>]) &lt;= <span class="number">25</span>:</span><br><span class="line">            <span class="keyword">return</span> self.GetTranslationCountCore(num_str, i+<span class="number">1</span>) + self.GetTranslationCountCore(num_str, i+<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> self.GetTranslationCountCore(num_str, i+<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div></div><p>动态规划：（自下而上）根据递归方式写动态规划表</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetTranslationCount</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num_str = str(number)</span><br><span class="line">        length = len(num_str)</span><br><span class="line">        dp = [<span class="number">0</span>] * (length + <span class="number">1</span>)</span><br><span class="line">        dp[length] = <span class="number">1</span></span><br><span class="line">        dp[length - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[i] = dp[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> num_str[i] != <span class="string">'0'</span> <span class="keyword">and</span> int(num_str[i:i+<span class="number">2</span>]) &lt;= <span class="number">25</span>:</span><br><span class="line">                dp[i] += dp[i+<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></div></div><p>动态规划表的空间压缩写法：</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetTranslationCount</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num_str = str(number)</span><br><span class="line">        length = len(num_str)</span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        next = <span class="number">1</span></span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            tmp = cur</span><br><span class="line">            <span class="keyword">if</span> num_str[i] != <span class="string">'0'</span> <span class="keyword">and</span> int(num_str[i:i+<span class="number">2</span>]) &lt;= <span class="number">25</span>:</span><br><span class="line">                cur += next</span><br><span class="line">            next = tmp</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-47：礼物的最大价值-amp-amp-LeetCode-64-最小路径和"><a href="#面试题-47：礼物的最大价值-amp-amp-LeetCode-64-最小路径和" class="headerlink" title="面试题 47：礼物的最大价值 &amp;&amp; LeetCode  64. 最小路径和"></a>面试题 47：礼物的最大价值 &amp;&amp; LeetCode  64. 最小路径和</h5><p>LeetCode: <a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a><br>在一个 $m*n$ 的棋盘中的每一个格都放一个礼物，每个礼物都有一定的价值（价值大于0）.你可以从棋盘的左上角开始拿各种里的礼物，并每次向右或者向下移动一格，直到到达棋盘的右下角。给定一个棋盘及上面个的礼物，请计算你最多能拿走多少价值的礼物？ </p><p>递归解法：定义函数 $f(i, j)$ 表示到达坐标为 $(i, j)$的格子时能拿到的礼物的最大值，所以$f(i, j)=max(f(i-1, j),f(i, j-1))+gift[i, j]$，其中 $gift[i, j]$ 表示坐标为 $(i, j)$ 的格子里礼物的价值。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxValue</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> array == <span class="literal">None</span> <span class="keyword">or</span> len(array) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        rows = len(array)</span><br><span class="line">        cols = len(array[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> self.getMaxValue_Core(array, rows, cols, rows<span class="number">-1</span>, cols<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxValue_Core</span><span class="params">(self, array, rows, cols, row, col)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> row &lt; <span class="number">0</span> <span class="keyword">or</span> row &gt; rows - <span class="number">1</span> <span class="keyword">or</span> col &lt; <span class="number">0</span> <span class="keyword">or</span> col &gt; cols - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = array[row][col]</span><br><span class="line">        <span class="keyword">if</span> row &lt; rows <span class="keyword">and</span> col &lt; cols:</span><br><span class="line">            res += max(self.getMaxValue_Core(array, rows, cols, row<span class="number">-1</span>, col),</span><br><span class="line">                       self.getMaxValue_Core(array, rows, cols, row, col<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div><p>利用递归解法修改的动态规划方法：</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxValue</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> array == <span class="literal">None</span> <span class="keyword">or</span> len(array) == <span class="number">0</span> <span class="keyword">or</span> array[<span class="number">0</span>] == <span class="literal">None</span> <span class="keyword">or</span> len(array[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        rows = len(array)</span><br><span class="line">        cols = len(array[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(cols)] <span class="keyword">for</span> i <span class="keyword">in</span> range(rows)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = array[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, rows):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + array[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, cols):</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-1</span>] + array[<span class="number">0</span>][i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, cols):</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + array[i][j]</span><br><span class="line">        print(dp)</span><br><span class="line">        <span class="keyword">return</span> dp[rows<span class="number">-1</span>][cols<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></div></div><p>对动态规划表进行进一步空间压缩：</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxValue</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> array == <span class="literal">None</span> <span class="keyword">or</span> len(array) == <span class="number">0</span> <span class="keyword">or</span> array[<span class="number">0</span>] == <span class="literal">None</span> <span class="keyword">or</span> len(array[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        rows = len(array)</span><br><span class="line">        cols = len(array[<span class="number">0</span>])</span><br><span class="line">        more = max(rows, cols)  <span class="comment"># 行数和列数较大的是more</span></span><br><span class="line">        less = min(rows, cols)  <span class="comment"># 行数和列数较小的是less</span></span><br><span class="line">        rowmore = (more == rows)  <span class="comment"># 行数是不是大于或者等于列数，始终用最小的空间生成动态规划表</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(less)]</span><br><span class="line">        dp[<span class="number">0</span>] = array[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, less):</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + (array[<span class="number">0</span>][i] <span class="keyword">if</span> rowmore <span class="keyword">else</span> array[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, more):</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">0</span>] + (array[i][<span class="number">0</span>] <span class="keyword">if</span> rowmore <span class="keyword">else</span> array[<span class="number">0</span>][i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, less):</span><br><span class="line">                dp[j] = max(dp[j<span class="number">-1</span>], dp[j]) + (array[i][j] <span class="keyword">if</span> rowmore <span class="keyword">else</span> array[j][i])</span><br><span class="line">        <span class="keyword">return</span> dp[less - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-48：最长不含重复字符的子字符串-amp-amp-LeetCode-3-无重复字符串的最长字串"><a href="#面试题-48：最长不含重复字符的子字符串-amp-amp-LeetCode-3-无重复字符串的最长字串" class="headerlink" title="面试题 48：最长不含重复字符的子字符串 &amp;&amp; LeetCode 3. 无重复字符串的最长字串"></a>面试题 48：最长不含重复字符的子字符串 &amp;&amp; LeetCode 3. 无重复字符串的最长字串</h5><p>LeetCode：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a><br>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含 ’a’~’z’ 的字符。例如，在字符串 $”arabcacfr”$ 中，最长的不含重复字符的子字符串就是 $”acfr”$，长度为4。 </p><p>暴力递归的时间复杂度为 $O(N^3)$，长度为 $n$ 的字符串包含 $O(N^2)$ 个子字符串，判断一个子字符串中是否包含重复的字符的时间复杂度为 $O(N)$。</p><p>动态规划：定义函数 $f(i)$ 表示以第 $i$ 个字符为结尾的不包含重复字符的子字符串的最长长度。从左到右逐一扫描字符串中的每个字符，并使用哈希表保持每个字符上一次出现在字符串中位置对应的下标。若第 $i$ 个字符之前没有出现过， $f(i) = f(i-1) + 1$；若第 $i$ 个字符之前出现过，记第 $i$ 个字符和它上次出现在字符串中的位置的距离为 $d$，【$d \le f(i-1)$】：表明第 $i$ 个字符上次出现在 $f(i-1)$ 对应的最长子字符串中，此时 $f(i-1) = d$；【$d \gt f(i-1)$】：表明第 $i$ 个字符上次出现在 $f(i-1)$ 对应的最长子字符串之前，此时 $f(i)=f(i-1)+1$。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="literal">None</span> <span class="keyword">or</span> len(s) ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        maxvalue = dp[<span class="number">0</span>]</span><br><span class="line">        hashmap[s[<span class="number">0</span>]] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> hashmap:</span><br><span class="line">                distance = i - hashmap[s[i]]</span><br><span class="line">                hashmap[s[i]] = i</span><br><span class="line">                <span class="keyword">if</span> distance &lt;= dp[i<span class="number">-1</span>]:</span><br><span class="line">                    dp[i] = distance</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                hashmap[s[i]] = i</span><br><span class="line">            <span class="keyword">if</span> dp[i] &gt; maxvalue:</span><br><span class="line">                maxvalue = dp[i]</span><br><span class="line">        <span class="keyword">return</span> maxvalue</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-49：丑数"><a href="#面试题-49：丑数" class="headerlink" title="面试题 49：丑数"></a>面试题 49：丑数</h5><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><p>丑数：如果一个数能被 $2$ 整除，就连续除以 $2$；如果能被 $3$ 整除，就连续除以 $3$；如果能被 $5$ 整除，就连续除以 $5$，最后得到的是 $1$。同时丑数应该是另一个丑数乘以 $2$、$3$ 或者 $5$ 的结果。</p><p>创建数组，保持排序好的丑数：数组中最大的丑数记为$M$，将数组前面的数分别乘以 $2, 3, 5$，获得大于 $M$的三个数$M_2, M_3, M_5$，下一个丑数是这个三个数中最小的，并使用 $T_2, T_3, T_5$ 保存排在此数之前的丑数乘以 $2, 3, 5$ 的结果都会小于 $M$。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.result = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> index &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.result = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(index)]</span><br><span class="line">        self.result[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        nextUglyIndex = <span class="number">1</span></span><br><span class="line">        T_2 = <span class="number">0</span></span><br><span class="line">        T_3 = <span class="number">0</span></span><br><span class="line">        T_5 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> nextUglyIndex &lt; index:</span><br><span class="line">            three_min = self.three_min(T_2, T_3, T_5)</span><br><span class="line">            self.result[nextUglyIndex] = three_min</span><br><span class="line">            <span class="keyword">while</span> self.result[T_2] * <span class="number">2</span> &lt;= self.result[nextUglyIndex]:</span><br><span class="line">                T_2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> self.result[T_3] * <span class="number">3</span> &lt;= self.result[nextUglyIndex]:</span><br><span class="line">                T_3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> self.result[T_5] * <span class="number">5</span> &lt;= self.result[nextUglyIndex]:</span><br><span class="line">                T_5 += <span class="number">1</span></span><br><span class="line">            nextUglyIndex += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.result[nextUglyIndex - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">three_min</span><span class="params">(self, T_2, T_3, T_5)</span>:</span></span><br><span class="line">        three_min = min(self.result[T_2]*<span class="number">2</span>, self.result[T_3]*<span class="number">3</span>)</span><br><span class="line">        three_min = min(three_min, self.result[T_5]*<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> three_min</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-50-1：字符串中第一个只出现一次的字符"><a href="#面试题-50-1：字符串中第一个只出现一次的字符" class="headerlink" title="面试题 50.1：字符串中第一个只出现一次的字符"></a>面试题 50.1：字符串中第一个只出现一次的字符</h5><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。</p><p>利用哈希表，扫描两次数组，第一次扫描时，每扫描到一个字符，就在哈希表的对应项中把次数加 1；第二次扫描时，每扫描到一个字符，就从哈希表中获得该字符出现的次数，第一个只出现一次的字符就是符合要求的输出。时间复杂度为 $O(N)$ ，空间复杂度 $O(1)$（需要一个包含256个字符的辅助数组，大小为 1KB，由于数组大小是个常数，可以认为空间复杂度时常数。）</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">if</span> dic[i] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span></span><br></pre></td></tr></table></figure></div></div><p>扩展题：考虑字符汉字<br>相关题目：</p><ol><li>从第一个字符串中删除在第二个字符串中出现过的所有字符。使用数组创建一个哈希表用来存储第二个字符串中出现过的字符，从头到尾遍历第一个字符串的每个字符，用 $O(1)$ 的时间判断是否出现在第二个字符串中。时间复杂度为 $O(N)$。</li><li>删除字符串中所有重复出现的字符，例如输入‘google’，输出’gole’。时间复杂度为 $O(N)$。</li><li>如果两个单词中出现的字符相同，并且每个字母出现的次数也相同，则这两个单词互为变位词。例如：‘evil’ 和 ’live’。判断输入的两个字符串是不是互为变位词。建立一个哈希表，扫描第一个字符串时哈希表对应的值增加 1，当扫描第二个字符串时，哈希表中对应的项值减去 1。</li></ol><h5 id="面试题-50-2：字符流中第一个只出现一次的字符"><a href="#面试题-50-2：字符流中第一个只出现一次的字符" class="headerlink" title="面试题 50.2：字符流中第一个只出现一次的字符"></a>面试题 50.2：字符流中第一个只出现一次的字符</h5><p>利用哈希表来保存字符在字符流中的位置。当一个字符第一次从字符流中读出来时，在哈希表中保存字符和字符的位置，若字符再次出现时，更新值为一个特殊值。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s = <span class="string">''</span></span><br><span class="line">        self.dict = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.s:</span><br><span class="line">            <span class="keyword">if</span> self.dict[i]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, char)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.s += char</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> self.dict:</span><br><span class="line">            self.dict[char]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.dict[char] = <span class="number">1</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-51：数组中的逆序对"><a href="#面试题-51：数组中的逆序对" class="headerlink" title="面试题 51：数组中的逆序对"></a>面试题 51：数组中的逆序对</h5><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数P。</p><p>先把数组分隔成子数组，统计出子数组内部的逆序对数目，然后再统计出两个相邻子数组之间的逆序对的数目，先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数字，【第一个子数组中的数字 &gt; 第二个子数组中的数字】：构成逆序对，逆序对的数目 == 第二个子数组中剩余数字的个数；【第一个子数组中的数字 &lt;= 第二个子数组中的数字】：不构成逆序对。每次比较时，将较大的数字从后往前复制到一个辅助数组，确保辅助数组中的数字是递增排序的（归并排序）。时间复杂度为 $O(N \log N)$ （归并排序的时间复杂度），空间复杂度为 $O(N)$。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        length = len(data)</span><br><span class="line">        <span class="keyword">if</span> data == <span class="literal">None</span> <span class="keyword">or</span> length &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        copy = [i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">        count = self.InversePairsCore(data, copy, <span class="number">0</span>, length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> count % <span class="number">10000000007</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairsCore</span><span class="params">(self, data, copy, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == end:</span><br><span class="line">            copy[start] = data[start]</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = (end - start) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 函数调用时将copy数组和data数组互换</span></span><br><span class="line">        left = self.InversePairsCore(copy, data, start, start + length)</span><br><span class="line">        right = self.InversePairsCore(copy, data, start + length + <span class="number">1</span>, end)</span><br><span class="line">        i = start + length</span><br><span class="line">        j = end</span><br><span class="line">        indexCopy = end</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= start <span class="keyword">and</span> j &gt;= start + length + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> data[i] &gt; data[j]:</span><br><span class="line">                copy[indexCopy] = data[i]</span><br><span class="line">                indexCopy -= <span class="number">1</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                count += j - start - length</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                copy[indexCopy] = data[j]</span><br><span class="line">                indexCopy -= <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= start:</span><br><span class="line">            copy[indexCopy] = data[i]</span><br><span class="line">            indexCopy -= <span class="number">1</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= start + length + <span class="number">1</span>:</span><br><span class="line">            copy[indexCopy] = data[j]</span><br><span class="line">            indexCopy -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left + right + count</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-52：两个链表的第一个公共节点"><a href="#面试题-52：两个链表的第一个公共节点" class="headerlink" title="面试题 52：两个链表的第一个公共节点"></a>面试题 52：两个链表的第一个公共节点</h5><p>输入两个链表，找出它们的第一个公共结点。</p><p>时间复杂度 $O(N+M)$，额外空间复杂度 $O(N+M)$：若两个链表有公共节点，则公共节点出现在两个链表的尾部，从尾部往前比较，最后一个相同的节点即为第一个公共节点。“后进先出”的思想，利用两个栈来实现，分别把两个链表的节点放在两个栈中。</p><p>时间复杂度 $O(N+M)$，额外空间复杂度 $O(1)$：先遍历两个链表得到它们的长度，得到长链表比短链表多几个节点；再进行第二次遍历，在较长的链表上先走若干步，接着在两个链表上同时遍历，找到的第一个相同的节点即为第一个公共节点。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        p1_length = self.GetListLength(pHead1)</span><br><span class="line">        p2_length = self.GetListLength(pHead2)</span><br><span class="line">        <span class="keyword">if</span> p1_length &gt; p2_length:</span><br><span class="line">            pNodeLong = pHead1</span><br><span class="line">            pNodeShort = pHead2</span><br><span class="line">            dif_length = p1_length - p2_length</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pNodeLong = pHead2</span><br><span class="line">            pNodeShort = pHead1</span><br><span class="line">            dif_length = p2_length - p1_length</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(dif_length):</span><br><span class="line">            pNodeLong = pNodeLong.next</span><br><span class="line">        <span class="keyword">while</span> pNodeLong != <span class="literal">None</span> <span class="keyword">and</span> pNodeShort != <span class="literal">None</span> <span class="keyword">and</span> pNodeLong != pNodeShort:</span><br><span class="line">            pNodeLong = pNodeLong.next</span><br><span class="line">            pNodeShort = pNodeShort.next</span><br><span class="line">        <span class="keyword">return</span> pNodeLong</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetListLength</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        nLength = <span class="number">0</span></span><br><span class="line">        pNode = pHead</span><br><span class="line">        <span class="keyword">while</span> pNode != <span class="literal">None</span>:</span><br><span class="line">            nLength += <span class="number">1</span></span><br><span class="line">            pNode = pNode.next</span><br><span class="line">        <span class="keyword">return</span> nLength</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-53-1：数字在排序数组中出现的次数"><a href="#面试题-53-1：数字在排序数组中出现的次数" class="headerlink" title="面试题 53.1：数字在排序数组中出现的次数"></a>面试题 53.1：数字在排序数组中出现的次数</h5><p>统计一个数字在排序数组中出现的次数。 </p><p>利用二分查找的方法，找到数字第一次在数组中出现的位置【用数组中间的数字和要找的数字比较，若大于，往前找，若小于，往后找，若相等，查看中间数字的前一个是不是要找的数字】，找到数字最后一次在数组中出现的位置。时间复杂度为 $O(\log N)$。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="literal">None</span> <span class="keyword">or</span> len(data) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        number = <span class="number">0</span></span><br><span class="line">        first = self.GetFirstK(data, k, <span class="number">0</span>, len(data)<span class="number">-1</span>)</span><br><span class="line">        last = self.GetLastK(data, k, <span class="number">0</span>, len(data)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> first &gt; <span class="number">-1</span> <span class="keyword">and</span> last &gt; <span class="number">-1</span>:</span><br><span class="line">            number = last - first + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> number</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetFirstK</span><span class="params">(self, data, k, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        middle = int((end - start) / <span class="number">2</span>) + start</span><br><span class="line">        <span class="keyword">if</span> data[middle] == k:</span><br><span class="line">            <span class="keyword">if</span> (middle &gt; <span class="number">0</span> <span class="keyword">and</span> data[middle<span class="number">-1</span>] != k) <span class="keyword">or</span> middle == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = middle - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> data[middle] &gt; k:</span><br><span class="line">            end = middle - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.GetFirstK(data, k, start, end)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLastK</span><span class="params">(self, data, k, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        middle = int((end - start) / <span class="number">2</span>) + start</span><br><span class="line">        <span class="keyword">if</span> data[middle] == k:</span><br><span class="line">            <span class="keyword">if</span> (middle &lt; len(data)<span class="number">-2</span> <span class="keyword">and</span> data[middle + <span class="number">1</span>] != k) <span class="keyword">or</span> middle == len(data) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> data[middle] &gt; k:</span><br><span class="line">            end = middle - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.GetLastK(data, k, start, end)</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-53-2：0-n-1-中缺失的数字"><a href="#面试题-53-2：0-n-1-中缺失的数字" class="headerlink" title="面试题 53.2：0~n-1 中缺失的数字"></a>面试题 53.2：0~n-1 中缺失的数字</h5><p> 一个长度为 $n-1$ 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0~n-1 之内。在范围 0~n-1 内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 </p><p>数字在数组中是是排序的，因此数组中开始的一些数字和它们的下标相同。记不在数组中的数为 $m$，那么所有比 $m$ 小的数字的下标都与它们的值相同，转换问题为：在排序数组中找出第一个值和下标不相等的元素。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMissingNumber</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="literal">None</span> <span class="keyword">or</span> len(number) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(number) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = int((right - left) / <span class="number">2</span>) + left</span><br><span class="line">            <span class="keyword">if</span> number[middle] != middle:</span><br><span class="line">                <span class="keyword">if</span> middle == <span class="number">0</span> <span class="keyword">or</span> number[middle<span class="number">-1</span>] == middle - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> middle</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left == len(number):</span><br><span class="line">            <span class="keyword">return</span> len(number)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-53-3：数组中数值和下标相等的元素"><a href="#面试题-53-3：数组中数值和下标相等的元素" class="headerlink" title="面试题 53.3：数组中数值和下标相等的元素"></a>面试题 53.3：数组中数值和下标相等的元素</h5><p>假设一个单调递增的数组里的每个元素都是整数且是唯一的，请编程实现一个函数，找出数组中任意一个数值等于其下标的元素，例如，在数组{-3，-1,1,3,5}中数字3和它的下标相同。 </p><p>利用二分查找算法：若当前数字的值 $m$ &gt; 数组的下标值 $i$：数组右边的数字都将大于其下标。若当前数字的值 $m$ &lt; 数组的下标值 $i$：数组左边的数字都将小于其下标。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberSameAsIndex</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="literal">None</span> <span class="keyword">or</span> len(number) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(number) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = int((right - left) / <span class="number">2</span>) + left</span><br><span class="line">            <span class="keyword">if</span> number[middle] == middle:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">            <span class="keyword">elif</span> number[middle] &gt; middle:</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-54：-二叉搜索树的第-k-大节点"><a href="#面试题-54：-二叉搜索树的第-k-大节点" class="headerlink" title="面试题 54： 二叉搜索树的第 k 大节点"></a>面试题 54： 二叉搜索树的第 k 大节点</h5><p>给定一棵二叉搜索树，请找出其中的第 $k$ 大的结点。例如（5，3，7，2，4，6，8）中，按结点数值大小顺序第三大结点的值为 4。（中序遍历）</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pRoot == <span class="literal">None</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.KthNodeCore(pRoot, k)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNodeCore</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pRoot.left != <span class="literal">None</span>:</span><br><span class="line">            node = self.KthNodeCore(pRoot.left, k)</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.count == k:</span><br><span class="line">                <span class="keyword">return</span> pRoot</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span> <span class="keyword">and</span> pRoot.right != <span class="literal">None</span>:</span><br><span class="line">            node = self.KthNodeCore(pRoot.right, k)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-55-1：-二叉树的深度"><a href="#面试题-55-1：-二叉树的深度" class="headerlink" title="面试题 55.1： 二叉树的深度"></a>面试题 55.1： 二叉树的深度</h5><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br>根节点的左子树，右子树较大值 + 1为二叉树的高度。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pRoot == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.TreeDepth(pRoot.left)</span><br><span class="line">        right = self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span> <span class="keyword">if</span> left &gt; right <span class="keyword">else</span> right + <span class="number">1</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-55-2：-平衡二叉树"><a href="#面试题-55-2：-平衡二叉树" class="headerlink" title="面试题 55.2： 平衡二叉树"></a>面试题 55.2： 平衡二叉树</h5><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。<br>简单解：遍历树的每一个节点，获得节点的左右子数的深度，如果每个节点的左右子数的深度差都不超过1。此方法会重复遍历一个节点多次。<br>每个节点只遍历一次：利用后序遍历的方式（在遍历到一个节点之前已经遍历完它的左右子数），在遍历每个节点的时候纪录节点的深度。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.flag = <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pRoot == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.IsBalanced_Solution(pRoot.left) <span class="keyword">and</span> self.IsBalanced_Solution(pRoot.right):</span><br><span class="line">            left = self.TreeDepth(pRoot.left)</span><br><span class="line">            right = self.TreeDepth(pRoot.right)</span><br><span class="line">            <span class="keyword">if</span> abs(left - right) &gt; <span class="number">1</span>:</span><br><span class="line">                self.flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">return</span> self.flag</span><br><span class="line">        <span class="keyword">return</span> self.flag</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pRoot == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.TreeDepth(pRoot.left)</span><br><span class="line">        right = self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span> <span class="keyword">if</span> left &gt; right <span class="keyword">else</span> right + <span class="number">1</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-56-1：-数组中只出现一次的两个数字-amp-amp-LeetCode-260-只出现一次的数字-III"><a href="#面试题-56-1：-数组中只出现一次的两个数字-amp-amp-LeetCode-260-只出现一次的数字-III" class="headerlink" title="面试题 56.1： 数组中只出现一次的两个数字 &amp;&amp; LeetCode 260.只出现一次的数字 III"></a>面试题 56.1： 数组中只出现一次的两个数字 &amp;&amp; LeetCode 260.只出现一次的数字 III</h5><p>LeetCode：<a href="https://leetcode-cn.com/problems/single-number-iii/" target="_blank" rel="noopener">260. 只出现一次的数字 III</a><br>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<br>异或：任何一个数字异或自己等于0，【无进位相加】。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> array == <span class="literal">None</span> <span class="keyword">or</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        resultExclusiveOR = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            resultExclusiveOR ^= i</span><br><span class="line">        indexOf1 = (~resultExclusiveOR + <span class="number">1</span>) &amp; resultExclusiveOR</span><br><span class="line">        num1 = <span class="number">0</span></span><br><span class="line">        num2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> i &amp; indexOf1 == <span class="number">0</span>:</span><br><span class="line">                num1 ^= i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num2 ^= i</span><br><span class="line">        <span class="keyword">return</span> [num1, num2]</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-56-2：-数组中唯一只出现一次的数字-amp-amp-LeetCode-137-只出现一次的数字II"><a href="#面试题-56-2：-数组中唯一只出现一次的数字-amp-amp-LeetCode-137-只出现一次的数字II" class="headerlink" title="面试题 56.2： 数组中唯一只出现一次的数字  &amp;&amp;  LeetCode 137.只出现一次的数字II"></a>面试题 56.2： 数组中唯一只出现一次的数字  &amp;&amp;  LeetCode 137.只出现一次的数字II</h5><p>LeetCode：<a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137. 只出现一次的数字 II</a><br>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 </p><p>位运算：如果一个数字出现三次，那么它的二进制表示的每一位（0或者1）也出现三次，把所有出现三次的数字的二进制表示的每一位都分别加起来，那么每一位的和都能被3整除。数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除，那么那个只出现一次的数字二进制表示对应的那一位是0，否则为1。【注意：python的整型方便是方便了，但是由于其没有最大值，所以，当输入是一堆负数的时候，会导致认为结果是个整数！因为32位有符号的被认为成了无符号的，所以以后出现位运算的时候，需要对结果进行判断一下最好。如果不在这个范围内，说明了结果被认为是无符号的数了，需要减去 $2 ^ {32}$。【16位整数中 -32768到32767】【32位整数中 -2147483648到2147483647】最高位为符号位 【16位整数$-2^{15}$~$2^{15}-1$】【 32位整数$-2^{31}$~$2^{31}-1$】。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SingleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        bitSum = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            bitMask = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">31</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                bit = nums[i] &amp; bitMask</span><br><span class="line">                <span class="keyword">if</span> bit != <span class="number">0</span>:</span><br><span class="line">                    bitSum[j] += <span class="number">1</span></span><br><span class="line">                bitMask = bitMask&lt;&lt; <span class="number">1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            result = result &lt;&lt; <span class="number">1</span></span><br><span class="line">            result += bitSum[i] % <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> result &gt;= <span class="number">2</span> ** <span class="number">31</span>:</span><br><span class="line">            result -= <span class="number">2</span> ** <span class="number">32</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></div></div><p>其他解法： $k$ 进制的两个数 $c$ 和 $d$ 在 $i$ 位上无进位相加的结果就是 $(c(i)+d(i))\%k$ 。 如果k个相同的k进制数进行无进位相加，相加的结果一定是每一位上都是0的 $k$ 进制数。首先设置一个变量eO，它是一个32位的 $k$ 进制数，且每个位置上都是0。然后遍历arr，把遍历到的每一个整数都转换为k进制数，然后与eO进行无进位相加。遍历结束时，把32位的 $k$ 进制数eORes转换为十进制整数，就是我们想要的结果。因为 $k$ 个相同的k进制数无进位相加，结果一定是每一位上都是0的 $k$ 进制数，所以只出现一次的那个数最终就会剩下来。（左程云.《程序员代码面试指南：IT名企算法与数据结构题目最优解（第2版）》.[Z].北京.电子工业出版社.2019. 摘要：）</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补充代码</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-57-1：-和为-s-的两个数字"><a href="#面试题-57-1：-和为-s-的两个数字" class="headerlink" title="面试题 57.1： 和为 s 的两个数字"></a>面试题 57.1： 和为 s 的两个数字</h5><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br>定义两个指针，P1指向数组的开头，P2 指向数组的结尾，如果两个指针指向的数字之和 &gt; 数字S，P2指针向前移动；如果两个指针指向的数字之和 &lt; 数字S，P1指针向后移动。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        p1 = <span class="number">0</span></span><br><span class="line">        p2 = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; p2:</span><br><span class="line">            <span class="keyword">if</span> nums[p1] + nums[p2] == target:</span><br><span class="line">                <span class="keyword">return</span> [nums[p1], nums[p2]]</span><br><span class="line">            <span class="keyword">elif</span> nums[p1] + nums[p2] &gt; target:</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-57-2：-和为-s-的连续正数序列"><a href="#面试题-57-2：-和为-s-的连续正数序列" class="headerlink" title="面试题 57.2： 和为 s 的连续正数序列"></a>面试题 57.2： 和为 s 的连续正数序列</h5><p>输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以结果打印出3个连续序列1-5,，4-6和7-8。</p><p>用两个树 small 和 big 表示连续序列的最小值和最大值，初始化时 $small = 1，big = 2$, 如果 $small + big &lt; s$，增大 $big$，如果$small + big &gt; s$，从序列中去掉最小值，即增大 $small$；因为这个序列至少要有两个数字，因此一直增加 small 到 (1+s)/2。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span><span class="params">(self, target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        small = <span class="number">1</span></span><br><span class="line">        big = <span class="number">2</span></span><br><span class="line">        cursum = small + big</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> small &lt; (target+<span class="number">1</span>)//<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> cursum == target:</span><br><span class="line">                res.append([i <span class="keyword">for</span> i <span class="keyword">in</span> range(small, big+<span class="number">1</span>)])</span><br><span class="line">                big += <span class="number">1</span></span><br><span class="line">                cursum += big</span><br><span class="line">            <span class="keyword">elif</span> cursum &gt; target:</span><br><span class="line">                cursum -= small</span><br><span class="line">                small += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                big += <span class="number">1</span></span><br><span class="line">                cursum += big</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-58-1：翻转单词顺序"><a href="#面试题-58-1：翻转单词顺序" class="headerlink" title="面试题 58.1：翻转单词顺序"></a>面试题 58.1：翻转单词顺序</h5><p>输入一个英文句子，翻转句子中单词的顺序。例如，“I am a student.” 翻转成 “student. a am I”。<br>两次翻转字符串：第一次翻转句子中所有的字符：【“I am a student.”——“.tneduts a ma I”】；第二次再翻转每个单词中字符的顺序【“.tneduts a ma I”——“student. a am I”】</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">1</span> <span class="keyword">or</span> s == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> s </span><br><span class="line">        s_list = list(s)</span><br><span class="line">        self.Reverse(s_list, <span class="number">0</span>, len(s_list)<span class="number">-1</span>)</span><br><span class="line">        pBegin = <span class="number">0</span></span><br><span class="line">        pEnd = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pEnd &lt; len(s_list):</span><br><span class="line">            <span class="keyword">while</span> pEnd &lt; len(s_list) <span class="keyword">and</span> s_list[pEnd] != <span class="string">' '</span>:</span><br><span class="line">                pEnd += <span class="number">1</span></span><br><span class="line">            self.Reverse(s_list, pBegin, pEnd<span class="number">-1</span>)</span><br><span class="line">            pBegin = pEnd + <span class="number">1</span></span><br><span class="line">            pEnd = pBegin</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s_list)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Reverse</span><span class="params">(self, s_list, pBegin, pEnd)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> pBegin &lt; pEnd:</span><br><span class="line">            tmp = s_list[pBegin]</span><br><span class="line">            s_list[pBegin] = s_list[pEnd]</span><br><span class="line">            s_list[pEnd] = tmp</span><br><span class="line">            pBegin += <span class="number">1</span></span><br><span class="line">            pEnd -= <span class="number">1</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-58-2：左旋转字符串"><a href="#面试题-58-2：左旋转字符串" class="headerlink" title="面试题 58.2：左旋转字符串"></a>面试题 58.2：左旋转字符串</h5><p>对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。<br>翻转字符串：先将字符串分成两部分，分别进行翻转，最后再将整体进行翻转。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> s != <span class="literal">None</span>:</span><br><span class="line">            nLength = len(s)</span><br><span class="line">            s_list = list(s)</span><br><span class="line">            <span class="keyword">if</span> nLength &gt; <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n &lt; nLength:</span><br><span class="line">                pFirstStart = <span class="number">0</span></span><br><span class="line">                pFirstEnd = n - <span class="number">1</span></span><br><span class="line">                pSecondStrat = n</span><br><span class="line">                pSecondEnd = nLength - <span class="number">1</span></span><br><span class="line">                self.Reverse(s_list, pFirstStart, pFirstEnd)</span><br><span class="line">                self.Reverse(s_list, pSecondStrat, pSecondEnd)</span><br><span class="line">                self.Reverse(s_list, <span class="number">0</span>, nLength - <span class="number">1</span>)</span><br><span class="line">                s = <span class="string">''</span>.join(s_list)</span><br><span class="line">        <span class="keyword">return</span> s </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Reverse</span><span class="params">(self, s_list, pBegin, pEnd)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> pBegin &lt; pEnd:</span><br><span class="line">            tmp = s_list[pBegin]</span><br><span class="line">            s_list[pBegin] = s_list[pEnd]</span><br><span class="line">            s_list[pEnd] = tmp</span><br><span class="line">            pBegin += <span class="number">1</span></span><br><span class="line">            pEnd -= <span class="number">1</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-59：滑动窗口的最大值"><a href="#面试题-59：滑动窗口的最大值" class="headerlink" title="面试题 59：滑动窗口的最大值"></a>面试题 59：滑动窗口的最大值</h5><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 </p><p>双端队列：将有可能成为滑动窗口最大值的数值存入双端队列中。使用两个指针L，R 确定窗口，队列严格维持由大到小的顺序，R 右移时，当前数字从队列尾部进入，若此时队列中有 &lt; 当前数字的数时，则小于当前数的数先弹出（弹出的数字再不进入队列）；L 右移时，查看L 右移出的数字是否在队列中，若在则从队列头部移除。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> len(num) &gt;= size <span class="keyword">and</span> size &gt; <span class="number">0</span>:</span><br><span class="line">            index = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">                print(index)</span><br><span class="line">                <span class="keyword">while</span> len(index) != <span class="number">0</span> <span class="keyword">and</span> num[i] &gt;= num[index[<span class="number">-1</span>]]:</span><br><span class="line">                    index.pop()</span><br><span class="line">                index.append(i)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(size, len(num)):</span><br><span class="line">                result.append(num[index[<span class="number">0</span>]])</span><br><span class="line">                <span class="keyword">while</span> len(index) != <span class="number">0</span> <span class="keyword">and</span> num[i] &gt;= num[index[<span class="number">-1</span>]]:</span><br><span class="line">                    index.pop()</span><br><span class="line">                <span class="keyword">if</span> len(index) != <span class="number">0</span> <span class="keyword">and</span> index[<span class="number">0</span>] &lt;= i - size:</span><br><span class="line">                    index.pop(<span class="number">0</span>)</span><br><span class="line">                index.append(i)</span><br><span class="line">            result.append(num[index[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-60：n-个骰子的点数-amp-amp-LeetCode-60-n-个骰子的点数"><a href="#面试题-60：n-个骰子的点数-amp-amp-LeetCode-60-n-个骰子的点数" class="headerlink" title="面试题 60：n 个骰子的点数  &amp;&amp; LeetCode 60. n 个骰子的点数"></a>面试题 60：n 个骰子的点数  &amp;&amp; LeetCode 60. n 个骰子的点数</h5><p>LeetCode：<a href>面试题60. n个骰子的点数</a><br>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值的概率。 </p><p>基于递归：先把 $n$ 个骰子分成两部分，第一堆只有一个，另一堆有 $n-1$ 个，单独的一个骰子有可能出现1~6 的点数，需要计算 1~6的每一种点数和剩下的 $n-1$ 个骰子来计算点数和；接下来将剩下的 $n-1$ 个骰子再次按照上述方法分成两部分。多次重复计算，时间效率不高。</p><p>基于循环：用两个数字来存储骰子点数的每个总数出现的次数，在一轮循环中，第一个数组中的第 $n$ 个数字表示骰子和为 n 出现的次数，在下一轮循环中，加一个新的骰子，此时和为 n 的骰子出现的次数应该等于上一轮循环中骰子点数和为 $n-1, n-2, n-3, n-4, n-5, n-6$ 的次数的总和。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = <span class="number">6</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Probability</span><span class="params">(self, n: int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        maxsum = self.count * n</span><br><span class="line">        Probability = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(maxsum + <span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, self.count + <span class="number">1</span>):</span><br><span class="line">            Probability[flag][i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                Probability[<span class="number">1</span> - flag][i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k, self.count * k + <span class="number">1</span>):</span><br><span class="line">                Probability[<span class="number">1</span> - flag][i] = <span class="number">0</span></span><br><span class="line">                j = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j &lt;= i <span class="keyword">and</span> j &lt;= self.count:</span><br><span class="line">                    Probability[<span class="number">1</span> - flag][i] += Probability[flag][i - j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            flag = <span class="number">1</span> - flag</span><br><span class="line">        total = pow(self.count, n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n, self.count * n + <span class="number">1</span>):</span><br><span class="line">            Probability[flag][i] = Probability[flag][i] / total</span><br><span class="line">        <span class="keyword">return</span> Probability[flag][n:self.count*n + <span class="number">1</span>]</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-61：扑克牌中的顺子"><a href="#面试题-61：扑克牌中的顺子" class="headerlink" title="面试题 61：扑克牌中的顺子"></a>面试题 61：扑克牌中的顺子</h5><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。其中A为1，J为11，Q为12，K为13，而大小王为0，且大小王能够当做任意一张牌。<br>三步：首先把数组排序，其次统计数组中 0 的个数，最后统计排序之后的数组中相邻数字之间的空缺总数。如果空缺的总数小于或者等于 0 的个数，则数组是连续的，反之不连续。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsContinuous</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        numbers.sort()</span><br><span class="line">        numOfKing = numbers.count(<span class="number">0</span>)</span><br><span class="line">        numOflack = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numOfKing, len(numbers) <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> numbers[i] == numbers[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                numOflack += (numbers[i + <span class="number">1</span>] - numbers[i] - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> numOfKing &gt;= numOflack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div></div><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isStraight</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        respeat = []</span><br><span class="line">        maxvalue = <span class="number">0</span></span><br><span class="line">        minvalue = <span class="number">14</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            print(respeat)</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">            maxvalue = max(maxvalue, num)</span><br><span class="line">            minvalue = min(minvalue, num)</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> respeat:<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            respeat.append(num)</span><br><span class="line">        <span class="keyword">return</span> maxvalue - minvalue &lt; <span class="number">5</span></span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-62：圆圈中最后剩下的数字"><a href="#面试题-62：圆圈中最后剩下的数字" class="headerlink" title="面试题 62：圆圈中最后剩下的数字"></a>面试题 62：圆圈中最后剩下的数字</h5><p>$0, 1, … , n-1$ 这n个数字排成一个圈圈，从数字0开始每次从圆圏里删除第m个数字。求出这个圈圈里剩下的最后一个数字。 </p><p>经典解法：利用环形链表模拟圆圈，创建一个共有 n 个节点的环形链表，然后每次在这个链表中删除第 m 个节点。每删除一个数字需要 m 步运算，共有 n 个数字，总的时间复杂度为 $O(mn)$，同时还需要一个辅助链表来模拟圆圈，额外空间复杂度为 $O(n)$。</p><p>找规律法：设 $f(n, m)$，表示每次在 n 个数字0，1，…，n-1中删除第 m 个数字最后剩下的数字，删除的第一个数字$(m-1)\%n$，记为 k，$f^{‘}(n-1, m)$ 表示在第一个数字被删除后，序列重新调整后删除第 m 个节点最后剩下的数字，因此 $f^{‘}(n-1, m)=f(n, m)$；设 $p(x)=(x-k-1)\%n$，表示如果映射前的数字是 $x$，映射后的数字是 $(x-k-1)\%n$，逆映射为 $p^{-1}(x) = (x+k+1)\%n$。因此 $f^{’}(n-1, m)=p^{-1}[f(n-1,m)]=[f(n-1, m)+k+1] \%n$。</p><script type="math/tex; mode=display">f(n, m)=\begin{cases}0, & \text{n=1} \\[3ex][f(n-1, m)+m]\%n, & \text{n>1}\end{cases}</script><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span> <span class="keyword">or</span> m &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        last = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            last = (last + m) % i</span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-63：股票的最大利润-amp-amp-LeetCode-121-买卖股票的最佳时机"><a href="#面试题-63：股票的最大利润-amp-amp-LeetCode-121-买卖股票的最佳时机" class="headerlink" title="面试题 63：股票的最大利润 &amp;&amp; LeetCode 121.买卖股票的最佳时机"></a>面试题 63：股票的最大利润 &amp;&amp; LeetCode 121.买卖股票的最佳时机</h5><p>LeetCode：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a><br>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖交易该股票可能获得的利润是多少？例如一只股票在某些时间节点的价格为$\{9, 11, 8, 5, 7, 12, 16, 14\}$。如果我们能在价格为5的时候买入并在价格为16时卖出，则能收获最大的利润11。 </p><p>定义函数 $diff(i)$ 为当卖出价为数组中第 $i$ 个数字时可能获得的最大利润，遍历数组时，需要前 $i-1$个数字中的最小值。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> prices == <span class="literal">None</span> <span class="keyword">or</span> len(prices) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        minbuy = prices[<span class="number">0</span>]</span><br><span class="line">        maxdiff = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i<span class="number">-1</span>] &lt; minbuy:</span><br><span class="line">                minbuy = prices[i<span class="number">-1</span>]</span><br><span class="line">            curdiff = prices[i] - minbuy</span><br><span class="line">            <span class="keyword">if</span> curdiff &gt; maxdiff:</span><br><span class="line">                maxdiff = curdiff</span><br><span class="line">        <span class="keyword">return</span> maxdiff</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-64：-求-1-2-…-n"><a href="#面试题-64：-求-1-2-…-n" class="headerlink" title="面试题 64： 求 1+2+…+n"></a>面试题 64： 求 1+2+…+n</h5><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 </p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用python特征</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> sum(list(range(<span class="number">1</span>,n+<span class="number">1</span>)))</span><br><span class="line"><span class="comment"># 终止递归采用逻辑与的短路特性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here     </span></span><br><span class="line">        <span class="keyword">return</span> n <span class="keyword">and</span> n + self.Sum_Solution(n<span class="number">-1</span>)</span><br><span class="line"><span class="comment"># 利用两个函数，一个函数充当递归函数的角色，另一个函数处理终止递归的情况，如果对n连续进行两次反运算，那么非零的n转换为True，0转换为False。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here     </span></span><br><span class="line">        <span class="keyword">return</span> self.sum(n)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum0</span><span class="params">(self,n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(self,n)</span>:</span></span><br><span class="line">        func=&#123;<span class="literal">False</span>:self.sum0,<span class="literal">True</span>:self.sum&#125;</span><br><span class="line">        <span class="keyword">return</span> n+func[<span class="keyword">not</span> <span class="keyword">not</span> n](n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-65：不用加减乘除做加法"><a href="#面试题-65：不用加减乘除做加法" class="headerlink" title="面试题 65：不用加减乘除做加法"></a>面试题 65：不用加减乘除做加法</h5><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 </p><p>第一步不考虑进位对每个数的二进制每一位相加（两个数的异或）；第二步考虑进位，对 0 加 0、0 加 1、1 加 0 都不会产生进位，只有 1 加 1时，才会产生进位，即两个数先做位与运算，然后左移一位；第三步将前两步的结果按照上述两步方式进行相加，直到不产生进位。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">while</span> num2 != <span class="number">0</span>:</span><br><span class="line">            xor = num1 ^ num2</span><br><span class="line">            carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span></span><br><span class="line">            num1 = xor</span><br><span class="line">            num2 = carry</span><br><span class="line">        <span class="keyword">return</span> num1</span><br></pre></td></tr></table></figure></div></div><p>在使用Python实现的过程中，对于正整数是没有问题的，但是对于负数，会出现死循环情况。因为在Python中，对于超出32位的大整数，会自动进行大整数的转变，这就导致了在右移位过程中，不会出现移到了0的情况，也就会造成了死循环。已经知道了右移过程中大整数的自动转化，导致变不成0，那么只需要在移动的过程中加一下判断就行了，把carry的值和 $0xFFFFFFFF$ 做一下比较就可以。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 牛客网</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        carry = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> carry:</span><br><span class="line">            xor = num1 ^ num2</span><br><span class="line">            carry = <span class="number">0xFFFFFFFF</span> &amp; ((num1 &amp; num2) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">            carry = -(~(carry - <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFF</span>) <span class="keyword">if</span> carry &gt; <span class="number">0x7FFFFFFF</span> <span class="keyword">else</span> carry</span><br><span class="line">            num1 = xor</span><br><span class="line">            num2 = carry</span><br><span class="line">        <span class="keyword">return</span> num1</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-66：构建乘积数组"><a href="#面试题-66：构建乘积数组" class="headerlink" title="面试题 66：构建乘积数组"></a>面试题 66：构建乘积数组</h5><p>给定一个数组A[0,1,…,n-1]，请构建一个数组B[0,1,…,n-1]，其中B中的元素 $B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]$。不能使用除法。（注意：规定B[0] = A[1] <em> A[2] </em> … <em> A[n-1]，B[n-1] = A[0] </em> A[1] <em> … </em> A[n-2];） </p><p>把 $B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]$ 看成 $A[0] <em>A[1]</em>…<em>A[i-1]$ 和 $A[i+1]</em>…<em>A[n-2]</em>A[n-1]$ 两部分的乘积。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> A == <span class="literal">None</span> <span class="keyword">or</span> len(A) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        length = len(A) </span><br><span class="line">        B = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(length)]</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            B[i] = B[i<span class="number">-1</span>] * A[i<span class="number">-1</span>]</span><br><span class="line">        temp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            temp *= A[i + <span class="number">1</span>]</span><br><span class="line">            B[i] *= temp</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure></div></div><h5 id="面试题-67：把字符串转换成整数"><a href="#面试题-67：把字符串转换成整数" class="headerlink" title="面试题 67：把字符串转换成整数"></a>面试题 67：把字符串转换成整数</h5><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 。</p><p>主要是需要对异常值要做出处理：指针是否为空指针以及字符串是否为空字符串；字符串对于正负号的处理；输入值是否为合法值，即小于等于’9’，大于等于’0’；int为32位，需要判断是否溢出；使用错误标志，区分合法值0和非法值0。代码中用两个函数来实现该功能，其中标志位g_nStatus用来表示是否为异常输出，minus标志位用来表示是否为负数。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.g_nStatus = <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StrToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="literal">None</span> <span class="keyword">or</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            self.g_nStatus = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        minus = <span class="literal">False</span></span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'+'</span>:</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'-'</span>:</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            minus = <span class="literal">True</span></span><br><span class="line">        begin = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            begin = <span class="number">1</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        minus = <span class="number">-1</span> <span class="keyword">if</span> minus <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s[begin:]:</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="string">'0'</span> <span class="keyword">and</span> i &lt;= <span class="string">'9'</span>:</span><br><span class="line">                num = num * <span class="number">10</span> + minus * (ord(i) - ord(<span class="string">'0'</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.g_nStatus = <span class="literal">False</span></span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">-2</span> ** <span class="number">31</span> <span class="keyword">or</span> num &gt; <span class="number">2</span> ** <span class="number">31</span> <span class="number">-1</span>:</span><br><span class="line">            self.g_nStatus = <span class="literal">False</span></span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">print(Solution().StrToInt(<span class="string">''</span>))  <span class="comment"># 输入的字符串为空字符串</span></span><br><span class="line">print(Solution().StrToInt(<span class="literal">None</span>))  <span class="comment"># 输入的字符串为空指针</span></span><br><span class="line">print(Solution().StrToInt(<span class="string">'12%34'</span>))  <span class="comment"># 输入的字符串中有非数字字符</span></span><br><span class="line">print(Solution().StrToInt(<span class="string">'-123'</span>))</span><br><span class="line">print(Solution().StrToInt(<span class="string">'+123'</span>))</span><br><span class="line">print(Solution().StrToInt(<span class="string">'-0'</span>))</span><br><span class="line">print(Solution().StrToInt(<span class="string">'-2147483649'</span>))</span><br><span class="line">print(<span class="number">2</span> ** <span class="number">31</span>)  <span class="comment"># 2147483648</span></span><br><span class="line">print(<span class="number">2</span> ** <span class="number">32</span>)  <span class="comment"># 4294967296</span></span><br><span class="line">print(<span class="number">0xFFFFFFFF</span>)  <span class="comment"># 4294967295</span></span><br><span class="line">print(<span class="number">0x80000000</span>)  <span class="comment"># 2147483648</span></span><br></pre></td></tr></table></figure></div></div><p>【16位整数中 -32768到32767】【32位整数中 -2147483648到2147483647】最高位为符号位 【16位整数$-2^{15}$~$2^{15}-1$】【 32位整数$-2^{31}$~$2^{31}-1$】</p><h5 id="面试题-68：树中两个节点的最低公共祖先-amp-amp-LeetCode-235-二叉搜索树的最近公共祖先-amp-amp-LeetCode-236-二叉树的最近公共祖先"><a href="#面试题-68：树中两个节点的最低公共祖先-amp-amp-LeetCode-235-二叉搜索树的最近公共祖先-amp-amp-LeetCode-236-二叉树的最近公共祖先" class="headerlink" title="面试题 68：树中两个节点的最低公共祖先 &amp;&amp; LeetCode 235.二叉搜索树的最近公共祖先  &amp;&amp; LeetCode 236. 二叉树的最近公共祖先"></a>面试题 68：树中两个节点的最低公共祖先 &amp;&amp; LeetCode 235.二叉搜索树的最近公共祖先  &amp;&amp; LeetCode 236. 二叉树的最近公共祖先</h5><p>题目：输入两个树的节点，求它们的最低公共祖先。<br>树是二叉搜索树：【LeetCode：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - I. 二叉搜索树的最近公共祖先</a>】；在二叉搜索树中，位与左子树的节点都比父节点小，而位与右子树的节点都比父节点大，从树的根节点开始和两个输入的节点进行比较，若当前节点的值比两个节点的值都大，则最低公共祖先一定在当前节点的左子树中；若当前节点的值比两个节点的值都小，则最低公共祖先一定在当前节点的右子树中，在树中从上到下找到第一个在两个输入节点的值之间的节点即为最低公共祖先。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span> <span class="keyword">or</span> p == <span class="literal">None</span> <span class="keyword">or</span> q == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pNode = root</span><br><span class="line">        <span class="keyword">while</span> pNode != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> pNode.val &gt; p.val <span class="keyword">and</span> pNode.val &gt; q.val:</span><br><span class="line">                pNode = pNode.left</span><br><span class="line">            <span class="keyword">elif</span> pNode.val &lt; p.val <span class="keyword">and</span> pNode.val &lt; q.val:</span><br><span class="line">                pNode = pNode.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> pNode</span><br><span class="line">        <span class="keyword">return</span> pNode</span><br></pre></td></tr></table></figure></div></div><p>树是二叉树，且树的节点中有指向父节点的指针：可以将问题转换成求两个链表的第一个公共节点，从两个输入节点开始，创建两个链表，链表的尾指针都是树的根节点。</p><p>树是二叉树，但树的节点中没有指向父节点的指针：【LeetCode：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a>】用两个链表分别保存从根节点到输入的两个节点的路径，之后将问题转换成两个链表的最后公共节点。时间复杂度为 $O(N)$，额外空间复杂度为 $O(\log n)$。</p><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span> <span class="keyword">or</span> p == <span class="literal">None</span> <span class="keyword">or</span> q == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        path1 = []</span><br><span class="line">        path2 = []</span><br><span class="line">        self.CreateLink(root, p, path1)</span><br><span class="line">        self.CreateLink(root, q, path2)</span><br><span class="line">        <span class="keyword">return</span> self.LastCommonNode(path1, path2)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CreateLink</span><span class="params">(self, root, p, path)</span>:</span></span><br><span class="line">        pNode = root</span><br><span class="line">        path.append(pNode)</span><br><span class="line">        <span class="keyword">if</span> root == p:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> found == <span class="literal">False</span> <span class="keyword">and</span> pNode.left != <span class="literal">None</span>:</span><br><span class="line">            found = self.CreateLink(pNode.left, p, path)</span><br><span class="line">        <span class="keyword">if</span> found == <span class="literal">False</span> <span class="keyword">and</span> pNode.right != <span class="literal">None</span>:</span><br><span class="line">            found = self.CreateLink(pNode.right, p, path)</span><br><span class="line">        <span class="keyword">if</span> found == <span class="literal">False</span>:</span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastCommonNode</span><span class="params">(self, path1, path2)</span>:</span></span><br><span class="line">        pLast = <span class="literal">None</span></span><br><span class="line">        index1 = <span class="number">0</span></span><br><span class="line">        index2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index1 &lt; len(path1) <span class="keyword">and</span> index2 &lt; len(path2):</span><br><span class="line">            <span class="keyword">if</span> path1[index1] == path2[index2]:</span><br><span class="line">                pLast = path1[index1]</span><br><span class="line">            index1 += <span class="number">1</span></span><br><span class="line">            index2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> pLast</span><br></pre></td></tr></table></figure></div></div><h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h4><h5 id="第一次面试："><a href="#第一次面试：" class="headerlink" title="第一次面试："></a>第一次面试：</h5><p>面试2020年1月17号， 字节跳动——大数据开发：</p><p>算法题：完全二叉树最后一个节点【完全二叉树高度】</p><p>kaggle比赛：</p><ol><li>直接使用哪些特征的平均值进行预测效果如何，为什么一定使用算法模型？</li><li>为什么用LGBM？</li><li>道路ID作用？比如利用西直门道路的数据来预测朝阳区道路的特征是否具有意义？</li><li>特征中含有的是20分位，40分位，60分位，80分位的值，预测要求的是20分位，50分位，80分位的值，如何评估模型好坏。</li><li>预测要求的是20分位，50分位，80分位的值，在这6个要预测的值中，哪个效果最差？</li><li>特征的重要程度如何评估，决策树中特征选择的标准？</li><li>如何处理数据不均衡问题的？</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考：动图来自牛客网（ &lt;a href=&quot;https://www.nowcoder.com/discuss/198840?type=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowcoder.com/discuss/1988
      
    
    </summary>
    
    
      <category term="Python算法" scheme="http://pl741.github.io/categories/Python%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法与数据结构-剑指offer" scheme="http://pl741.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>Python面试题</title>
    <link href="http://pl741.github.io/2019/11/08/Python%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://pl741.github.io/2019/11/08/Python面试题/</id>
    <published>2019-11-08T03:36:01.000Z</published>
    <updated>2019-11-12T02:43:39.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h5 id="1-列举Python中基本数据类型"><a href="#1-列举Python中基本数据类型" class="headerlink" title="1. 列举Python中基本数据类型"></a>1. 列举Python中基本数据类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">六个标准的数据类型：字符串String、数字Digit、列表List、元组Tuple、集合Sets、字典Dictionary。</span><br></pre></td></tr></table></figure><h5 id="2-区别可变数据类型和不可变数据类型"><a href="#2-区别可变数据类型和不可变数据类型" class="headerlink" title="2. 区别可变数据类型和不可变数据类型"></a>2. 区别可变数据类型和不可变数据类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">根据对象内存地址来说：</span><br><span class="line">  1. 可变数据类型：在内存地址不变的情况下，值可改变（列表和字典是可变类型，但是字典中的 key 值必须是不可变类型）</span><br><span class="line">  2. 不可变数据类型：内存改变，值也跟着改变。（数字，字符串，布尔类型，都是不可变类型）可以通过 id() 方法进行内存地址的检测。</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h5 id="1-将”hello-world”转换为首字母大写”Hello-World”"><a href="#1-将”hello-world”转换为首字母大写”Hello-World”" class="headerlink" title="1. 将”hello world”转换为首字母大写”Hello World”"></a>1. 将”hello world”转换为首字母大写”Hello World”</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：</span></span><br><span class="line">    <span class="comment"># title() 方法返回"标题化"的字符串，所有单词的首个字母转化为大写，其余字母均为小写</span></span><br><span class="line">    <span class="string">"hello world"</span>.title()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 方法二：</span></span><br><span class="line">    <span class="comment"># 分析：capitalize()将字符串的第一个字母变成大写,其他字母变小写，题目要求将两个单词的首字母都大写：</span></span><br><span class="line">    arr = <span class="string">"hello world"</span>.split(<span class="string">" "</span>)</span><br><span class="line">    new_str = <span class="string">f"<span class="subst">&#123;arr[<span class="number">0</span>].capitalize()&#125;</span> <span class="subst">&#123;arr[<span class="number">1</span>].capitalize()&#125;</span>"</span></span><br><span class="line">    print(new_str)</span><br><span class="line">    <span class="comment"># f-string，亦称为格式化字符串常量（formatted string literals），是Python3.6新引入的一种字符串格式化方法</span></span><br><span class="line">    <span class="comment"># f-string在形式上是以 f 或 F 修饰符引领的字符串（f'xxx' 或 F'xxx'），以大括号 &#123;&#125; 标明被替换的字段；</span></span><br><span class="line">    <span class="comment"># f-string在本质上并不是字符串常量，而是一个在运行时运算求值的表达式,</span></span><br><span class="line">    <span class="comment"># f-string可以解析任意类型的变量（包括字典，元组，列表，集合，数字，函数）</span></span><br></pre></td></tr></table></figure><h5 id="2-检测字符串中只含有数字"><a href="#2-检测字符串中只含有数字" class="headerlink" title="2. 检测字符串中只含有数字"></a>2. 检测字符串中<font color="red">只含</font>有数字</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过isdigit方法：</span></span><br><span class="line">s1 = <span class="string">"12332"</span>.isdigit()  <span class="comment"># Ture</span></span><br><span class="line">    s1 = <span class="string">"12334a"</span>.isdigit()   <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h5 id="3-字符串进行反转"><a href="#3-字符串进行反转" class="headerlink" title="3. 字符串进行反转"></a>3. 字符串进行反转</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：</span></span><br><span class="line"><span class="comment"># 使用字符串切片</span></span><br><span class="line">    s1 = <span class="string">"ilovechina"</span>[: : <span class="number">-1</span>]</span><br><span class="line"><span class="comment"># 方法二：</span></span><br><span class="line"><span class="comment"># reversed(seq)返回一个反转的迭代器， seq表示要转换的序列，可以是 tuple, string, list 或 range。</span></span><br><span class="line">    s2 = <span class="string">''</span>.join(reversed(<span class="string">"ilovechina"</span>))</span><br></pre></td></tr></table></figure><h5 id="4-字符串格式化方式"><a href="#4-字符串格式化方式" class="headerlink" title="4. 字符串格式化方式"></a>4. 字符串格式化方式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># “旧式”字符串解析（%操作符）</span></span><br><span class="line">    print(<span class="string">"I'm %s. I'm %d year old"</span> % (<span class="string">'Vamei'</span>, <span class="number">99</span>)</span><br><span class="line">    <span class="comment"># %s 格式说明符代表了类型为字符串；%x 把一个类型为 Int 的值转成字符串使它代表十六进制数；</span></span><br><span class="line">    print(<span class="string">"I'm %(name)s. I'm %(age)d year old"</span> % &#123;<span class="string">'name'</span>:<span class="string">'Vamei'</span>, <span class="string">'age'</span>:<span class="number">99</span>&#125;)  </span><br><span class="line">    <span class="comment"># 对格式符进行了命名。命名使用()括起来。每个命名对应词典的一个key。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 format() 来做简单的基于位置的字符串格式化</span></span><br><span class="line">    print(<span class="string">'my name is &#123;1&#125; ,age &#123;0&#125;'</span>.format(<span class="number">10</span>,<span class="string">'jack'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串插值/f-Strings(Python 3.6+)</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    b = <span class="number">10</span></span><br><span class="line">    <span class="string">f'Five plus ten is <span class="subst">&#123;a + b&#125;</span> and not <span class="subst">&#123;<span class="number">2</span> * (a + b)&#125;</span>.'</span>  <span class="comment"># 'Five plus ten is 15 and not 30.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串模板（Python标准库）</span></span><br><span class="line">    <span class="keyword">from</span> string <span class="keyword">import</span> Template</span><br><span class="line">    name = <span class="string">"Bob"</span>, errno = <span class="number">50159747054</span>     </span><br><span class="line">    Template(<span class="string">'Hey, $name!'</span>).substitute(name=name)  </span><br><span class="line">    <span class="comment"># 手动转换这个int错误号码为十六进制字符串</span></span><br><span class="line">    Template(<span class="string">'Hey $name, there is a $error error!'</span>).substitute(name=name, error=hex(errno))</span><br></pre></td></tr></table></figure><h5 id="5-字符串开头和末尾都有空格，比如“-adabdw-”，写一个函数把字符串前后空格都去掉"><a href="#5-字符串开头和末尾都有空格，比如“-adabdw-”，写一个函数把字符串前后空格都去掉" class="headerlink" title="5. 字符串开头和末尾都有空格，比如“ adabdw ”，写一个函数把字符串前后空格都去掉"></a>5. 字符串开头和末尾都有空格，比如“ adabdw ”，写一个函数把字符串前后空格都去掉</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># strip可以把它封装到函数中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strip_function</span><span class="params">(s1)</span>：</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">s1</span>.<span class="title">strip</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h5 id="6-获取字符串”123456“最后的两个字符"><a href="#6-获取字符串”123456“最后的两个字符" class="headerlink" title="6. 获取字符串”123456“最后的两个字符"></a>6. 获取字符串”123456“最后的两个字符</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切片使用的考察，最后两个即开始索引是-2</span></span><br><span class="line">a = <span class="string">'123456'</span></span><br><span class="line">print(a[<span class="number">-2</span>: ])</span><br></pre></td></tr></table></figure><h5 id="7-将一个GBK字符串S转换成UTF-8编码格式"><a href="#7-将一个GBK字符串S转换成UTF-8编码格式" class="headerlink" title="7. 将一个GBK字符串S转换成UTF-8编码格式"></a>7. 将一个GBK字符串S转换成UTF-8编码格式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"S"</span>.encode(<span class="string">'gbk'</span>).decode(<span class="string">'utf-8'</span>, <span class="string">'ignore'</span>)</span><br><span class="line"><span class="comment"># str.decode(encoding='UTF-8',errors='strict')</span></span><br><span class="line"><span class="comment"># errors -- 设置不同错误的处理方案。默认为 'strict',意为编码错误引起一个UnicodeError。 其他可能得值有 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' 以及通过 codecs.register_error() 注册的任何值。</span></span><br></pre></td></tr></table></figure><h5 id="8-1-怎样将字符串转换为小写。-2-单引号、双引号、三引号的区别？"><a href="#8-1-怎样将字符串转换为小写。-2-单引号、双引号、三引号的区别？" class="headerlink" title="8.  (1) 怎样将字符串转换为小写。 (2) 单引号、双引号、三引号的区别？"></a>8.  (1) 怎样将字符串转换为小写。 (2) 单引号、双引号、三引号的区别？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.  使用字符串的 lower() 方法。 </span><br><span class="line">2.  单独使用单引号和双引号没什么区别，但是如果引号里面还需要使用引号的时候，就需要这两个配合使用了，然后说三引号，同样的三引号也分为三单引号和三双引号，两个都可以声名长的字符串时候使用，如果使用 docstring(  文档字符串 ) 就需要使用三双引号。</span><br></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h5 id="1-已知-AList-1-2-3-1-2-，对-AList-列表元素去重，写出具体过程。"><a href="#1-已知-AList-1-2-3-1-2-，对-AList-列表元素去重，写出具体过程。" class="headerlink" title="1. 已知 AList = [1,2,3,1,2]，对 AList 列表元素去重，写出具体过程。"></a>1. 已知 AList = [1,2,3,1,2]，对 AList 列表元素去重，写出具体过程。</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">list(set(AList))</span><br></pre></td></tr></table></figure><h5 id="2-实现”1-2-3”-变成-“1”-”2”-”3”"><a href="#2-实现”1-2-3”-变成-“1”-”2”-”3”" class="headerlink" title="2. 实现”1,2,3” 变成 [“1”,”2”,”3”]"></a>2. 实现”1,2,3” 变成 [“1”,”2”,”3”]</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"1, 2, 3"</span></span><br><span class="line">print(a.split(<span class="string">","</span>))</span><br></pre></td></tr></table></figure><h5 id="3-给定两个-list，A-和-B，找出相同元素和不同元素"><a href="#3-给定两个-list，A-和-B，找出相同元素和不同元素" class="headerlink" title="3.  给定两个 list，A 和 B，找出相同元素和不同元素"></a>3.  给定两个 list，A 和 B，找出相同元素和不同元素</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A、B 中相同元素：print(set(A)&amp;set(B)) </span><br><span class="line">A、B 中不同元素：print(set(A)^set(B))</span><br></pre></td></tr></table></figure><h5 id="4-1-2-3-4-5-6-一行代码展开该列表，得出-1-2-3-4-5-6"><a href="#4-1-2-3-4-5-6-一行代码展开该列表，得出-1-2-3-4-5-6" class="headerlink" title="4. [[1,2],[3,4],[5,6]] 一行代码展开该列表，得出 [1,2,3,4,5,6]"></a>4. [[1,2],[3,4],[5,6]] 一行代码展开该列表，得出 [1,2,3,4,5,6]</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">output = [j <span class="keyword">for</span> i <span class="keyword">in</span> Input <span class="keyword">for</span> j <span class="keyword">in</span> i]  </span><br><span class="line"><span class="comment"># itertools类库</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">output = list(itertools.chain(*Input))  </span><br><span class="line"><span class="comment"># sum函数合并</span></span><br><span class="line">output = sum(Input, [])   </span><br><span class="line"><span class="comment"># reduce() 函数会对参数序列中元素进行累积。函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">output = reduce(list.__add__, Input)</span><br><span class="line"><span class="comment"># 若为numpy对象，即array或者mat，flatten()默认是按行的方向降维，可以先将列表转换成数组，降维后再tolist()</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">output = np.array(Input).flatten().tolist()</span><br></pre></td></tr></table></figure><h5 id="5-合并列表-1-5-7-9-和-2-2-6-8"><a href="#5-合并列表-1-5-7-9-和-2-2-6-8" class="headerlink" title="5. 合并列表 [1,5,7,9] 和 [2,2,6,8]"></a>5. 合并列表 [1,5,7,9] 和 [2,2,6,8]</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>], b = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line"><span class="comment"># extend方法</span></span><br><span class="line">a.extend(b)</span><br><span class="line"><span class="comment"># 直接相加</span></span><br><span class="line">c = a + b</span><br></pre></td></tr></table></figure><h5 id="6-打乱一个列表的元素"><a href="#6-打乱一个列表的元素" class="headerlink" title="6. 打乱一个列表的元素"></a>6. 打乱一个列表的元素</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">random.shuffle(a)</span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><h5 id="1-字典操作中-del-和-pop-有什么区别"><a href="#1-字典操作中-del-和-pop-有什么区别" class="headerlink" title="1.字典操作中 del 和 pop 有什么区别"></a>1.字典操作中 del 和 pop 有什么区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-按照字典的内的年龄排序"><a href="#2-按照字典的内的年龄排序" class="headerlink" title="2.按照字典的内的年龄排序"></a>2.按照字典的内的年龄排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1 = [ &#123;<span class="string">'name'</span>：<span class="string">'alice'</span>, <span class="string">'age'</span>：<span class="number">38</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>：<span class="string">'bob'</span>, <span class="string">'age'</span>：<span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>：<span class="string">'Carl'</span>, <span class="string">'age'</span>：<span class="number">28</span>&#125; ]</span><br></pre></td></tr></table></figure><h5 id="3-合并两个字典"><a href="#3-合并两个字典" class="headerlink" title="3.合并两个字典"></a>3.合并两个字典</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">"A"</span>：<span class="number">1</span>,<span class="string">"B"</span>：<span class="number">2</span>&#125;</span><br><span class="line">b = &#123;<span class="string">"C"</span>：<span class="number">3</span>,<span class="string">"D"</span>：<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="4-使用生成式的方式生成一个字典"><a href="#4-使用生成式的方式生成一个字典" class="headerlink" title="4.使用生成式的方式生成一个字典"></a>4.使用生成式的方式生成一个字典</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="5-把元组-“a”-”b”-和元组-1-2-，变为字典-“a”：1-”b”：2"><a href="#5-把元组-“a”-”b”-和元组-1-2-，变为字典-“a”：1-”b”：2" class="headerlink" title="5. 把元组 (“a”,”b”) 和元组 (1,2)，变为字典 {“a”：1,”b”：2}"></a>5. 把元组 (“a”,”b”) 和元组 (1,2)，变为字典 {“a”：1,”b”：2}</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><h5 id="1-（1）s-”info：xiaoZhang-33-shandong”，用正则切分字符串输出-‘info’-‘xiaoZhang’-‘33’-‘shandong’-。（2）a-“你好-中国-“，去除多余空格只留一个空格。"><a href="#1-（1）s-”info：xiaoZhang-33-shandong”，用正则切分字符串输出-‘info’-‘xiaoZhang’-‘33’-‘shandong’-。（2）a-“你好-中国-“，去除多余空格只留一个空格。" class="headerlink" title="1. （1）s=”info：xiaoZhang 33 shandong”，用正则切分字符串输出[‘info’, ‘xiaoZhang’, ‘33’, ‘shandong’]。（2）a = “你好 中国 “，去除多余空格只留一个空格。"></a>1. （1）s=”info：xiaoZhang 33 shandong”，用正则切分字符串输出[‘info’, ‘xiaoZhang’, ‘33’, ‘shandong’]。（2）a = “你好 中国 “，去除多余空格只留一个空格。</h5><ol><li><p>根据冒号或者空格切分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">"info：xiaoZhang 33 shandong"</span></span><br><span class="line">res = re.split(<span class="string">r": | "</span>, s)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"你好       中国"</span></span><br><span class="line">print(<span class="string">" "</span>.join(s.split()))</span><br></pre></td></tr></table></figure></li></ol><h2 id="Git面试题"><a href="#Git面试题" class="headerlink" title="Git面试题"></a>Git面试题</h2><h5 id="1-说说你知道得git命令"><a href="#1-说说你知道得git命令" class="headerlink" title="1. 说说你知道得git命令"></a>1. 说说你知道得git命令</h5><p> git init：该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件,这些文件是 Git 仓库的骨干<br> git clone url：将服务器代码下载到本地<br> git pull：将服务器的代码拉到本地进行同步，如果本地有修改会产生冲突。<br> git push：提交本地修改的代码到服务器<br> git checkout -b branch：创建并切换分支<br> git status：查看修改状态<br> git add 文件名：提交到暂存区<br> git commit -m “提交内容”：输入提交的注释内容<br> git log：查看提交的日志情况 </p><h5 id="2-git如何查看某次提交修改的内容"><a href="#2-git如何查看某次提交修改的内容" class="headerlink" title="2. git如何查看某次提交修改的内容"></a>2. git如何查看某次提交修改的内容</h5><p> 首先可以 git log 显示历史的提交列表 之后用 git show 便可以显示某次提交的修改内容 同样 git show filename 可以显示某次提交的某个内容的修改信息。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;h5 id=&quot;1-列举Python中基本数据类型&quot;&gt;&lt;a href=&quot;#1-列举Python中基本数据类型&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Python" scheme="http://pl741.github.io/categories/Python/"/>
    
    
      <category term="Python面试题" scheme="http://pl741.github.io/tags/Python%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Kaggle比赛</title>
    <link href="http://pl741.github.io/2019/11/04/Kaggle%E6%AF%94%E8%B5%9B/"/>
    <id>http://pl741.github.io/2019/11/04/Kaggle比赛/</id>
    <published>2019-11-04T02:52:20.000Z</published>
    <updated>2020-01-08T09:54:38.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GBDT回归算法"><a href="#GBDT回归算法" class="headerlink" title="GBDT回归算法"></a>GBDT回归算法</h2><p>GBDT(Gradient Boosting Decision Tree) 梯度提升决策树，是一种迭代的决策树算法，由多棵决策树组成，所有树的结果累加成最终答案，即基函数的线性组合。主要的优点：1. 在深度学习没有广泛被应用时，比赛的效果很不错；2. 即可以做分类同时也可以做回归，同时还可处理排序任务； 3. 可以筛选特征。</p><p>Boosting、Bagging和Stacking是集成学习(Ensemble Learning)的三种主要方法。Boosting是一族可将弱学习器提升为强学习器的算法，不同于Bagging、Stacking方法，Boosting训练过程为串联方式，弱学习器的训练是有顺序的，每个弱学习器都会在前一个学习器的基础上进行学习，最终综合所有学习器的预测值产生最终的预测结果。 </p><h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><p>当基学习器采用决策树时，梯度提升算法就具体到了梯度提升决策树。GBDT算法可看成是$M$棵树组成的加法模型，对应公式：</p><script type="math/tex; mode=display">F(x, w)=\sum_{m=0}^M \alpha_{m}h_{m}(x, w_{m})=\sum_{m=0}^M f_{m}(x, w_{m})</script><p>其中，$x$为输入样本，$w$为模型参数，$h$为分类回归树，$\alpha$为每棵树的权重。</p><h4 id="GBDT算法的实现过程"><a href="#GBDT算法的实现过程" class="headerlink" title="GBDT算法的实现过程"></a>GBDT算法的实现过程</h4><p>给定训练数据集：$T=\{(x_{1}, y_{i}), (x_{2}, y_{2}), \ldots, (x_{N}, y_{N})\}$，其中$x_{i} \in \chi \subseteq R^{n}$，$\chi$为输入空间，$y_{i} \in Y \subseteq R$， $Y$为输出空间，损失函数$L(y, f(x))$，找出最终的回归树$F_{M}$。</p><ol><li>初始化第一个弱学习器$F_{0}(x)$：<script type="math/tex; mode=display">F_{0}(x)=\mathop {argmin}_{c} \sum_{i=1}^N L(y_{i}, c)</script></li><li><p>建立$M$棵分类回归树：$m=1, 2, \ldots, M$</p><p>a. 对于$i=1, 2, \ldots, N$，计算第$m$棵树对应的响应值（损失函数的负梯度，即伪残差）</p><script type="math/tex; mode=display">r_{m, i}=-\left[\frac{\partial L(y_{i}, F(x_{i}))}{\partial F(x)}\right]_{F(x)=F_{m-1}(x)}</script><p>b. 对于$i=1, 2, \ldots, N$，利用CART回归树（一般选择）拟合数据$(x_{i}, r_{m, i})$，得到第$m$棵回归树，对应的叶子节点区域为$R_{m,j}$，其中$j=1, 2, \ldots, J_{m}$，同时$J_{m}$是第$m$棵回归树叶子节点的个数。</p><p>c. 对于$J_{m}$个叶子节点区域$j=1, 2, \ldots, J_{m}$，计算最佳拟合值：</p><script type="math/tex; mode=display">c_{m, j}=\mathop {argmin}_{c} \sum_{x_{i} \in R_{m, j}} L(y_{i}, F_{m-1}(x_{i}) + c)</script><p>d. 更新强学习器$F_{m}(x)$:</p><script type="math/tex; mode=display">F_{m}(x)=F_{m-1}(x) + \sum_{j=1}^{J_{m}} c_{m, j}I(x \in R_{m, j})</script></li><li><p>强学习器$F_{M}(x)$：</p><script type="math/tex; mode=display">F_{M}(x)=F_{0}(x)+\sum_{m=1}^M \sum_{j=1}^{J_{m}} c_{m, j}I(x \in R_{m, j})</script></li></ol><h3 id="GBDT基本介绍"><a href="#GBDT基本介绍" class="headerlink" title="GBDT基本介绍"></a>GBDT基本介绍</h3><p>GBDT = Regression Decistion Tree (DT)  + Gradient Boosting (GB) + Shrinkage</p><h4 id="DT：回归树"><a href="#DT：回归树" class="headerlink" title="DT：回归树"></a>DT：回归树</h4><p>决策树分为两类，回归树和分类树，GBDT核心是可以累加所有树的结果作为最终结果，因此GBDT树属于回归树 。回归树中最好分割点的衡量标准不再是最大熵（分类树的衡量标准），而是最小均方差。</p><h4 id="GB：梯度迭代"><a href="#GB：梯度迭代" class="headerlink" title="GB：梯度迭代"></a>GB：梯度迭代</h4><p>Gradient Boosting，Boosting迭代，通过迭代多棵树来共同决策，GBDT中每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量。</p><p>Boosting最大的优势在于，每一步的残差计算其实增大了分错instance的权重，使得后面的树能越来越专注于分错的instance。</p><h4 id="Shrinkage：缩减"><a href="#Shrinkage：缩减" class="headerlink" title="Shrinkage：缩减"></a>Shrinkage：缩减</h4><p>Shrinkage思想认为，每次走一小步逐渐逼近结果，要比每次一大步很快的比逼近结果更容易避免过拟合。即它不完全信任每一颗残差树，累加的时候只累加一小部分。</p><p>没用Shrinkage：其中$y_{i}$表示第$i$棵树上$y$的预测值，$y_{1-i}$表示前$i$棵树上$y$的综合预测值，</p><p>$y_{i + 1} = 残差(y_{1} \sim y_{i})$，其中：$残差(y_{1} \sim y_{i})=y_{真实值}-y_{1 \sim i}$，$y_{1  \sim  i}=SUM(y_{1}, \ldots, y_{i})$</p><p>Shrinkage中：$y_{1 \sim i}=y(1 \sim i-1)+step * y_{i}$</p><p>即Shrinkage仍然以残差作为学习目标，但对于残差学习出来的结果，只累加一小部分$（step*残差）$逐步逼近目标，step一般都比较小，如$0.01\sim 0.001$（注意该step非gradient的step） 。本质上，Shrinkage为每棵树设置一个$weight$，累加时要乘以这个$weight$， <font color="red">但和Gradient没有关系</font> 。Shrinkage实践证明可以减少过拟合。</p><h4 id="GBDT适用范围"><a href="#GBDT适用范围" class="headerlink" title="GBDT适用范围"></a>GBDT适用范围</h4><p>适用所有回归问题（线性/非线性），也可用于二分类问题（设定阈值，大于阈值为正例，反之为负例），排序</p><h4 id="关于RankNet"><a href="#关于RankNet" class="headerlink" title="关于RankNet"></a>关于RankNet</h4><p>搜索引擎排序，RankNet基本是用来定义cost function的，</p><h3 id="GBDT在Sklearn中的实现"><a href="#GBDT在Sklearn中的实现" class="headerlink" title="GBDT在Sklearn中的实现"></a>GBDT在Sklearn中的实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> GradientBoostingRegressor</span><br><span class="line">gbdt = GradientBoostingRegressor(loss=<span class="string">'ls'</span>, learning_rate=<span class="number">0.1</span>, n_estimators=<span class="number">5</span>, subsample=<span class="number">1</span></span><br><span class="line">                                 , min_samples_split=<span class="number">2</span>, min_samples_leaf=<span class="number">1</span>, max_depth=<span class="number">3</span></span><br><span class="line">                                 , init=<span class="literal">None</span>, random_state=<span class="literal">None</span>, max_features=<span class="literal">None</span></span><br><span class="line">                                 , alpha=<span class="number">0.9</span>, verbose=<span class="number">0</span>, max_leaf_nodes=<span class="literal">None</span></span><br><span class="line">                                 , warm_start=<span class="literal">False</span></span><br><span class="line">                                 )</span><br></pre></td></tr></table></figure><h3 id="GBDT回归任务中常见的损失函数"><a href="#GBDT回归任务中常见的损失函数" class="headerlink" title="GBDT回归任务中常见的损失函数"></a>GBDT回归任务中常见的损失函数</h3><p>对于GBDT回归模型，sklearn中实现了四种损失函数，有均方差’ls’, 绝对损失’lad’, Huber损失’huber’和分位数损失’quantile’。默认是均方差’ls’。一般来说，如果数据的噪音点不多，用默认的均方差’ls’比较好。如果是噪音点较多，则推荐用抗噪音的损失函数’huber’。而如果我们需要对训练集进行分段预测的时候，则采用’quantile’。 </p><ol><li><p><strong>均方差</strong>：$L(y, f(x)) = (y-f(x))^2$ 对应的负梯度误差：$y_{i}-f(x_{i})$</p></li><li><p><strong>绝对损失</strong>：$L(y, f(x))=|y-f(x)|$ 对应负梯度误差：$sign(y_{i}-f(x_{i}))$</p></li><li><p><strong>Huber损失</strong>: 均方差和绝对损失的折衷， 对于远离中心的异常点，采用绝对损失，而中心附近的点采用均方差。这个界限一般用分位数点度量。 </p><script type="math/tex; mode=display">L(y, f(x))=\begin{cases} \frac{1}{2} (y-f(x))^2, & |y - f(x)|\le \delta \\ \delta (|y-f(x)|- \frac {\delta}{2}), & |y - f(x)|\gt \delta \end{cases}</script><p>对应的负梯度误差为：</p><script type="math/tex; mode=display">r(y_{i}, f(x_{i}))=\begin{cases} y_{i}-f(x_{i}), & |y_{i} - f(x_{i})|\le \delta \\ \delta * sign(y_{i}-f(x_{i})), & |y_{i} - f(x_{i})|\gt \delta \end{cases}</script></li><li><p><strong>分位数损失</strong>： 对应的是分位数回归的损失函数 </p><script type="math/tex; mode=display">L(y, f(x))=\sum_{y \geq f(x)} \theta|y-f(x)|+\sum_{y<f(x)}(1-\theta)|y-f(x)|</script><p>其中 $ \theta $为分位数，需要指定，对应的负梯度误差为：</p><script type="math/tex; mode=display">r\left(y_{i}, f\left(x_{i}\right)\right)=\left\{\begin{array}{rl}{\theta} & {y_{i} \geq f\left(x_{i}\right)} \\ {\theta-1} & {y_{i}<f\left(x_{i}\right)}\end{array}\right.</script></li></ol><h3 id="GBDT的正则化：防止过拟合"><a href="#GBDT的正则化：防止过拟合" class="headerlink" title="GBDT的正则化：防止过拟合"></a>GBDT的正则化：防止过拟合</h3><ol><li><p><strong>Shrinkage</strong>： 在每次对残差估计进行迭代时，不直接加上当前步所拟合的残差，而是乘以一个系数$\alpha$ 学习率， 对梯度提升的步长进行调整，可以影响设置的回归树个数 。</p><p> 加上了正则化项 ：</p><script type="math/tex; mode=display">F_{m}(x)=F_{m-1}(x)+h_{m}(x)  \Rightarrow F_{m}(x)=F_{m-1}(x)+\alpha h_{m}(x)</script><p>$\alpha$的取值范围为$(0, 1]$，较小的$\alpha$ 意味着需要更多的弱学习器的迭代次数 。通常用学习率和迭代最大次数一起来决定算法的拟合效果。  经验上，推荐小一点的<code>learning_rate​</code>会对测试误差(<code>test error</code>)更好。在实际调参中推荐将<code>learning_rate</code>设置为一个小的常数（<code>e.g. learning_rate &lt;= 0.1</code>），并通过<code>early stopping</code>机制来选<code>n_estimators</code>（弱学习器个数）。 </p></li><li><p><strong>Subsample</strong> ： 通过子采样比例（subsample），取值为 (0,1] 。 这里的子采样和随机森林不一样，随机森林使用的是放回抽样，而这里是不放回抽样。如果取值为1，则全部样本都使用，等于没有使用子采样。如果取值小于1，则只有一部分样本会去做GBDT的决策树拟合。选择小于1的比例可以减少方差，即防止过拟合，但会增加样本拟合的偏差，因此取值不能太低。推荐在 [0.5, 0.8]之间。 </p><p>使用了子采样的GBDT也称作随机梯度提升树 (Stochastic Gradient Boosting Tree, SGBT)。由于使用了子采样，程序可以通过采样分发到不同的任务去做Boosting的迭代过程，最后形成新树，从而减少弱学习器难以并行学习的弱点。 </p></li><li><p><strong>对于弱学习器即CART回归树进行正则化剪枝</strong> </p></li><li><p><strong>Early</strong> <strong>Stopping</strong> ： 具体的做法是选择一部分样本作为验证集，在迭代拟合训练集的过程中，如果模型在验证集里错误率不再下降，就停止训练，控制迭代的轮数（树的个数）。在sklearn的GBDT中可以设置参数n_iter_no_change实现early stopping。 </p></li><li><p><strong>Dropout</strong> ： Dropout是deep learning里很常用的正则化技巧 ， 具体的做法是：每次新加一棵树，这棵树要拟合的并不是之前全部树ensemble后的残差，而是随机抽取的一些树ensemble；同时新加的树结果要规范化一下。 可参考： AISTATS2015有篇文章《DART: Dropouts meet Multiple Additive Regression Trees》 </p></li></ol><h3 id="有关GBDT常见面试问题"><a href="#有关GBDT常见面试问题" class="headerlink" title="有关GBDT常见面试问题"></a>有关GBDT常见面试问题</h3><h4 id="GBDT与AdaBoost的区别与联系？"><a href="#GBDT与AdaBoost的区别与联系？" class="headerlink" title="GBDT与AdaBoost的区别与联系？"></a>GBDT与AdaBoost的区别与联系？</h4><p>AdaBoost和GBDT都是重复选择一个表现一般的模型并且每次基于先前模型的表现进行调整。不同的是，AdaBoost是通过调整错分数据点的权重来改进模型，GBDT是通过计算负梯度来改进模型。因此，相比AdaBoost, GBDT可以使用更多种类的目标函数，而当目标函数是均方误差时，计算损失函数的负梯度值在当前模型的值即为残差。 </p><h4 id="GBDT与随机森林（Random-Forest，RF）的区别与联系？"><a href="#GBDT与随机森林（Random-Forest，RF）的区别与联系？" class="headerlink" title="GBDT与随机森林（Random Forest，RF）的区别与联系？"></a>GBDT与随机森林（Random Forest，RF）的区别与联系？</h4><p><strong>相同点：</strong>都是由多棵树组成，最终的结果都是由多棵树一起决定。</p><p><strong>不同点：</strong></p><ol><li>集成的方式：随机森林属于Bagging思想，而GBDT是Boosting思想。</li><li>偏差-方差权衡：RF不断的降低模型的方差，而GBDT不断的降低模型的偏差。</li><li>训练样本方式：RF每次迭代的样本是从全部训练集中有放回抽样形成的，而GBDT每次使用全部样本。</li><li>并行性：RF的树可以并行生成，而GBDT只能顺序生成(需要等上一棵树完全生成)。</li><li>最终结果：RF最终是多棵树进行多数表决（回归问题是取平均），而GBDT是加权融合。</li><li>数据敏感性：RF对异常值不敏感，而GBDT对异常值比较敏感。</li><li>泛化能力：RF不易过拟合，而GBDT容易过拟合。</li></ol><h4 id="我们知道残差-真实值-预测值，明明可以很方便的计算出来，为什么GBDT的残差要用负梯度来代替？为什么要引入麻烦的梯度？有什么用呢？"><a href="#我们知道残差-真实值-预测值，明明可以很方便的计算出来，为什么GBDT的残差要用负梯度来代替？为什么要引入麻烦的梯度？有什么用呢？" class="headerlink" title="我们知道残差=真实值-预测值，明明可以很方便的计算出来，为什么GBDT的残差要用负梯度来代替？为什么要引入麻烦的梯度？有什么用呢？"></a>我们知道残差=真实值-预测值，明明可以很方便的计算出来，为什么GBDT的残差要用负梯度来代替？为什么要引入麻烦的梯度？有什么用呢？</h4><ol><li><p>在GBDT中，无论损失函数是什么形式，每个决策树拟合的都是负梯度。准确的说，不是用负梯度代替残差，而是当损失函数是均方损失时，负梯度刚好是残差，残差只是特例。</p></li><li><p>GBDT的求解过程就是梯度下降在函数空间中的优化过程。在函数空间中优化，每次得到增量函数，这个函数就是GBDT中一个个决策树，负梯度会拟合这个函数。要得到最终的GBDT模型，只需要把初始值或者初始的函数加上每次的增量即可。参考： <a href="https://mp.weixin.qq.com/s?__biz=MzI5NDMzMjY1MA==&amp;mid=2247485110&amp;idx=1&amp;sn=86bcdb38f51fc5f82236b35c349ada4b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">梯度提升（Gradient Boosting）算法，地址：</a><a href="https://mp.weixin.qq.com/s?__biz=MzI5NDMzMjY1MA==&amp;mid=2247485110&amp;idx=1&amp;sn=86bcdb38f51fc5f82236b35c349ada4b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Ods1PHhYyjkRA8bS16OfCg</a>  </p></li></ol><h4 id="GBDT训练过程"><a href="#GBDT训练过程" class="headerlink" title="GBDT训练过程"></a>GBDT训练过程</h4><img src="/2019/11/04/Kaggle比赛/1.png"><p> GBDT通过多轮迭代,每轮迭代产生一个弱分类器，每个分类器在上一轮分类器的基础上进行训练。对弱分类器的要求一般是足够简单，并且是低方差和高偏差的。因为训练的过程是通过降低偏差来不断提高最终分类器的精度。</p><h4 id="GBDT如何选择特征？"><a href="#GBDT如何选择特征？" class="headerlink" title="GBDT如何选择特征？"></a>GBDT如何选择特征？</h4><p>GBDT选择特征的细节其实是想问CART Tree生成的过程。这里有一个前提，GBDT的弱分类器默认选择的是CART TREE。其实也可以选择其他弱分类器的，选择的前提是低方差和高偏差。框架服从boosting 框架即可。参考： 李航第五章中CART TREE 算法  </p><h4 id="GBDT如何构建特征"><a href="#GBDT如何构建特征" class="headerlink" title="GBDT如何构建特征 ?"></a>GBDT如何构建特征 ?</h4><p>其实说GBDT能够构建特征并非很准确，GBDT本身是不能产生特征的，但是可以利用GBDT去产生特征的组合。在CTR预估中，工业界一般会采用<a href="http://www.cnblogs.com/ModifyRong/p/7739955.html#3825035" target="_blank" rel="noopener">逻辑回归</a>去进行处理，逻辑回归本身是适合处理线性可分的数据，如果想让逻辑回归处理非线性的数据，其中一种方式便是组合不同特征，增强逻辑回归对非线性分布的拟合能力。</p><p>Facebook 在2014年发表的一篇论文利用GBDT去产生有效的特征组合，以便用于逻辑回归的训练，提升模型最终的效果。</p><img src="/2019/11/04/Kaggle比赛/2.png"><p>如图所示，我们 使用 GBDT 生成了两棵树，两颗树一共有五个叶子节点。我们将样本 X 输入到两颗树当中去，样本X 落在了第一棵树的第二个叶子节点，第二颗树的第一个叶子节点，于是我们便可以依次构建一个五纬的特征向量，每一个纬度代表了一个叶子节点，样本落在这个叶子节点上面的话那么值为1，没有落在该叶子节点的话，那么值为 0.</p><p>于是对于该样本，我们可以得到一个向量[0,1,0,1,0] 作为该样本的组合特征，和原来的特征一起输入到逻辑回归当中进行训练。</p><h4 id="GBDT-如何用于分类-？"><a href="#GBDT-如何用于分类-？" class="headerlink" title="GBDT 如何用于分类 ？"></a>GBDT 如何用于分类 ？</h4><p>首先明确一点，GBDT无论用于分类还是回归一直都是使用的CART回归树。不会因为任务是分类任务就选用分类树，这里面的核心是因为GBDT每轮的训练是在上一轮的训练的残差基础之上进行训练的。这里的残差就是当前模型的负梯度值 。这个要求每轮迭代的时候，弱分类器的输出的结果相减是有意义的。残差相减是有意义的。</p><p>如果选用的弱分类器是分类树，类别相减是没有意义的。上一轮输出的是样本 x 属于 A类，本一轮训练输出的是样本 x 属于 B类。 A 和 B 很多时候甚至都没有比较的意义，A 类- B类是没有意义的。</p><ol><li><p>在训练的时候，是针对样本$x$每个可能的类都训练一个分类回归树。举例说明，目前样本有三类，也就是$K = 3$。样本$x$属于第二类。那么针对该样本$x$类结果，可以用一个 三维向量$ [0,1,0] $来表示。$0$表示样本不属于该类，$1$表示样本属于该类。</p></li><li><p>针对样本有三类的情况，实质上是在每轮的训练的时候是同时训练三颗树。第一颗树针对样本$x$的第一类，输入为$(x,0)$。第二颗树输入针对样本$x$的第二类，输入为$(x,1)$。第三颗树针对样本$x$的第三类，输入为$(x，0)$。</p></li><li><p>每颗树的训练过程其实就是CATR TREE 的生成过程。参照之前的生成树的程序即可以就解出三颗树，以及三颗树对$x$类别的预测值$f_{1}(x),f_{2}(x),f_{3}(x)$。那么在此类训练中，仿照多分类的逻辑回归 ，使用softmax来产生概率，则属于类别 1 的概率：</p><script type="math/tex; mode=display">p_{1}=\exp \left(f_{1}(x)\right) / \sum_{k=1}^{3} \exp \left(f_{k}(x)\right)</script><p>针对类别1求出残差$y_{11}(x)=0−p_{1}(x)$;类别2求出残差$y_{22}(x)=1−p_{2}(x)$;类别3求出残差$y_{33}(x)=0−p_{3}(x)$。</p></li><li><p>开始第二轮训练，针对第一类输入为$(x,y_{11}(x))$, 针对第二类输入为$(x,y_{22}(x))$, 针对 第三类输入为 $(x,y_{33}(x))$，继续训练出三颗树。一直迭代M轮。每轮构建3颗树。 </p></li><li><p>当$K =3$。三个式子：</p><script type="math/tex; mode=display">F_{1 M}(x)=\sum_{m=1}^{M} \hat{C_{1 m}} I\left(x \epsilon R_{1 m}\right)</script><script type="math/tex; mode=display">F_{2 M}(x)=\sum_{m=1}^{M} \hat{C_{2 m}} I\left(x \epsilon R_{2 m}\right)</script><script type="math/tex; mode=display">F_{3 M}(x)=\sum_{m=1}^{M} \hat{C_{3 m}} I\left(x \epsilon R_{3 m}\right)</script></li><li><p>训练完毕以后，新来一个样本$x_{1}$ ，需要预测该样本的类别的时候，可以有这三个式子产生三个值，$f_{1}(x),f_{2}(x),f_{3}(x)$。样本属于 某个类别$c$的概率为 :</p><script type="math/tex; mode=display">p_{c}=\exp \left(f_{c}(x)\right) / \sum_{k=1}^{3} \exp \left(f_{k}(x)\right)</script></li></ol><h4 id="比较LR和GBDT，说说什么情景下GBDT不如LR"><a href="#比较LR和GBDT，说说什么情景下GBDT不如LR" class="headerlink" title="比较LR和GBDT，说说什么情景下GBDT不如LR"></a>比较LR和GBDT，说说什么情景下GBDT不如LR</h4><p>先说说LR和GBDT的区别：</p><ul><li>LR是线性模型，可解释性强，很容易并行化，但学习能力有限，需要大量的人工特征工程</li><li>GBDT是非线性模型，具有天然的特征组合优势，特征表达能力强，但是树与树之间无法并行训练，而且树模型很容易过拟合；</li></ul><p>当在高维稀疏特征的场景下，LR的效果一般会比GBDT好。原因如下：</p><p>先看一个例子：</p><blockquote><p>假设一个二分类问题，label为0和1，特征有100维，如果有1w个样本，但其中只有10个正样本1，而这些样本的特征 $f_{1}$的值为全为1，而其余9990条样本的$f_{1}$特征都为0(在高维稀疏的情况下这种情况很常见)。</p><p>都知道在这种情况下，树模型很容易优化出一个使用$f_{1}$特征作为重要分裂节点的树，因为这个结点直接能够将训练数据划分的很好，但是当测试的时候，却会发现效果很差，因为这个特征$f_{1}$只是刚好偶然间跟$y$拟合到了这个规律，这也是我们常说的过拟合。</p></blockquote><p>那么这种情况下，如果采用LR的话，应该也会出现类似过拟合的情况呀：$y = W_{1}<em>f_{1} + W_{i}</em>f_{i}+….$，其中 $W_{1}$特别大以拟合这10个样本。为什么此时树模型就过拟合的更严重呢？</p><p>仔细想想发现，因为现在的模型普遍都会带着正则项，而 LR 等线性模型的正则项是对权重的惩罚，也就是 $W_{1}$一旦过大，惩罚就会很大，进一步压缩 $W_{1}$的值，使其不至于过大。但是，树模型则不一样，树模型的惩罚项通常为叶子节点数和深度等，而我们都知道，对于上面这种 case，树只需要一个节点就可以完美分割9990和10个样本，一个结点，最终产生的惩罚项极其之小。</p><p>这也就是为什么在高维稀疏特征的时候，线性模型会比非线性模型好的原因了：<strong>带正则化的线性模型比较不容易对稀疏特征过拟合。</strong></p><h2 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h2><p>XGBoost是大规模并行boosting tree的工具，  Xgboost 和 GBDT 两者都是 boosting 方法，除了工程实现、解决问题上的一些差异外，最大的不同就是<font color="RED">目标函数</font>的定义 。 目前已有的 GBDT 工具基本都是基于预排序的方法（pre-sorted）的决策树算法(如 xgboost)。 </p><h3 id="数学推导-1"><a href="#数学推导-1" class="headerlink" title="数学推导"></a>数学推导</h3><img src="/2019/11/04/Kaggle比赛/6.png"><h4 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h4><p>  XGBoost 是由 $k$ 个基模型组成的一个加法运算式，其中$f_{k}$为第$k$个基模型，$\hat{y}_{i}$为第$i$个样本的预测值：</p><script type="math/tex; mode=display">\hat{y}_{i}=\sum_{t=1}^{k} f_{t}\left(x_{i}\right)</script><p>损失函数可由预测值$\hat{y}_{i}$与真实值$y_{i}$进行表示，其中$n$为样本数量：</p><script type="math/tex; mode=display">L=\sum_{i=1}^n l(y_{i}, \hat{y_{i}})</script><p>常见的损失函数：</p><ol><li>平方损失函数：$l(y_{i}, \hat{y}_{i}) = (y_{i}-\hat{y}_{i})^2$</li><li>逻辑回归损失函数：$l(y_{i}, \hat{y}_{i})=y_{i}ln(1+e^{-\hat{y}_{i}})+(1-y_{i})ln(1+e^{\hat{y}_{i}})$</li></ol><font color="red"> 模型的预测精度由模型的偏差和方差共同决定，损失函数代表了模型的偏差，方差小需要简单的模型 </font>，目标函数由模型的损失函数 $L$ 与抑制模型复杂度的正则项 $ \Omega $ 组成 ：$$O b j=\sum_{i=1}^{n} l\left(\hat{y}_{i}, y_{i}\right)+\sum_{t=1}^{k} \Omega\left(f_{t}\right)$$由于Boosting模型是前向加法， 以第 $t$ 个的模型为例，模型对第 $i$个样本 $x_{i}$的预测为： $$\hat{y}_{i}^{t}=\hat{y}_{i}^{t-1}+f_{t}\left(x_{i}\right)$$其中 $\hat{y}_{i}^{t-1}$ 由第 $t-1$ 步的模型（第 $t-1$ 棵树）给出的预测值，$f_{t}(x_{i})$是新加入模型的预测值，此时的目标函数可写成：$$\begin{aligned} O b j^{(t)} &=\sum_{i=1}^{n} l\left(y_{i}, \hat{y}_{i}^{t}\right)+\sum_{i=1}^{t} \Omega\left(f_{i}\right) \\ &=\sum_{i=1}^{n} l\left(y_{i}, \hat{y}_{i}^{t-1}+f_{t}\left(x_{i}\right)\right)+ \Omega(f_{t}) +\sum_{i=1}^{t-1} \Omega\left(f_{i}\right) \\ &=\sum_{i=1}^{n} l\left(y_{i}, \hat{y}_{i}^{t-1}+f_{t}\left(x_{i}\right)\right)+ \Omega(f_{t}) + const \end{aligned}$$将正则化项进行拆分，由于前 $t-1$ 棵树的结构已经确定，因此，前 $t-1$ 棵树的复杂度之和可以用一个常量 $const$ 表示。 注意到上式中只有一个变量，即第 $t$ 棵树模型的$f_{t}(x_{i})$，最优化目标函数，就相当于求解  $f_{t}(x_{i})$ 。<br><h4>泰勒公式</h4> 将一个在 $x = x0$ 处具有 $n$ 阶导数的函数 $f(x)$ 利用关于 $(x-x_{0})$ 的 $n$ 次多项式来逼近。 若函数 $f(x)$ 在包含 $x_{0}$ 的某个闭区间 $[a, b]$ 上具有 $n$ 阶导数，且在开区间 $(a,b)$ 上具有 $n+1$ 阶导数，则对闭区间  $[a, b]$ 上任意一点 $x$ 有：$$f(x)=\sum_{i=0}^{n} \frac{f^{(i)}\left(x_{0}\right)}{i !}\left(x-x_{0}\right)^{i}+R_{n}(x)$$其中的多项式称为函数在 $x_{0}$处的泰勒展开式，$R_{n}(x)$ 是泰勒公式的余项，且是 $(x-x_{0})^n$ 的高阶无穷小。函数 $f(x+ \Delta x)$ 在点 $x$ 处进行泰勒公式的二阶展开，形式如下： $$f(x+\Delta x) \simeq f(x)+f^{\prime}(x) \Delta x+\frac{1}{2} f^{\prime \prime}(x) \Delta x^{2}$$将损失函数 $l$ 视为上式的 $f(x)$ ，将 $\hat{y}_{i}^{t-1}$ 视为 $x$，将 $f_{t}(x_{i})$ 视为 $\Delta x$，定义损失函数 $l$ 关于 $\hat{y}_{i}^{t-1}$ 的一阶偏导数和二阶偏导数：$$g_{i}= \frac {\partial l(y_{i}, \hat{y}^{t-1})}{\partial {\hat{y}^{t-1}}}\\h_{i}=\frac {\partial^{2} l(y_{i}, \hat{y}^{t-1})}{\partial {\hat{y}^{t-1}}}$$损失函数可以表示成如下形式：$$l \left (y_{i}, \hat{y}_{i}^{t-1}+f_{t}(x_{i}) \right)=l(y_{i}, \hat{y}_{i}^{t-1})+g_{i}f_{t}(x_{i})+\frac{1}{2}h_{i}f_{t}^{2}(x_{i})$$由此可以得到目标函数的近似表达式：$$Obj^{(t)} \simeq \sum_{i=1}^{n}\left[ l(y_{i}, \hat{y}_{i}^{t-1})+g_{i}f_{t}(x_{i})+\frac{1}{2}h_{i}f_{t}^{2}(x_{i})\right]+\Omega (f_{t})+const$$由于在第 $t$ 步时 $\hat{y}_{i}^{t-1}$ 已知，所以 $l(y_{i}, \hat{y}_{i}^{t-1})$ 和$const$是一个常量，因此优化目标可写成：$$Obj^{(t)} \simeq \sum_{i=1}^{n}\left[g_{i}f_{t}(x_{i})+\frac{1}{2}h_{i}f_{t}^{2}(x_{i})\right]+\Omega (f_{t})$$ 只需要求出每一步损失函数的一阶导和二阶导的值（由于前一步的 $\hat{y}_{i}^{t-1}$ 是已知的，所以这两个值就是常数），然后最优化目标函数，就可以得到每一步的 $f(x)$ ，最后根据加法模型得到一个整体模型。 <br><h4>基于决策树的目标函数</h4>XGBoost的基模型不仅支持决策树，还支持线性模型。以下主要介绍基于决策树的目标函数。定义一棵树：1. 叶子结点的权重向量 $\omega$2. 实例  —>  叶子结点的映射关系 $q$决策树的表达式：$$f_{t}(x)=w_{q(x)},     w \in \boldsymbol R^{T},q:\boldsymbol R^{d} \to{1, 2, \cdots ,T}$$其中 $x$ 为某一样本, $w$ 是长度为 $T$ 的一维向量，$T$ 代表树的叶子结点的个数，代表树 $q$ 各叶子结点的权重，$q$ 代表了一棵树的结构，将输入 $x_{i}\in \boldsymbol R^{d}$ 映射到某叶子结点， $q(x)$ 代表了该样本在哪个叶子结点上，$w_{q}$ 表示叶子结点取值 $\omega$，$\omega_{q(x)}$ 代表了每个样本的取值 $w$。决策树的复杂度可由叶子数 $T$ 组成，叶子结点越少模型越简单，此外叶子结点也不应该含有过高的权重 $w$ （类比 LR 的每个变量的权重），由此可定义一棵树的复杂度 $\Omega$（即目标函数的正则化项）：$$\Omega\left(f_{t}\right)=\gamma T+\frac{1}{2} \lambda \sum_{j=1}^{T} w_{j}^{2}$$即决策树模型的复杂度由叶子结点数量 + 叶子结点权重向量的$L2$范数共同决定。 将属于第 $j$ 个叶子结点的所有样本 $x_{i}$ , 划入到一个叶子结点样本集中，数学表示如下： $$I_{j}=\left\{i | q\left(x_{i}\right)=j\right\}$$目标函数可写成如下式子：$$\begin{aligned} O b j^{(t)} & \simeq \sum_{i=1}^{n}\left[g_{i} f_{t}\left(x_{i}\right)+\frac{1}{2} h_{i} f_{t}^{2}\left(x_{i}\right)\right]+\Omega\left(f_{t}\right) \\ &=\sum_{i=1}^{n}\left[g_{i} w_{q\left(x_{i}\right)}+\frac{1}{2} h_{i} w_{q\left(x_{i}\right)}^{2}\right]+\gamma T+\frac{1}{2} \lambda \sum_{j=1}^{T} w_{j}^{2} \\ &=\sum_{j=1}^{T}\left[\left(\sum_{i \in I_{j}} g_{i}\right) w_{j}+\frac{1}{2}\left(\sum_{i \in I_{j}} h_{i}+\lambda\right) w_{j}^{2}\right]+\gamma T \end{aligned} 将训练样本按叶子结点进行分组$$ 第二步到第三步：第二步是遍历所有的样本后求每个样本的损失函数，但样本最终会落在叶子节点上，所以我们也可以遍历叶子节点，然后获取叶子节点上的样本集合，最后再求损失函数。即之前样本的集合，现在都改写成叶子结点的集合，由于一个叶子结点有多个样本存在，因此才有了 $\sum_{i \in I_{j}} g_{i}$ 和 $\sum_{i \in I_{j}} h_{i}$ 这两项， $w_{j}$为第 $j$ 个叶子节点取值。 进一步简化表达式，定义：$$G_{j} = \sum_{i \in I_{j}} g_{i}, \ H_{j} = \sum_{i \in I_{j}} h_{i}\\$$- $G_{j}$ ：叶子结点 $j$ 所包含样本的一阶偏导数累加之和，是一个常量；<br>- $H_{j}$ ：叶子结点 $j$ 所包含样本的二阶偏导数累加之和，是一个常量；<br>最终的目标函数：$$O b j^{(t)}=\sum_{j=1}^{T}\left[G_{j} w_{j}+\frac{1}{2}\left(H_{j}+\lambda\right) w_{j}^{2}\right]+\gamma T$$此时表达式中只有第 $t$ 棵树的叶子结点权重$w_{j}$是未知量，一元二次函数变量一阶导为$0$的点为最值点（$y=ax^{2}+bx+c$，如果$a>0$，为最小值，若$a<0$为最大值）， 分析一下目标函数$obj$，可以发现，各个叶子结点的目标子式是相互独立的，也就是说，当每个叶子结点的子式都达到最值点时，整个目标函数式$obj$才达到最值点。 将目标函数对 $w_{j}$ 求一阶导，并令其等于 $0$ ，则可以求得叶子结点 $j$ 对应的权值：<br>$$w_{j}^{*}=-\frac{G_{j}}{H_{j}+\lambda}$$目标函数可以化简为：<br>$$O b j=-\frac{1}{2} \sum_{j=1}^{T} \frac{G_{j}^{2}}{H_{j}+\lambda}+\gamma T$$<h4>最优切分点划分算法</h4>  在决策树的生长过程中，一个非常关键的问题是如何找到叶子节点的最优切分点，XGBoost 支持两种分裂节点的方法——贪心算法和近似算法。 <h5>贪心算法 / 全局扫描法</h5>  从深度为 0 的树开始：1. 对树中的每个叶子结点尝试进行分裂；2. 每次分裂后，原来的一个叶子结点继续分裂为左右两个子叶子结点，原叶子结点中的样本集将根据该结点的判断规则分散到左右两个叶子结点中；3. 新分裂一个结点后，我们需要检测这次分裂是否会给损失函数带来增益假设在某一节点完成特征分裂，则分裂前的目标函数可以写为：$$O b j_{L+R}=-\frac{1}{2} \frac{\left(G_{L}+G_{R}\right)^{2}}{H_{L}+H_{R}+\lambda}+\gamma$$ 分裂后的目标函数为： $$O b j_{L}+O b j_{R}=-\frac{1}{2}\left[\frac{G_{L}^{2}}{H_{L}+\lambda}+\frac{G_{R}^{2}}{H_{R}+\lambda}\right]+2 \gamma$$ 目标函数来说，每个特征分裂后的收益（ 该特征收益也可作为特征重要性输出的重要依据 ）：$$\begin{aligned} \text {Gain} &=O b j_{L+R}-\left(O b j_{L}+O b j_{R}\right) \\ &=\left[-\frac{1}{2} \frac{\left(G_{L}+G_{R}\right)^{2}}{H_{L}+H_{R}+\lambda}+\gamma\right]-\left[-\frac{1}{2}\left(\frac{G_{L}^{2}}{H_{L}+\lambda}+\frac{G_{R}^{2}}{H_{R}+\lambda}\right)+2 \gamma\right] \\ &=\frac{1}{2}\left[\frac{G_{L}^{2}}{H_{L}+\lambda}+\frac{G_{R}^{2}}{H_{R}+\lambda}-\frac{\left(G_{L}+G_{R}\right)^{2}}{H_{L}+H_{R}+\lambda}\right]-\gamma \end{aligned}$$增益$Gain>0$，即分裂为两个叶子节点后，目标函数下降了，会考虑此次分裂的结果。但是，在一个结点分裂时，可能有很多个分裂点，每个分裂点都会产生一个增益，如何才能寻找到最优的分裂点呢？ <br>寻找最佳分割点的大致步骤如下： <br>1. 对每个叶节点枚举所有的可用特征（遍历每个结点的所有特征 ）；<br>2. 针对每个特征，把属于该节点的训练样本根据该特征值进行升序排列，通过线性扫描的方式来决定该特征的最佳分裂点，并记录该特征的分裂收益；<br>3. 选择收益最大的特征作为分裂特征，用该特征的最佳分裂点作为分裂位置，在该节点上分裂出左右两个新的叶节点，并为每个新节点关联对应的样本集<br>4. 回到第 1 步，递归执行到满足特定条件为止<br><h5>近似算法</h5>当数据量过大导致内存无法一次载入或者在分布式情况下，贪心算法的效率就会变得很低，全局扫描法不再适用。 基于此，XGBoost提出了一系列加快寻找最佳分裂点的方案： <br>- **特征预排序+缓存：**XGBoost在训练之前，预先对每个特征按照特征值大小进行排序，然后保存为block结构， 并在每个块结构中都采用了稀疏矩阵存储格式（Compressed Sparse Columns Format，CSC）进行存储， 后面的迭代中会重复地使用这个结构，使计算量大大减小。<br>  - 特征预排序：每一个块结构包括一个或多个已经排序好的特征；缺失特征值将不进行排序；每个特征会存储指向样本梯度统计值的索引，方便计算一阶导和二阶导数值；<br>    <img src="/2019/11/04/Kaggle比赛/5.png">  - 缓存访问优化算法：块结构的设计可以减少节点分裂时的计算量，但特征值通过索引访问样本梯度统计值的设计会导致访问操作的内存空间不连续，这样会造成缓存命中率低，从而影响到算法的效率。为了解决缓存命中率低的问题，XGBoost 提出了缓存访问优化算法：为每个线程分配一个连续的缓存区，将需要的梯度信息存放在缓冲区中，这样就是实现了非连续空间到连续空间的转换，提高了算法效率。此外适当调整块大小，也可以有助于缓存优化。<br>- **"核外"快计算：**当数据量过大时无法将数据全部加载到内存中，只能先将无法加载到内存中的数据暂存到硬盘中，直到需要时再进行加载计算，而这种操作必然涉及到因内存与硬盘速度不同而造成的资源浪费和性能瓶颈。为了解决这个问题，XGBoost 独立一个线程专门用于从硬盘读入数据，以实现处理数据和读入数据同时进行。<br>  此外，XGBoost 还用了两种方法来降低硬盘读写的开销：<br>  - 块压缩：对 Block 进行按列压缩，并在读取时进行解压；<br>  - 块拆分：将每个块存储到不同的磁盘中，从多个磁盘读取可以增加吞吐量。<br>- 分位点近似法：对每个特征按照特征值排序后，采用类似分位点选取的方式，仅仅选出常数个特征值作为该特征的候选分割点，在寻找该特征的最佳分割点时，从候选分割点中选出最优的一个。<br>- 并行查找：由于各个特性已预先存储为block结构，XGBoost支持利用多个线程并行地计算每个特征的最佳分割点，这不仅大大提升了结点的分裂速度，也极利于大规模训练集的适应性扩展。<br>该算法会首先根据特征分布的分位数提出候选划分点，然后将连续型特征映射到由这些候选点划分的桶中，然后聚合统计信息找到所有区间的最佳分裂点。<br>在提出候选切分点时有两种策略：<br>- Global：学习每棵树前就提出候选切分点，并在每次分裂时都采用这种分割；<br>- Local：每次分裂前将重新提出候选切分点。<br>直观上来看，Local 策略需要更多的计算步骤，而 Global 策略因为节点没有划分所以需要更多的候选点。<br>事实上， XGBoost 不是简单地按照样本个数进行分位，而是以二阶导数值 $h_{i}$ 作为样本的权重进行划分：<br>1. 按照样本个数进行分位，三分位为例：   <img src="/2019/11/04/Kaggle比赛/3.png">2.  以二阶导数值 $h_{i}$ 作为样本的权重进行划分:   <img src="/2019/11/04/Kaggle比赛/4.png">为什么要用 $h_{i}$ 进行样本加权：<br>模型的目标函数为： $$Obj^{(t)} \simeq \sum_{i=1}^{n}\left[g_{i}f_{t}(x_{i})+\frac{1}{2}h_{i}f_{t}^{2}(x_{i})\right]+\Omega (f_{t})$$稍作整理，便可以看出 $h_{i}$ 有对 loss 加权的作用：<br>$$\begin{aligned} O b j^{(t)} & \approx \sum_{i=1}^{n}\left[g_{i} f_{t}\left(x_{i}\right)+\frac{1}{2} h_{i} f_{t}^{2}\left(x_{i}\right)\right]+\sum_{i=1}^{t} \Omega\left(f_{i}\right) \\ &=\sum_{i=1}^{n}\left[g_{i} f_{t}\left(x_{i}\right)+\frac{1}{2} h_{i} f_{t}^{2}\left(x_{i}\right)  + \frac{1}{2} \frac{g_{i}^{2}}{h_{i}}\right]+\Omega\left(f_{t}\right)+const \\ &=\sum_{i=1}^{n} \frac{1}{2} h_{i}\left[f_{t}\left(x_{i}\right)-\left(-\frac{g_{i}}{h_{i}}\right)\right]^{2}+\Omega\left(f_{t}\right)+const \end{aligned}$$其中 $h_{i}$ 与 $const$ 皆为常数。可以看到 $h_{i}$ 就是平方损失函数中样本的权重。 <font color="red">[不是很懂]</font><h5 id="树停止生长"><a href="#树停止生长" class="headerlink" title="树停止生长"></a>树停止生长</h5><ol><li>当新引入的一次分裂所带来的增益 $Gain&lt;0$ 时，放弃当前的分裂。这是训练损失和模型结构复杂度的博弈过程。 </li><li>当树达到最大深度时，停止建树，因为树的深度太深容易出现过拟合，这里需要设置一个超参数 max_depth。 </li><li>当引入一次分裂后，重新计算新生成的左、右两个叶子结点的样本权重和。如果任一个叶子结点的样本权重低于某一个阈值，也会放弃此次分裂。这涉及到一个超参数：最小样本权重和，是指如果一个叶子节点包含的样本数量太少也会放弃分裂，防止树分的太细，这也是过拟合的一种措施。 </li></ol><h3 id="稀疏感知算法"><a href="#稀疏感知算法" class="headerlink" title="稀疏感知算法"></a>稀疏感知算法</h3><p>XGBoost 在决策树应对数据缺失时给出的分裂策略，XGBoost 在构建树的节点过程中只考虑非缺失值的数据遍历，而为每个节点增加了一个缺省方向，当样本相应的特征值缺失时，可以被归类到缺省方向上，最优的缺省方向可以从数据中学到。至于如何学到缺省值的分支，其实很简单，分别枚举特征缺省的样本归为左右分支后的增益，选择增益最大的枚举项即为最优缺省方向。</p><p>在构建树的过程中需要枚举特征缺失的样本，乍一看该算法的计算量增加了一倍，但其实该算法在构建树的过程中只考虑了特征未缺失的样本遍历，而特征值缺失的样本无需遍历只需直接分配到左右节点，故算法所需遍历的样本量减少。</p><h3 id="算法优缺点"><a href="#算法优缺点" class="headerlink" title="算法优缺点"></a>算法优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>精度更高：GBDT 只用到一阶泰勒展开，而 XGBoost  对损失函数进行了二阶泰勒展开。XGBoost 引入二阶导一方面是为了增加精度，另一方面也是为了能够自定义损失函数，二阶泰勒展开可以近似大量损失函数；</li><li>灵活性更强：GBDT 以 CART 作为基分类器，XGBoost 不仅支持 CART 还支持线性分类器，（使用线性分类器的 XGBoost 相当于带 L1 和 L2 正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题））。此外，XGBoost 工具支持自定义损失函数，只需函数支持一阶和二阶求导；</li><li>正则化：XGBoost 在目标函数中加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、叶子节点权重的 L2 范式。正则项降低了模型的方差，使学习出来的模型更加简单，有助于防止过拟合；</li><li>Shrinkage（缩减）：相当于学习速率。XGBoost 在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间；</li><li>列抽样：XGBoost 借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算；</li><li>缺失值处理：XGBoost 采用的稀疏感知算法极大的加快了节点分裂的速度；</li><li>可以并行化操作：块结构可以很好的支持并行计算。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>虽然利用预排序和近似算法可以降低寻找最佳分裂点的计算量，但在节点分裂过程中仍需要遍历数据集；</li><li>预排序过程的空间复杂度过高，不仅需要存储特征值，还需要存储特征对应样本的梯度统计值的索引，相当于消耗了两倍的内存。</li></ol><h3 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h3><h4 id="XGB与GBDT、随机森林等模型相比，有什么优缺点"><a href="#XGB与GBDT、随机森林等模型相比，有什么优缺点" class="headerlink" title="XGB与GBDT、随机森林等模型相比，有什么优缺点?"></a>XGB与GBDT、随机森林等模型相比，有什么优缺点?</h4><p>   与GBDT模型相比：</p><ul><li><strong>基分类器</strong>：XGBoost的基分类器不仅支持CART决策树，还支持线性分类器，此时XGBoost相当于带L1和L2正则化项的Logistic回归（分类问题）或者线性回归（回归问题）。</li><li><strong>导数信息</strong>：XGBoost对损失函数做了二阶泰勒展开，GBDT只用了一阶导数信息，并且XGBoost还支持自定义损失函数，只要损失函数一阶、二阶可导。</li><li><strong>正则项</strong>：XGBoost的目标函数加了正则项， 相当于预剪枝，使得学习出来的模型更加不容易过拟合。</li><li><strong>列抽样</strong>：XGBoost支持列采样，与随机森林类似，用于防止过拟合。</li><li><strong>缺失值处理</strong>：对树中的每个非叶子结点，XGBoost可以自动学习出它的默认分裂方向。如果某个样本该特征值缺失，会将其划入默认分支。</li><li><strong>并行化</strong>：注意不是tree维度的并行，而是特征维度的并行。XGBoost预先将每个特征按特征值排好序，存储为块结构，分裂结点时可以采用多线程并行查找每个特征的最佳分割点，极大提升训练速度。</li></ul><h4 id="XGB为什么可以并行训练？"><a href="#XGB为什么可以并行训练？" class="headerlink" title="XGB为什么可以并行训练？"></a>XGB为什么可以并行训练？</h4><ul><li>XGBoost的并行，并不是说每棵树可以并行训练，XGB本质上仍然采用boosting思想，每棵树训练前需要等前面的树训练完成才能开始训练。</li><li>XGBoost的并行，指的是特征维度的并行：在训练之前，每个特征按特征值对样本进行预排序，并存储为Block结构，在后面查找特征分割点时可以重复使用，而且特征已经被存储为一个个block结构，那么在寻找每个特征的最佳分割点时，可以利用多线程对每个block并行计算。</li></ul><h4 id="XGB用二阶泰勒展开的优势在哪？"><a href="#XGB用二阶泰勒展开的优势在哪？" class="headerlink" title="XGB用二阶泰勒展开的优势在哪？"></a>XGB用二阶泰勒展开的优势在哪？</h4><ul><li><strong>精准性</strong>：相对于GBDT的一阶泰勒展开，XGBoost采用二阶泰勒展开，可以更为精准的逼近真实的损失函数</li><li><strong>可扩展性</strong>：损失函数支持自定义，只需要新的损失函数二阶可导。</li></ul><h4 id="XGB为了防止过拟合，进行了哪些设计？"><a href="#XGB为了防止过拟合，进行了哪些设计？" class="headerlink" title="XGB为了防止过拟合，进行了哪些设计？"></a>XGB为了防止过拟合，进行了哪些设计？</h4><p>XGBoost在设计时，为了防止过拟合做了很多优化，具体如下：</p><ul><li><strong>目标函数添加正则项</strong>：叶子节点个数+叶子节点权重的L2正则化</li><li><strong>列抽样</strong>：训练的时候只用一部分特征（不考虑剩余的block块即可）</li><li><strong>子采样</strong>：每轮计算可以不使用全部样本，使算法更加保守</li><li><strong>shrinkage</strong>: 可以叫学习率或步长，为了给后面的训练留出更多的学习空间</li></ul><h4 id="XGB如何处理缺失值？"><a href="#XGB如何处理缺失值？" class="headerlink" title="XGB如何处理缺失值？"></a>XGB如何处理缺失值？</h4><p>XGBoost模型的一个优点就是允许特征存在缺失值。对缺失值的处理方式如下：</p><ul><li>在特征$k$上寻找最佳 split point 时，不会对该列特征 missing 的样本进行遍历，而只对该列特征值为 non-missing 的样本上对应的特征值进行遍历，通过这个技巧来减少了为稀疏离散特征寻找 split point 的时间开销。</li><li>在逻辑实现上，为了保证完备性，会将该特征值 missing 的样本分别分配到左叶子结点和右叶子结点，两种情形都计算一遍后，选择分裂后增益最大的那个方向（左分支或是右分支），作为预测时特征值缺失样本的默认分支方向。</li><li>如果在训练中没有缺失值而在预测中出现缺失，那么会自动将缺失值的划分方向放到右子结点。</li></ul><h4 id="为什么XGBoost相比某些模型对缺失值不敏感"><a href="#为什么XGBoost相比某些模型对缺失值不敏感" class="headerlink" title="为什么XGBoost相比某些模型对缺失值不敏感"></a>为什么XGBoost相比某些模型对缺失值不敏感</h4><p>对存在缺失值的特征，一般的解决方法是：</p><ul><li>离散型变量：用出现次数最多的特征值填充；</li><li>连续型变量：用中位数或均值填充；</li></ul><p>一些模型如SVM和KNN，其模型原理中涉及到了对样本距离的度量，如果缺失值处理不当，最终会导致模型预测效果很差。而树模型对缺失值的敏感度低，大部分时候可以在数据缺失时使用。原因就是，一棵树中每个结点在分裂时，寻找的是某个特征的最佳分裂点（特征值），完全可以不考虑存在特征值缺失的样本，也就是说，如果某些样本缺失的特征值缺失，对寻找最佳分割点的影响不是很大。</p><p>XGBoost对缺失数据有特定的处理方法，因此，对于有缺失值的数据在经过缺失处理后：</p><ul><li>当数据量很小时，优先用朴素贝叶斯</li><li>数据量适中或者较大，用树模型，优先XGBoost</li><li>数据量较大，也可以用神经网络</li><li>避免使用距离度量相关的模型，如KNN和SVM</li></ul><h4 id="XGB如何分裂一个结点？如何选择特征？"><a href="#XGB如何分裂一个结点？如何选择特征？" class="headerlink" title="XGB如何分裂一个结点？如何选择特征？"></a>XGB如何分裂一个结点？如何选择特征？</h4><p>XGBoost在训练前预先将特征按照特征值进行了排序，并存储为block结构，以后在结点分裂时可以重复使用该结构。因此，可以采用特征并行的方法利用多个线程分别计算每个特征的最佳分割点，根据每次分裂后产生的增益，最终选择增益最大的那个特征的特征值作为最佳分裂点。</p><p>如果在计算每个特征的最佳分割点时，对每个样本都进行遍历，计算复杂度会很大，这种全局扫描的方法并不适用大数据的场景。XGBoost还提供了一种近似算法，对特征排序后仅选择常数个候选分裂位置作为候选分裂点，极大提升了结点分裂时的计算效率。</p><h4 id="XGB中一颗树停止生长的条件有哪些？"><a href="#XGB中一颗树停止生长的条件有哪些？" class="headerlink" title="XGB中一颗树停止生长的条件有哪些？"></a>XGB中一颗树停止生长的条件有哪些？</h4><ul><li>当新引入的一次分裂所带来的增益Gain&lt;0时，放弃当前的分裂。这是训练损失和模型结构复杂度的博弈过程。</li><li>当树达到最大深度时，停止建树，因为树的深度太深容易出现过拟合，这里需要设置一个超参数max_depth。</li><li>当引入一次分裂后，重新计算新生成的左、右两个叶子结点的样本权重和。如果任一个叶子结点的样本权重低于某一个阈值，也会放弃此次分裂。这涉及到一个超参数:最小样本权重和，是指如果一个叶子节点包含的样本数量太少也会放弃分裂，防止树分的太细。</li></ul><h4 id="XGB叶子结点的权重有什么含义？如何计算？"><a href="#XGB叶子结点的权重有什么含义？如何计算？" class="headerlink" title="XGB叶子结点的权重有什么含义？如何计算？"></a>XGB叶子结点的权重有什么含义？如何计算？</h4><p>XGBoost目标函数最终推导形式如下：</p><script type="math/tex; mode=display">O b j^{(t)}=\sum_{j=1}^{T}\left[G_{j} w_{j}+\frac{1}{2}\left(H_{j}+\lambda\right) w_{j}^{2}\right]+\gamma T</script><p>利用一元二次函数求最值的知识，当目标函数达到最小值$Obj^{<em>}$时，每个叶子结点的权重为$w_{j}^{</em>}$。</p><p>具体公式如下：</p><script type="math/tex; mode=display">w_{j}^{*}=-\frac{G_{j}}{H_{j}+\lambda} \quad, \quad O b j=-\frac{1}{2} \sum_{j=1}^{T} \frac{G_{j}^{2}}{H_{j}+\lambda}+\gamma T</script><h4 id="训练一个XGB模型，经历了哪些过程？调参步骤是什么？"><a href="#训练一个XGB模型，经历了哪些过程？调参步骤是什么？" class="headerlink" title="训练一个XGB模型，经历了哪些过程？调参步骤是什么？"></a>训练一个XGB模型，经历了哪些过程？调参步骤是什么？</h4><p>首先需要初始化一些基本变量，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- max_depth = 5</span><br><span class="line">- min_child_weight = 1</span><br><span class="line">- gamma = 0</span><br><span class="line">- subsample, colsample_bytree = 0.8</span><br><span class="line">- scale_pos_weight = 1</span><br></pre></td></tr></table></figure><p>(1) 确定learning rate和estimator的数量</p><p>&emsp;&emsp;learning rate可以先用0.1，用cv来寻找最优的estimators</p><p>(2) max_depth和 min_child_weight</p><p>&emsp;&emsp;调整这两个参数是因为，这两个参数对输出结果的影响很大。首先将这两个参数设置为较大的数，然后通过迭代的方式不断修正，缩小范围。</p><p>&emsp;&emsp;max_depth，每棵子树的最大深度，check from range(3,10,2)。</p><p>&emsp;&emsp;min_child_weight，子节点的权重阈值，check from range(1,6,2)。</p><p>&emsp;&emsp;如果一个结点分裂后，它的所有子节点的权重之和都大于该阈值，该叶子节点才可以划分。</p><p>(3) gamma</p><p>&emsp;&emsp;也称作最小划分损失<code>min_split_loss</code>，check from 0.1 to 0.5，指的是，对于一个叶子节点，当对它采取划分之后，损失函数的降低值的阈值。</p><ul><li>如果大于该阈值，则该叶子节点值得继续划分</li><li>如果小于该阈值，则该叶子节点不值得继续划分</li></ul><p>(4) subsample, colsample_bytree</p><p>&emsp;&emsp;subsample是对训练的采样比例</p><p>&emsp;&emsp;colsample_bytree是对特征的采样比例</p><p>&emsp;&emsp;both check from 0.6 to 0.9</p><p>(5) 正则化参数</p><p>&emsp;&emsp;$alpha$ 是L1正则化系数，try $1e-5, 1e-2, 0.1, 1, 100$</p><p>&emsp;&emsp;$lambda$ 是L2正则化系数</p><p>(6) 降低学习率</p><p>&emsp;&emsp;降低学习率的同时增加树的数量，通常最后设置学习率为$0.01~0.1$</p><h4 id="XGB如何给特征评分？"><a href="#XGB如何给特征评分？" class="headerlink" title="XGB如何给特征评分？"></a>XGB如何给特征评分？</h4><p> 采用三种方法来评判XGBoost模型中特征的重要程度： </p><ul><li><strong>weight</strong> ：该特征在所有树中被用作分割样本的特征的总次数。</li><li><strong>gain</strong> ：该特征在其出现过的所有树中产生的平均增益。</li><li><strong>cover</strong> ：该特征在其出现过的所有树中的平均覆盖范围。</li></ul><blockquote><p>注意：覆盖范围这里指的是一个特征用作分割点后，其影响的样本数量，即有多少样本经过该特征分割到两个子节点。</p></blockquote><h4 id="XGBoost如何处理不平衡数据"><a href="#XGBoost如何处理不平衡数据" class="headerlink" title="XGBoost如何处理不平衡数据"></a>XGBoost如何处理不平衡数据</h4><p>对于不平衡的数据集，例如用户的购买行为，肯定是极其不平衡的，这对XGBoost的训练有很大的影响，XGBoost有两种自带的方法来解决：</p><p>第一种，如果你在意AUC，采用AUC来评估模型的性能，那你可以通过设置<em>scale_pos_weight</em>来平衡正样本和负样本的权重。例如，当正负样本比例为1:10时，<em>scale_pos_weight</em>可以取10；</p><p>第二种，如果你在意概率(预测得分的合理性)，不能重新平衡数据集(会破坏数据的真实分布)，应该设置<em>max_delta_step</em>为一个有限数字来帮助收敛（基模型为LR时有效）。</p><p>那么，源码到底是怎么利用<strong>scale_pos_weight</strong>来平衡样本的呢，是调节权重还是过采样呢？请看源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (info.labels[i] == <span class="number">1.0</span>f)  w *= param_.scale_pos_weight</span><br></pre></td></tr></table></figure><p>可以看出，应该是增大了少数样本的权重。</p><p>除此之外，还可以通过上采样、下采样、SMOTE算法或者自定义代价函数的方式解决正负样本不平衡的问题。</p><h4 id="XGBoost中如何对树进行剪枝"><a href="#XGBoost中如何对树进行剪枝" class="headerlink" title="XGBoost中如何对树进行剪枝"></a>XGBoost中如何对树进行剪枝</h4><ul><li>在目标函数中增加了正则项：使用叶子结点的数目和叶子结点权重的L2模的平方，控制树的复杂度。</li><li>在结点分裂时，定义了一个阈值，如果分裂后目标函数的增益小于该阈值，则不分裂。</li><li>当引入一次分裂后，重新计算新生成的左、右两个叶子结点的样本权重和。如果任一个叶子结点的样本权重低于某一个阈值（最小样本权重和），也会放弃此次分裂。</li><li>XGBoost 先从顶到底建立树直到最大深度，再从底到顶反向检查是否有不满足分裂条件的结点，进行剪枝。</li></ul><h2 id="LightGBM"><a href="#LightGBM" class="headerlink" title="LightGBM"></a>LightGBM</h2><p>LightGBM  （Light Gradient Boosting Machine） 由微软提出，用于解决GBDT在海量数据中遇到的问题。 其相对 XGBoost 具有训练速度快、内存占用低的特点。 GBDT在工业界通常被用于点击预测，搜索排序等任务。LightGBM是实现GBDT算法的框架，支持高效的并行训练。</p><h3 id="LightGBM在相比XGBoost哪些地方进行了优化？"><a href="#LightGBM在相比XGBoost哪些地方进行了优化？" class="headerlink" title="LightGBM在相比XGBoost哪些地方进行了优化？"></a>LightGBM在相比XGBoost哪些地方进行了优化？</h3><ol><li>单边梯度抽样算法；</li><li>直方图算法；</li><li>互斥特征捆绑算法；</li><li>基于最大深度的 Leaf-wise 的垂直生长算法；</li><li>类别特征最优分割；</li><li>特征并行和数据并行；</li><li>缓存优化。</li></ol><h3 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h3><h5 id="单边梯度抽样算法"><a href="#单边梯度抽样算法" class="headerlink" title="单边梯度抽样算法"></a>单边梯度抽样算法</h5><p>GBDT 算法的梯度大小可以反应样本的权重，梯度越小说明模型拟合的越好，单边梯度抽样算法（Gradient-based One-Side Sampling, GOSS）利用这一信息对样本进行抽样，减少了大量梯度小的样本，在接下来的计算中只需关注梯度高的样本，极大的减少了计算量。</p><p>GOSS 算法保留了梯度大的样本，并对梯度小的样本进行随机抽样，为了不改变样本的数据分布，在计算增益时为梯度小的样本引入一个常数进行平衡。 GOSS 事先基于梯度的绝对值对样本进行排序（无需保存排序后结果），然后拿到前 $a \%$ 的梯度大的样本，和剩下样本的 $b\%$，在计算增益时，通过乘上 $\frac{1-a}{b}$来放大梯度小的样本的权重。一方面算法将更多的注意力放在训练不足的样本上，另一方面通过乘上权重来防止采样对原始数据分布造成太大的影响。 </p><h5 id="直方图算法"><a href="#直方图算法" class="headerlink" title="直方图算法"></a>直方图算法</h5><h6 id="直方图算法-1"><a href="#直方图算法-1" class="headerlink" title="直方图算法"></a>直方图算法</h6><p>直方图算法的基本思想是将连续的特征离散化为 $k$ 个离散特征 （其实又是分桶的思想，而这些桶称为bin，比如[0,0.1)→0, [0.1,0.3)→1） ，同时构造一个宽度为 $k$ 的直方图用于统计信息（含有 $k$ 个 bin）。利用直方图算法无需遍历数据，只需要遍历 $k$ 个 bin 即可找到最佳分裂点。</p><p>我们知道特征离散化的具有很多优点，如存储方便、运算更快、鲁棒性强、模型更加稳定等等。对于直方图算法来说最直接的有以下两个优点（以 k=256 为例）：</p><ul><li>内存占用更小：XGBoost 需要用 32 位的浮点数去存储特征值，并用 32 位的整形去存储索引，而 LightGBM 只需要用 8 位去存储直方图，相当于减少了 1/8；</li><li>计算代价更小：计算特征分裂增益时，XGBoost 需要遍历一次数据找到最佳分裂点，而 LightGBM 只需要遍历一次 k 次，直接将时间复杂度从 $O(data  <em> feature)$降低到 $O(k  </em> feature)$  ， $data &gt;&gt; k$ 。</li></ul><p>虽然将特征离散化后无法找到精确的分割点，可能会对模型的精度产生一定的影响，但较粗的分割也起到了正则化的效果，一定程度上降低了模型的方差。</p><h6 id="直方图加速"><a href="#直方图加速" class="headerlink" title="直方图加速"></a>直方图加速</h6><p>在构建叶节点的直方图时，还可以通过父节点的直方图与相邻叶节点的直方图相减的方式构建，从而减少了一半的计算量。在实际操作过程中，还可以先计算直方图小的叶子节点，然后利用直方图作差来获得直方图大的叶子节点。 </p><img src="/2019/11/04/Kaggle比赛/7.png"><h6 id="稀疏特征优化"><a href="#稀疏特征优化" class="headerlink" title="稀疏特征优化"></a>稀疏特征优化</h6><p> XGBoost 在进行预排序时只考虑非零值进行加速，而 LightGBM 也采用类似策略：只用非零特征构建直方图。 </p><h5 id="带深度限制的-Leaf-wise-算法"><a href="#带深度限制的-Leaf-wise-算法" class="headerlink" title="带深度限制的 Leaf-wise 算法"></a>带深度限制的 Leaf-wise 算法</h5><p>在建树的过程中有两种策略：</p><ul><li><em>Level-wise</em>：基于层进行生长，直到达到停止条件；</li><li><em>Leaf-wise</em>：每次分裂增益最大的叶子节点，直到达到停止条件。</li></ul><img src="/2019/11/04/Kaggle比赛/8.png"><p>XGBoost 采用 <em>Level-wise</em> 的增长策略，方便并行计算每一层的分裂节点，提高了训练速度，但同时也因为节点增益过小增加了很多不必要的分裂，降低了计算量；LightGBM 采用 <em>Leaf-wise</em> 的增长策略减少了计算量，配合最大深度的限制防止过拟合，由于每次都需要计算增益最大的节点，所以无法并行分裂。</p><h5 id="类别特征最优分割"><a href="#类别特征最优分割" class="headerlink" title="类别特征最优分割"></a>类别特征最优分割</h5><p>大部分的机器学习算法都不能直接支持类别特征，一般都会对类别特征进行编码，然后再输入到模型中。常见的处理类别特征的方法为 one-hot 编码，但对于决策树来说并不推荐使用 one-hot 编码：</p><ol><li>会产生样本切分不平衡问题，切分增益会非常小。如，国籍切分后，会产生是否中国，是否美国等一系列特征，这一系列特征上只有少量样本为 1，大量样本为 0。这种划分的增益非常小：较小的那个拆分样本集，它占总样本的比例太小。无论增益多大，乘以该比例之后几乎可以忽略；较大的那个拆分样本集，它几乎就是原始的样本集，增益几乎为零；</li><li><p>影响决策树学习：决策树依赖的是数据的统计信息，而独热码编码会把数据切分到零散的小空间上。在这些零散的小空间上统计信息不准确的，学习效果变差。本质是因为独热码编码之后的特征的表达能力较差的，特征的预测能力被人为的拆分成多份，每一份与其他特征竞争最优划分点都失败，最终该特征得到的重要性会比实际值低。</p><p>LightGBM 原生支持类别特征，采用 many-vs-many 的切分方式将类别特征分为两个子集，实现类别特征的最优切分。假设有某维特征有 $k$ 个类别，则有 $2^{(k-1)} - 1$ 中可能，时间复杂度为 $O(2^k)$ ，LightGBM 实现了 $O(klog_2k)$ 的时间复杂度。 </p></li></ol><img src="/2019/11/04/Kaggle比赛/9.png"><p>上图为左边为基于 one-hot 编码进行分裂，后图为 LightGBM 基于 many-vs-many 进行分裂，在给定深度情况下，后者能学出更好的模型。其基本思想在于每次分组时都会根据训练目标对类别特征进行分类，根据其累积值 $\frac{\sum gradient }{\sum hessian}$ 对直方图进行排序，然后在排序的直方图上找到最佳分割。此外，LightGBM 还加了约束条件正则化，防止过拟合。</p><h3 id="XGBoost和LightGBM的区别"><a href="#XGBoost和LightGBM的区别" class="headerlink" title="XGBoost和LightGBM的区别"></a>XGBoost和LightGBM的区别</h3><ol><li><p>树生长策略：XGB采用<code>level-wise</code>的分裂策略，LGB采用<code>leaf-wise</code>的分裂策略。XGB对每一层所有节点做无差别分裂，但是可能有些节点增益非常小，对结果影响不大，带来不必要的开销。<em>Leaf-wise</em>是在所有叶子节点中选取分裂收益最大的节点进行的，但是很容易出现过拟合问题，所以需要对最大深度做限制 。</p></li><li><p>分割点查找算法：XGB使用特征预排序算法，LGB使用基于直方图的切分点算法，其优势如下：</p><ul><li><p>减少内存占用，比如离散为256个bin时，只需要用8位整形就可以保存一个样本被映射为哪个bin(这个bin可以说就是转换后的特征)，对比预排序的exact greedy算法来说（用int_32来存储索引+ 用float_32保存特征值），可以节省7/8的空间。</p></li><li><p>计算效率提高，预排序的Exact greedy对每个特征都需要遍历一遍数据，并计算增益，复杂度为 $𝑂(𝑓𝑒𝑎𝑡𝑢𝑟𝑒<em>𝑑𝑎𝑡𝑎)$ 。<br>而直方图算法在建立完直方图后，只需要对每个特征遍历直方图即可，复杂度为 $𝑂(𝑓𝑒𝑎𝑡𝑢𝑟𝑒</em>b𝑖𝑛𝑠)$ 。</p></li><li><p>LGB还可以使用直方图做差加速，一个节点的直方图可以通过父节点的直方图减去兄弟节点的直方图得到，从而加速计算</p><blockquote><p>但实际上xgboost的近似直方图算法也类似于lightgbm这里的直方图算法，为什么xgboost的近似算法比lightgbm还是慢很多呢？</p><p>xgboost在每一层都动态构建直方图， 因为xgboost的直方图算法不是针对某个特定的feature，而是所有feature共享一个直方图(每个样本的权重是二阶导)，所以每一层都要重新构建直方图，而lightgbm中对每个特征都有一个直方图，所以构建一次直方图就够了。</p></blockquote></li></ul></li><li><p>支持离散变量：无法直接输入类别型变量，因此需要事先对类别型变量进行编码（例如独热编码），而LightGBM可以直接处理类别型变量。</p></li><li><p>缓存命中率：XGB使用Block结构的一个缺点是取梯度的时候，是通过索引来获取的，而这些梯度的获取顺序是按照特征的大小顺序的，这将导致非连续的内存访问，可能使得CPU cache缓存命中率低，从而影响算法效率。而LGB是基于直方图分裂特征的，梯度信息都存储在一个个bin中，所以访问梯度是连续的，缓存命中率高。</p></li><li><p>LightGBM 与 XGboost 的并行策略不同：</p><ul><li><strong>特征并行</strong> ：LGB特征并行的前提是每个worker留有一份完整的数据集，但是每个worker仅在特征子集上进行最佳切分点的寻找；worker之间需要相互通信，通过比对损失来确定最佳切分点；然后将这个最佳切分点的位置进行全局广播，每个worker进行切分即可。XGB的特征并行与LGB的最大不同在于XGB每个worker节点中仅有部分的列数据，也就是垂直切分，每个worker寻找局部最佳切分点，worker之间相互通信，然后在具有最佳切分点的worker上进行节点分裂，再由这个节点广播一下被切分到左右节点的样本索引号，其他worker才能开始分裂。二者的区别就导致了LGB中worker间通信成本明显降低，只需通信一个特征分裂点即可，而XGB中要广播样本索引。</li><li><strong>数据并行</strong> ：当数据量很大，特征相对较少时，可采用数据并行策略。LGB中先对数据水平切分，每个worker上的数据先建立起局部的直方图，然后合并成全局的直方图，采用直方图相减的方式，先计算样本量少的节点的样本索引，然后直接相减得到另一子节点的样本索引，这个直方图算法使得worker间的通信成本降低一倍，因为只用通信以此样本量少的节点。XGB中的数据并行也是水平切分，然后单个worker建立局部直方图，再合并为全局，不同在于根据全局直方图进行各个worker上的节点分裂时会单独计算子节点的样本索引，因此效率贼慢，每个worker间的通信量也就变得很大。</li><li><strong>投票并行（LGB）</strong>：当数据量和维度都很大时，选用投票并行，该方法是数据并行的一个改进。数据并行中的合并直方图的代价相对较大，尤其是当特征维度很大时。大致思想是：每个worker首先会找到本地的一些优秀的特征，然后进行全局投票，根据投票结果，选择top的特征进行直方图的合并，再寻求全局的最优分割点。</li></ul></li></ol><h2 id="BigQuery-Geotab-Intersection-Congestion"><a href="#BigQuery-Geotab-Intersection-Congestion" class="headerlink" title="BigQuery-Geotab Intersection Congestion"></a>BigQuery-Geotab Intersection Congestion</h2><p>BigQuery-Geotab交叉路口拥堵：预测主要城市十字路口的等待时间</p><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><p>该比赛的数据集包括总计停止的车辆信息和交叉路口等待时间。任务是根据美国四个主要城市（亚特兰大，波士顿，芝加哥和费城）的交叉路口的停车距离和等待时间的总量来预测交通拥堵。</p><p>这项比赛是与BigQuery合作举办的，BigQuery是一个用于操纵，联接和查询大规模表格数据集的数据仓库。 BigQuery还提供BigQuery ML，这是用户创建和运行机器学习模型以通过SQL查询界面生成预测的简便方法。</p><p>Kaggle最近在我们的内核笔记本环境中发布了BigQuery集成，该入门内核为您提供了使用BQ和BQML的绝佳起点。建议使用精明的数据，机智和直觉来查找并加入其他外部数据集，以提高模型的预测能力。</p><h4 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h4><p>根据均方根误差对提交的内容评分。RMSE定义为：</p><script type="math/tex; mode=display">\textrm{RMSE} = \sqrt{\frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2}</script><p>其中$\hat{y}$是预测值，$y$是原始值。</p><p>提交文件：</p><p>对于测试集中的每一行，必须按照“数据”选项卡上的描述预测六个目标结果的值，每个目标结果都在提交文件中的单独一行中。 该文件应包含标头，并具有以下格式：</p><div class="table-container"><table><thead><tr><th>ID</th><th>TARGET</th></tr></thead><tbody><tr><td>0_1</td><td>0</td></tr><tr><td>0_2</td><td>0</td></tr><tr><td>0_3</td><td>0</td></tr></tbody></table></div><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>通过内核使用 BigQuery 和 BigQuery ML：除了可以在 Kaggle 上下载之外，该比赛的数据集还托管在一个私有的 BigQuery 数据集中。 您可以按照“数据”页面上 BigQuery-Dataset-Access.md 文档中的说明进行访问。在“设置”面板中，可以在 Kaggle 内核/笔记本上启用 BigQuery。</p><p>入门资源：本入门教程向您展示如何开始在 BigQuery ML上运行查询。</p><h4 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h4><p>数据包括来自商用车辆（例如半卡车）的汇总行程记录指标。数据已按照交叉路口，月份，一天中的小时，通过交叉路口的方向以及一天是否在周末进行了分组。</p><p>对于测试集中的每个分组，需要针对两个不同度量标准的三个不同分位数进行预测，以涵盖该组车辆驶过交叉路口需要多长时间。具体来说，总时间的20％，50％和80％在交叉路口停止，并且交叉路口与车辆在等待时停止的第一位置之间的距离。您可以将目标视为总结每个交叉路口的等待时间和停车距离的分布。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RowId                int64</span><br><span class="line">IntersectionId       int64</span><br><span class="line">Latitude           float64</span><br><span class="line">Longitude          float64</span><br><span class="line">EntryStreetName     object</span><br><span class="line">ExitStreetName      object</span><br><span class="line">EntryHeading        object</span><br><span class="line">ExitHeading         object</span><br><span class="line">Hour                 int64</span><br><span class="line">Weekend              int64</span><br><span class="line">Month                int64</span><br><span class="line">Path                object</span><br><span class="line">City                object</span><br></pre></td></tr></table></figure><p>这六个预测中的每个预测都在提交文件中的新行中进行。 读取提交的TargetId字段，例如1_1，第一个数字是RowId，第二个数字是度量标准ID。 可以使用submission_metric_map.json解压缩提交指标ID代码。</p><p>训练集包括一个可选的附加输出指标（TimeFromFirstStop），以防它对构建模型有用。 它仅从测试集中排除，以限制必须进行的预测的次数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">RowId                        int64</span><br><span class="line">IntersectionId               int64</span><br><span class="line">Latitude                   float64</span><br><span class="line">Longitude                  float64</span><br><span class="line">EntryStreetName             object</span><br><span class="line">ExitStreetName              object</span><br><span class="line">EntryHeading                object</span><br><span class="line">ExitHeading                 object</span><br><span class="line">Hour                         int64</span><br><span class="line">Weekend                      int64</span><br><span class="line">Month                        int64</span><br><span class="line">Path                        object</span><br><span class="line">TotalTimeStopped_p20         int64</span><br><span class="line">TotalTimeStopped_p40         int64</span><br><span class="line">TotalTimeStopped_p50         int64</span><br><span class="line">TotalTimeStopped_p60         int64</span><br><span class="line">TotalTimeStopped_p80         int64</span><br><span class="line">TimeFromFirstStop_p20        int64</span><br><span class="line">TimeFromFirstStop_p40        int64</span><br><span class="line">TimeFromFirstStop_p50        int64</span><br><span class="line">TimeFromFirstStop_p60        int64</span><br><span class="line">TimeFromFirstStop_p80        int64</span><br><span class="line">DistanceToFirstStop_p20    float64</span><br><span class="line">DistanceToFirstStop_p40    float64</span><br><span class="line">DistanceToFirstStop_p50    float64</span><br><span class="line">DistanceToFirstStop_p60    float64</span><br><span class="line">DistanceToFirstStop_p80    float64</span><br><span class="line">City                        object</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. scipy：建立在Numpy基础上，用于数值运算，如线性代数、常微分方程数值求解、信号处理、图像处理、稀疏矩阵。scipy.stats中包含很多常见的分布</span><br><span class="line">        rvs产生服从制定分布的随机数</span><br><span class="line">        pdf概率密度函数</span><br><span class="line">        cdf累计分布函数</span><br><span class="line">        sf残存函数(1-cdf)</span><br><span class="line">        ppf分位点函数（CDF的你函数）</span><br><span class="line">        isf逆残存函数</span><br><span class="line">        fit对随机取样进行你和，最大似然估计找到的概率密度函数系数</span><br><span class="line">2. Seaborn：对matplotlib的extend，是一个数据可视化库，提供更高级的API封装，在应用中更加的方便灵活。</span><br><span class="line">3. plotly：一款基于D3.js框架的Python库，非常著名且强大的开源数据可视化框架，通过构建基于浏览器显示的web形式的可交互图表来展示信息，可创建多达数十种精美的图表和地图。</span><br><span class="line">4. skleran: sklearn.metrics.mean_squared_error计算均方误差回归误差</span><br><span class="line">sklearn.preprocessing.LabelEncoder可以将标签分配一个0—n_classes-1之间的编码</span><br><span class="line">5. functools：为了高阶函数（该高阶函数的定义为作用于或返回其它函数的函数）而设置的。一般来说，任何可调用的对象在该模块中都可被当做函数而处理。functools.partial 通过包装手法，允许我们 &quot;重新定义&quot; 函数签名，用一些默认参数包装一个可调用对象,返回结果是可调用对象，并且可以像原始对象一样对待。</span><br><span class="line">6. hyperopt: 帮助快速进行机器学习模型参数调试。通常情况下有两种类型的参数调试方法，网格搜索（grid search）和随机搜索（random search）。网格搜索速度慢但是适用于需要随整个参数空间进行搜索的情况；随机搜索速度很快但是容易遗漏一些重要信息。Hyheropt四个重要的因素：指定需要最小化的函数，搜索的空间，采样的数据集(trails database)（可选），搜索的算法（可选）。</span><br></pre></td></tr></table></figure><h4 id="部分函数解读"><a href="#部分函数解读" class="headerlink" title="部分函数解读"></a>部分函数解读</h4><h5 id="pd-DataFrame"><a href="#pd-DataFrame" class="headerlink" title="pd.DataFrame()"></a>pd.DataFrame()</h5><p>在pandas里，DataFrame是最经常用的数据结构，这里总结生成和添加数据的方法：</p><ol><li><p>把其他格式的数据整理到DataFrame中；</p><p>① 字典类型读取到DataFrame: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">test_dict = &#123;<span class="string">'id'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">'name'</span>:[<span class="string">'Alice'</span>,<span class="string">'Bob'</span>,<span class="string">'Cindy'</span>],<span class="string">'math'</span>:[<span class="number">90</span>,<span class="number">89</span>,<span class="number">99</span>],<span class="string">'english'</span>:[<span class="number">89</span>,<span class="number">94</span>,<span class="number">80</span>]&#125;</span><br><span class="line"><span class="comment"># 直接使用`pd.DataFrame(data=test_dict)`即可,括号中的`data=`写不写都可以 。</span></span><br><span class="line">test_dict_df = pd.DataFrame(test_dict) <span class="comment">#[1].直接写入参数test_dict</span></span><br><span class="line">test_dict_df = pd.DataFrame(data=test_dict) <span class="comment">#[2].字典型赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用from_dict方法</span></span><br><span class="line">test_dict_df = pd.DataFrame.from_dict(test_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：如果你的dict变量很小，例如&#123;'id':1,'name':'Alice'&#125;,想直接写到括号里：</span></span><br><span class="line"><span class="comment"># test_dict_df = pd.DataFrame(&#123;'id':1,'name':'Alice'&#125;) 会报错ValueError: If using all scalar values, you must pass an index</span></span><br><span class="line">test_dict_df = pd.DataFrame(&#123;<span class="string">'id'</span>:<span class="number">1</span>,<span class="string">'name'</span>:<span class="string">'Alice'</span>&#125;,pd.Index(range(<span class="number">1</span>)))</span><br><span class="line">pd.DataFrame(&#123;<span class="string">'id'</span>:[<span class="number">1</span>,<span class="number">2</span>],<span class="string">'name'</span>:[<span class="string">'Alice'</span>,<span class="string">'Bob'</span>]&#125;,pd.Index(range(<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只需要选择dict中部分的键当做DataFrame的列，可以使用columns参数</span></span><br><span class="line">test_dict_df = pd.DataFrame(data=test_dict,columns=[<span class="string">'id'</span>,<span class="string">'name'</span>])</span><br></pre></td></tr></table></figure><p>② csv文件构建DataFrame</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最常用的应该就是pd.read_csv('filename.csv')了，用sep指定数据的分割方式，默认的是','</span></span><br><span class="line">df = pd.read_csv(<span class="string">'./xxx.csv'</span>) <span class="comment"># 如果csv中没有表头，就要加入head参数</span></span><br></pre></td></tr></table></figure></li><li><p>在已有的DataFrame中插入N列或者N行。 </p><p>① 添加列 insert方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new_columns = [<span class="number">92</span>,<span class="number">94</span>,<span class="number">89</span>,<span class="number">77</span>,<span class="number">87</span>,<span class="number">91</span>]</span><br><span class="line">test_dict_df.insert(<span class="number">2</span>,<span class="string">'pyhsics'</span>,new_columns)</span><br><span class="line"><span class="comment"># DataFrame默认不允许添加重复的列，但是在insert函数中有参数 allow_duplicates=True，设置为True后，就可以添加重复的列了，列名也是重复的：</span></span><br></pre></td></tr></table></figure><p>② 添加行 loc方法或者append方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new_line = [<span class="number">7</span>,<span class="string">'Iric'</span>,<span class="number">99</span>]</span><br><span class="line"><span class="comment"># 但是十分注意的是，这样实际是改的操作，如果loc[index]中的index已经存在，则新的值会覆盖之前的值。</span></span><br><span class="line">test_dict_df.loc[<span class="number">3</span>]= new_line </span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以把这些新的数据构建为一个新的DataFrame，然后两个DataFrame拼起来。可以用append方法</span></span><br><span class="line">test_dict_df.append(pd.DataFrame([new_line],columns=[<span class="string">'id'</span>,<span class="string">'name'</span>,<span class="string">'physics'</span>]))</span><br></pre></td></tr></table></figure></li></ol><h5 id="df-reset-index"><a href="#df-reset-index" class="headerlink" title="df.reset_index()"></a>df.reset_index()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据清洗时，会将带空值的行删除，此时DataFrame或Series类型的数据不再是连续的索引，可以使用reset_index()重置索引。 在获得新的index，原来的index变成数据列，保留下来。不想保留原来的index，使用参数 drop=True，默认 False。</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df.reset_index()</span><br><span class="line">df.reset_index(drop=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h5 id="df-isnull"><a href="#df-isnull" class="headerlink" title="df.isnull()"></a>df.isnull()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># df.isnull() 元素级别的判断，把对应的所有元素的位置都列出来，元素为空或者NA就显示True，否则就是False</span></span><br><span class="line"><span class="comment"># df.isnull().any() 各个列是否存在缺失值</span></span><br><span class="line"><span class="comment"># df.isnull().any(1) 查看行包含缺失值情况</span></span><br><span class="line"><span class="comment"># df.isnull().values.any()  检查DataFrame 是否还有缺失值 返回True/False</span></span><br><span class="line"><span class="comment"># df.isnull().sum() 检查字段缺失值的数量</span></span><br><span class="line"><span class="comment"># df.isnull().sum().sum() 计算所有缺失值的数量</span></span><br></pre></td></tr></table></figure><h5 id="df-nunique"><a href="#df-nunique" class="headerlink" title="df.nunique()"></a>df.nunique()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回的是唯一值的个数</span></span><br><span class="line"><span class="comment"># 区别df.unique(), unique()是以数组形式（numpy.ndarray）返回列的所有唯一值（特征的所有唯一值）</span></span><br></pre></td></tr></table></figure><h5 id="df-value-counts"><a href="#df-value-counts" class="headerlink" title="df.value_counts()"></a>df.value_counts()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看表格某列中有多少个不同值的快捷方法，并计算每个不同值有在该列中有多少重复值,且默认从高到低排序</span></span><br><span class="line"><span class="comment"># 想升序排列，设置参数 ascending = True</span></span><br><span class="line"><span class="comment"># 想得出计数占比，可以加参数 normalize=True</span></span><br></pre></td></tr></table></figure><h5 id="df-groupby"><a href="#df-groupby" class="headerlink" title="df.groupby()"></a>df.groupby()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># groupby就是按xx分组, 基本操作：组内计数, 求和, 求均值, 求方差...</span></span><br><span class="line"><span class="comment"># 例如：对不同取值的计数: .value_counts()</span></span><br></pre></td></tr></table></figure><h5 id="sns-heatmap"><a href="#sns-heatmap" class="headerlink" title="sns.heatmap()"></a>sns.heatmap()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seaborn.heatmap(data, vmin=<span class="literal">None</span>, vmax=<span class="literal">None</span>, cmap=<span class="literal">None</span>, center=<span class="literal">None</span>, robust=<span class="literal">False</span>, annot=<span class="literal">None</span>, fmt=<span class="string">'.2g'</span>, annot_kws=<span class="literal">None</span>, linewidths=<span class="number">0</span>, linecolor=<span class="string">'white'</span>, cbar=<span class="literal">True</span>, cbar_kws=<span class="literal">None</span>, cbar_ax=<span class="literal">None</span>, square=<span class="literal">False</span>, xticklabels=<span class="string">'auto'</span>, yticklabels=<span class="string">'auto'</span>, mask=<span class="literal">None</span>, ax=<span class="literal">None</span>, **kwargs)</span><br><span class="line"><span class="comment"># 共20个参数，除参数data外其他都是默认</span></span><br><span class="line"><span class="comment"># 对于二维数组：热力图就是把这个二维的数组的数字用热力图的颜色值来表示</span></span><br><span class="line"><span class="comment"># 即热力图的作用：可视化已有的数字，数据表里多个特征两两的相似度</span></span><br><span class="line"><span class="comment"># annot: 默认为False，为True的话，会在格子上显示数字</span></span><br><span class="line"><span class="comment"># vmax, vmin: 热力图颜色取值的最大值，最小值，默认会从data中推导</span></span><br></pre></td></tr></table></figure><h5 id="pd-concat"><a href="#pd-concat" class="headerlink" title="pd.concat()"></a>pd.concat()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以将数据根据不同的轴作简单的融合</span></span><br><span class="line">pd.concat(objs, axis=<span class="number">0</span>, join=<span class="string">'outer'</span>, join_axes=<span class="literal">None</span>, ignore_index=<span class="literal">False</span>, keys=<span class="literal">None</span>, levels=<span class="literal">None</span>, names=<span class="literal">None</span>, verify_integrity=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 参数说明 </span></span><br><span class="line"><span class="comment"># objs: series，dataframe或者是panel构成的序列lsit </span></span><br><span class="line"><span class="comment"># axis： 需要合并链接的轴，0是行，1是列 </span></span><br><span class="line"><span class="comment"># join：连接的方式 inner，或者outer</span></span><br></pre></td></tr></table></figure><h5 id="sklearn-decomposition-PCA"><a href="#sklearn-decomposition-PCA" class="headerlink" title="sklearn.decomposition.PCA"></a>sklearn.decomposition.PCA</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参考：https://www.cnblogs.com/pinard/p/6243025.html</span></span><br><span class="line"><span class="comment"># 在scikit-learn中，与PCA相关的类都在sklearn.decomposition包中。最常用的PCA类是sklearn.decomposition.PCA， 除了PCA类以外，最常用的PCA相关类还有KernelPCA类（主要用于非线性数据的降维，需要用到核技巧。因此在使用的时候需要选择合适的核函数并对核函数的参数进行调参）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sklearn.decomposition.PCA参数介绍：</span></span><br><span class="line">   <span class="comment"># 1）n_components：指定希望PCA降维后的特征维度数目，也即保留下来的特征个数n。最常用的做法是直接指定降维到的维度数目，此时n_components是一个大于等于1的整数。也可以指定主成分的方差和所占的最小比例阈值，让PCA类根据样本特征方差来决定降维到的维度数，此时n_components是一个（0，1]之间的数。还可以将参数设置为"mle", 此时PCA类会用MLE算法根据特征的方差分布情况去选择一定数量的主成分特征来降维。也可以用默认值，即不输入n_components，此时n_components=min(样本数，特征数)。</span></span><br><span class="line">   <span class="comment"># 2）whiten ：判断是否进行白化。所谓白化，就是对降维后的数据的每个特征进行归一化，让方差都为1.对于PCA降维本身来说，一般不需要白化。如果你PCA降维后有后续的数据处理动作，可以考虑白化。默认值是False，即不进行白化。</span></span><br><span class="line">   <span class="comment"># 3）svd_solver：即指定奇异值分解SVD的方法，由于特征分解是奇异值分解SVD的一个特例，一般的PCA库都是基于SVD实现的。有4个可以选择的值：&#123;‘auto’, ‘full’, ‘arpack’, ‘randomized’&#125;。randomized一般适用于数据量大，数据维度多同时主成分数目比例又较低的PCA降维，它使用了一些加快SVD的随机算法。 full则是传统意义上的SVD，使用了scipy库对应的实现。arpack和randomized的适用场景类似，区别是randomized使用的是scikit-learn自己的SVD实现，而arpack直接使用了scipy库的sparse SVD实现。默认是auto，即PCA类会自己去在前面讲到的三种算法里面去权衡，选择一个合适的SVD算法来降维。一般来说，使用默认值就够了。</span></span><br><span class="line"> 　<span class="comment"># 除了这些输入参数外，有两个PCA类的成员值得关注。第一个是explained_variance_，它代表降维后的各主成分的方差值。方差值越大，则说明越是重要的主成分。第二个是explained_variance_ratio_，它代表降维后的各主成分的方差值占总方差值的比例，这个比例越大，则越是重要的主成分。</span></span><br><span class="line">   <span class="comment"># fit_transform(X), 用X来训练PCA模型，同时返回降维后的数据。</span></span><br></pre></td></tr></table></figure><h5 id="sns-FacetGrid"><a href="#sns-FacetGrid" class="headerlink" title="sns.FacetGrid()"></a>sns.FacetGrid()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先sns.FacetGrid画出轮廓 然后用map填充内容</span></span><br><span class="line"><span class="comment"># plt.hist直方图 plt.scatter散点图 sns.barplot条形图</span></span><br><span class="line"><span class="comment"># 参数alpha，设置点的大小</span></span><br></pre></td></tr></table></figure><h5 id="pd-crosstab"><a href="#pd-crosstab" class="headerlink" title="pd.crosstab"></a>pd.crosstab</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交叉表是用于统计分组频率的特殊透视表</span></span><br><span class="line"><span class="comment"># 透视表：pd.pivot_table, 透视表就是将指定原有DataFrame的列分别作为行索引和列索引，然后对指定的列应用聚集函数(默认情况下式mean函数)。</span></span><br></pre></td></tr></table></figure><h5 id="df-drop-duplicates"><a href="#df-drop-duplicates" class="headerlink" title="df.drop_duplicates()"></a>df.drop_duplicates()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 去除特定列下面的重复行, 返回DataFrame格式的数据</span></span><br><span class="line">DataFrame.drop_duplicates(subset=<span class="literal">None</span>, keep=<span class="string">'first'</span>, inplace=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># subset : column label or sequence of labels, optional, 用来指定特定的列，默认所有列</span></span><br><span class="line"><span class="comment"># keep : &#123;‘first’, ‘last’, False&#125;, default ‘first’, 删除重复项并保留第一次出现的项</span></span><br><span class="line"><span class="comment"># inplace : boolean, default False, 是直接在原来数据上修改还是保留一个副本</span></span><br></pre></td></tr></table></figure><h5 id="sklearn-LabelEncoder"><a href="#sklearn-LabelEncoder" class="headerlink" title="sklearn.LabelEncoder()"></a>sklearn.LabelEncoder()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># LabelEncoder可以将标签分配一个0—n_classes-1之间的编码, 将各种标签分配一个可数的连续编号</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line">le = preprocessing.LabelEncoder()</span><br><span class="line">le.fit([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>])  <span class="comment"># ---&gt; LabelEncoder()</span></span><br><span class="line">le.classes_   <span class="comment"># --&gt; array([1, 2, 6])</span></span><br><span class="line">le.transform([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>]) <span class="comment"># --&gt; array([0, 0, 1, 2], dtype=int64)</span></span><br><span class="line">le.inverse_transform([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]) <span class="comment"># Transform Integers Into Categories  --&gt; array([1, 1, 2, 6])</span></span><br></pre></td></tr></table></figure><h5 id="pd-get-dummies"><a href="#pd-get-dummies" class="headerlink" title="pd.get_dummies()"></a>pd.get_dummies()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># one-hot的基本思想：将离散型特征的每一种取值都看成一种状态，若你的这一特征中有N个不相同的取值，那么我们就可以将该特征抽象成N种不同的状态，one-hot编码保证了每一个取值只会使得一种状态处于“激活态”，也就是说这N种状态中只有一个状态位值为1，其他状态位都是0。</span></span><br><span class="line"><span class="comment"># dummy encoding 直观的解释就是任意的将一个状态位去除。</span></span><br><span class="line"><span class="comment"># pandas提供对one-hot编码的函数是：pd.get_dummies()</span></span><br><span class="line">pandas.get_dummies(data, prefix=<span class="literal">None</span>, prefix_sep=<span class="string">'_'</span>, dummy_na=<span class="literal">False</span>, columns=<span class="literal">None</span>, sparse=<span class="literal">False</span>, drop_first=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 输入：array-like, Series, or DataFrame</span></span><br><span class="line"><span class="comment"># 输出：DataFrame</span></span><br><span class="line"><span class="comment"># 主要参数说明：</span></span><br><span class="line"><span class="comment"># data : array-like, Series, or DataFrame</span></span><br><span class="line"><span class="comment"># prefix : string, list of strings, or dict of strings, default None, 给输出的列添加前缀，如prefix="A",输出的列会显示类似</span></span><br><span class="line"><span class="comment"># prefix_sep : 设置前缀跟分类的分隔符sepration，默认是下划线"_"</span></span><br><span class="line"><span class="comment"># 直接在原始数据中操作，可以使用columns参数</span></span><br><span class="line"><span class="comment"># drop_first : bool, default False, 获得k中的k-1个类别值，去除第一个</span></span><br></pre></td></tr></table></figure><h5 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># round() 方法返回浮点数x的四舍五入值。</span></span><br></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.cnblogs.com/peizhe123/p/5086128.html?clicktime=1572921140&amp;enterid=1572921140" target="_blank" rel="noopener">https://www.cnblogs.com/peizhe123/p/5086128.html?clicktime=1572921140&amp;enterid=1572921140</a></p><p><a href="https://mp.weixin.qq.com/s/adMMz8u29OnvqelgZuXWjg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/adMMz8u29OnvqelgZuXWjg</a> </p><p><a href="https://mp.weixin.qq.com/s/M2PwsrAnI1S9SxSB1guHdg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/M2PwsrAnI1S9SxSB1guHdg</a><br><a href="https://mp.weixin.qq.com/s/LoX987dypDg8jbeTJMpEPQ" target="_blank" rel="noopener">终于有人把XGBoost 和 LightGBM 讲明白了，项目中最主流的集成算法！</a><br><a href="https://mp.weixin.qq.com/s/wLE9yb7MtE208IVLFlZNkw" target="_blank" rel="noopener">XGBoost超详细推导，终于有人讲明白了！</a></p><p> <a href="https://mp.weixin.qq.com/s/fDwpJxSwWXWjV0y0mtKxAQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fDwpJxSwWXWjV0y0mtKxAQ</a> </p><p> <a href="https://mp.weixin.qq.com/s/441iM0snbfHznewbktUsvQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/441iM0snbfHznewbktUsvQ</a> </p><p> <a href="https://mp.weixin.qq.com/s/LoX987dypDg8jbeTJMpEPQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LoX987dypDg8jbeTJMpEPQ</a> </p></0$为最大值），>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GBDT回归算法&quot;&gt;&lt;a href=&quot;#GBDT回归算法&quot; class=&quot;headerlink&quot; title=&quot;GBDT回归算法&quot;&gt;&lt;/a&gt;GBDT回归算法&lt;/h2&gt;&lt;p&gt;GBDT(Gradient Boosting Decision Tree) 梯度提升决策树，
      
    
    </summary>
    
    
      <category term="Kaggle比赛" scheme="http://pl741.github.io/categories/Kaggle%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="GBDT" scheme="http://pl741.github.io/tags/GBDT/"/>
    
  </entry>
  
  <entry>
    <title>今日头条App爬虫</title>
    <link href="http://pl741.github.io/2019/10/31/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1app%E7%88%AC%E8%99%AB/"/>
    <id>http://pl741.github.io/2019/10/31/今日头条app爬虫/</id>
    <published>2019-10-31T11:58:19.000Z</published>
    <updated>2019-12-15T11:40:47.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今日头条App爬虫"><a href="#今日头条App爬虫" class="headerlink" title="今日头条App爬虫"></a>今日头条App爬虫</h2><h3 id="一、安装App爬虫模拟器与抓包软件"><a href="#一、安装App爬虫模拟器与抓包软件" class="headerlink" title="一、安装App爬虫模拟器与抓包软件"></a>一、安装App爬虫模拟器与抓包软件</h3><h4 id="Fiddler抓包工具安装与配置"><a href="#Fiddler抓包工具安装与配置" class="headerlink" title="Fiddler抓包工具安装与配置"></a>Fiddler抓包工具安装与配置</h4><ol><li><p>下载地址：<a href="https://www.telerik.com/fiddler" target="_blank" rel="noopener">https://www.telerik.com/fiddler</a></p></li><li><p>设置相关选项：打开fiddler，选择Tools——&gt;Options——&gt;HTTPS</p><p>勾选“Capture HTTPS CONNECTs”，同时勾选“Decrypt HTTPS traffic”—- Fiddler就可以截获HTTPS请求。</p><p>如果需要监听不可信的证书的HTTPS请求的话，需要勾选“Ignore server certificate errors (unsafe)”</p><img src="/2019/10/31/今日头条app爬虫/fiddler_1.png"><p><img src="//pl741.github.io/2019/10/31/今日头条app爬虫/fiddler_1.png" alt="1" style="zoom:60%;"></p></li><li><p>手机配置：Tools——&gt;Options——&gt;Connection</p><p>输入端口号：8889 ——手机输入Ip端口与Fiddler端口匹配</p><p>勾选”Allow remote computers to connect”。——允许别的机器把HTTP/HTTPS请求发送到Fiddler上来</p><img src="/2019/10/31/今日头条app爬虫/fiddler_2.png"><p><img src="//pl741.github.io/2019/10/31/今日头条app爬虫/fiddler_2.png" alt="1" style="zoom:60%;"></p></li></ol><h4 id="夜神Android模拟器安装与配置"><a href="#夜神Android模拟器安装与配置" class="headerlink" title="夜神Android模拟器安装与配置"></a>夜神Android模拟器安装与配置</h4><ol><li><p>下载网址：<a href="https://www.yeshen.com/" target="_blank" rel="noopener">https://www.yeshen.com/</a></p><p>选择历史版本，高版本在为wifi设置网桥代理时容易出错，需要下载专门的代理软件</p><img src="/2019/10/31/今日头条app爬虫/yeshen_1.png"><p><img src="//pl741.github.io/2019/10/31/今日头条app爬虫/yeshen_1.png" alt="1" style="zoom:60%;"></p><p>我选择的版本：V6.2.2.3</p><img src="/2019/10/31/今日头条app爬虫/yeshen_2.png"><p><img src="//pl741.github.io/2019/10/31/今日头条app爬虫/yeshen_2.png" alt="1" style="zoom:60%;"></p></li><li><p>为Android模拟器设置：</p><p>设置——&gt;WLAN，鼠标点击wifi位置，长按左键，会出现一个修改网络的弹窗</p><img src="/2019/10/31/今日头条app爬虫/yeshen_3.png"><p><img src="//pl741.github.io/2019/10/31/今日头条app爬虫/yeshen_3.png" alt="1" style="zoom:60%;"></p><img src="/2019/10/31/今日头条app爬虫/yeshen_4.png"><p><img src="//pl741.github.io/2019/10/31/今日头条app爬虫/yeshen_4.png" alt="1" style="zoom:60%;"></p></li><li><p>点击上图中的“修改网络”，会出现下图中的弹窗，勾选”显示高级选项”，代理选择“手动”</p><p>代理服务器主机名填写自己电脑的ip地址，接着再填写端口，与fiddler设置的端口号相同</p><img src="/2019/10/31/今日头条app爬虫/yeshen_5.png"><p><img src="//pl741.github.io/2019/10/31/今日头条app爬虫/yeshen_5.png" alt="1" style="zoom:60%;"></p></li><li><p>安装Fiddler证书：在模拟器浏览器输入<a href="http://ipv4.fiddler:8888/" target="_blank" rel="noopener">http://ipv4.fiddler:8888</a>，下载安装证书</p><img src="/2019/10/31/今日头条app爬虫/yeshen_6.png"><p><img src="//pl741.github.io/2019/10/31/今日头条app爬虫/yeshen_6.png" alt="1" style="zoom:60%;"></p><p>为证书命名：</p><img src="/2019/10/31/今日头条app爬虫/yeshen_7.png"><p><img src="//pl741.github.io/2019/10/31/今日头条app爬虫/yeshen_7.png" alt="1" style="zoom:60%;"></p><p>检查证书安装成功：设置———&gt;安全</p><img src="/2019/10/31/今日头条app爬虫/yeshen_9.png"><p><img src="//pl741.github.io/2019/10/31/今日头条app爬虫/yeshen_9.png" alt="1" style="zoom:60%;"></p><img src="/2019/10/31/今日头条app爬虫/yeshen_8.png"><p><img src="//pl741.github.io/2019/10/31/今日头条app爬虫/yeshen_8.png" alt="1" style="zoom:60%;"></p></li></ol><h4 id="Postman网页调试工具安装"><a href="#Postman网页调试工具安装" class="headerlink" title="Postman网页调试工具安装"></a>Postman网页调试工具安装</h4><ol><li><p>下载地址：<a href="https://www.getpostman.com/apps" target="_blank" rel="noopener">https://www.getpostman.com/apps</a></p><p>选择自己电脑对应的版本：Windows 32-bit 或者 Windows 64-bit</p></li></ol><h3 id="二、今日头条官方账号网址解析"><a href="#二、今日头条官方账号网址解析" class="headerlink" title="二、今日头条官方账号网址解析"></a>二、今日头条官方账号网址解析</h3><p><strong>今日头条官方账号：</strong></p><img src="/2019/10/31/今日头条app爬虫/今日头条官方账号.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 爬取到的网址</span><br><span class="line">https://ic.snssdk.com/api/search/content/?from=media&amp;keyword=%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1&amp;search_position=search_bar&amp;action_type=&amp;iid=90943616846&amp;device_id=68611601593&amp;ac=wifi&amp;channel=lite2_tengxun&amp;aid=35&amp;app_name=news_article_lite&amp;version_code=718&amp;version_name=7.1.8&amp;device_platform=android&amp;abflag=3&amp;device_type=HUAWEI%2BMLA-AL10&amp;device_brand=HUAWEI&amp;language=zh&amp;os_api=19&amp;os_version=4.4.2&amp;uuid=863064010001412&amp;openudid=000ec6d69fe08850&amp;manifest_version_code=718&amp;resolution=720*1280&amp;dpi=240&amp;update_version_code=71805&amp;_rticket=1572515243458&amp;sa_enable=0&amp;rom_version=19&amp;plugin_state=32727103&amp;fp=a_fake_fp&amp;is_ttwebview=0&amp;search_sug=1&amp;is_native_req=1&amp;fetch_by_ttnet=0&amp;search_start_time=1572515243460&amp;forum=1&amp;count=10&amp;format=json&amp;source=search_subtab_switch&amp;pd=user&amp;keyword_type=&amp;from_search_subtab=synthesis&amp;offset=0&amp;search_id=&amp;has_count=0&amp;qc_query=</span><br></pre></td></tr></table></figure><p>利用Postman进行网址分析：剔除不必要的字段，必须含有的字段包括<strong><em>count,   keyword,   offset,   channel,    app_name,    device_platform,    from,   device_type,   pd</em></strong>，字段<strong><em>pd</em></strong>表示搜索的是<strong>用户</strong>，字段<strong><em>keyword</em></strong>表示搜索的关键字，例如“今日头条”，其他字段为必须含有的固定字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 简化后的网址</span><br><span class="line">https://ic.snssdk.com/api/search/content/?count=10&amp;keyword=%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1&amp;offset=0&amp;channel=lite2_tengxun&amp;app_name=news_article_lite&amp;device_platform=android&amp;from=media&amp;device_type=HUAWEI%2BMLA-AL10&amp;pd=user</span><br></pre></td></tr></table></figure><p><strong>今日头条官方账号主页：</strong></p><img src="/2019/10/31/今日头条app爬虫/今日头条官方账号主页.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 爬取到的网址：</span><br><span class="line">https://ic.snssdk.com/api/feed/profile/v1/?category=profile_all&amp;visited_uid=3612927328&amp;stream_api_version=47&amp;count=20&amp;offset=0&amp;client_extra_params=%7B%7D&amp;iid=90943616846&amp;device_id=68611601593&amp;ac=wifi&amp;channel=lite2_tengxun&amp;aid=35&amp;app_name=news_article_lite&amp;version_code=718&amp;version_name=7.1.8&amp;device_platform=android&amp;ab_version=668906%2C1248366%2C1183179%2C631598%2C668903%2C679107%2C668905%2C643996%2C661929%2C785656%2C668907%2C808414%2C1210943%2C668908%2C668904%2C908123%2C928942%2C1211862&amp;ab_client=a1%2Cc2%2Ce1%2Cf2%2Cg2%2Cf7&amp;ab_feature=z1&amp;abflag=3&amp;ssmix=a&amp;device_type=HUAWEI+MLA-AL10&amp;device_brand=HUAWEI&amp;language=zh&amp;os_api=19&amp;os_version=4.4.2&amp;uuid=863064010001412&amp;openudid=000ec6d69fe08850&amp;manifest_version_code=718&amp;resolution=720*1280&amp;dpi=240&amp;update_version_code=71805&amp;_rticket=1572515346612&amp;sa_enable=0&amp;rom_version=19&amp;plugin_state=32727103&amp;fp=a_fake_fp&amp;ts=1572515346&amp;as=ab6c1ade505dbaae126c1a&amp;mas=01199333939919b9b3f95379b985624a77b9b3f95373b399b9b979</span><br></pre></td></tr></table></figure><p>利用Postman进行网址解析：剔除不必要的字段，最终必须包含的字段有<strong><em>category,   visited_uid,   count,   offset,   device_id,    channel,  app_name,   version_code,   device_platform,   device_type,   os_version</em></strong>，字段<strong><em>category</em></strong>可以是<strong>profile_all(全部)， profile_article(文章)， profile_video(视频)， profile_wenda(问答)</strong>，<font color="#D2691E">小视频</font>暂时还未抓取到关键字，其中有两个关键字段分别为<strong><em>visited_uid,   device_id</em></strong>，<strong><em>device_id</em></strong>是设备的ID，<strong><em>visited_uid</em></strong>在今日头条官方账号网页响应中可以获得，如下图：</p><img src="/2019/10/31/今日头条app爬虫/visited_id.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 简化后的网址</span><br><span class="line">https://ic.snssdk.com/api/feed/profile/v1/?category=profile_all&amp;visited_uid=3612927328&amp;count=20&amp;offset=0&amp;device_id=68611601593&amp;channel=lite2_tengxun&amp;app_name=news_article_lite&amp;version_code=717&amp;device_platform=android&amp;device_type=HUAWEI+MLA-AL10&amp;os_version=4.4.2</span><br></pre></td></tr></table></figure><h3 id="三、MongoDB中存储数据"><a href="#三、MongoDB中存储数据" class="headerlink" title="三、MongoDB中存储数据"></a>三、MongoDB中存储数据</h3><p>按照给定的MongoDB地址连接数据库，并将数据存入数据库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#pymongo.MongoClient连接到数据库</span></span><br><span class="line">        client = pymongo.MongoClient(<span class="string">"mongodb://toutiao:Toutiao#2019@47.92.136.180/toutiao"</span>)</span><br><span class="line">        <span class="comment"># 创建数据库'db1'</span></span><br><span class="line">        db = client[<span class="string">'toutiao'</span>]</span><br><span class="line">        <span class="comment"># 连接到数据集'toutiao'，类型为dict</span></span><br><span class="line">        self.collection=db[<span class="string">'toutiao'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self,item,spider)</span>:</span></span><br><span class="line">        <span class="comment">#插入数据到数据库</span></span><br><span class="line">        self.collection.update_one(&#123;<span class="string">'_id'</span>: item[<span class="string">'_id'</span>]&#125;, &#123;<span class="string">'$set'</span>: dict(item)&#125;, <span class="literal">True</span>)</span><br><span class="line">        print(<span class="string">u'-----------插入/更新成功!'</span>)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><p>在robomongo数据库可视化中查看数据是否插入成功：</p><p><img src="//pl741.github.io/2019/10/31/今日头条app爬虫/mongo_1.png" alt="1"></p><h3 id="四、今日头条主页返回信息分析"><a href="#四、今日头条主页返回信息分析" class="headerlink" title="四、今日头条主页返回信息分析"></a>四、今日头条主页返回信息分析</h3><p>根据要提取的内容：帖子内容，转发数，评论数，点赞数以及评论下的每条评论用户名，评论内容，此条评论的评论和获赞数</p><ol><li><p>首先根据要求先获取帖子内容，转发数，评论数，点赞数：</p><p>get请求：<code>https://ic.snssdk.com/api/feed/profile/v1/?category=profile_all&amp;visited_uid=3612927328&amp;offset=0&amp;device_id=68611601593&amp;channel=lite2_tengxun&amp;app_name=news_article_lite&amp;version_code=717&amp;device_platform=android&amp;device_type=HUAWEI+MLA-AL10&amp;os_version=4.4.2</code></p><p>转发数字段：forward_count</p><p>评论数字段：comment_count</p><p>点赞数字段：digg_count</p><p>帖子内容字段：title字段（帖子的标题， 有些帖子此字段为空） abstract， content 其中 abstract 字段为空的帖子的返回信息中含有 content 字段，content 字段包含了帖子的全部内容，abstract 字段不为空的帖子的返回信息中不含有 content 字段，abstract 字段不含有帖子的全部内容，此时在返回的信息中没有帖子的全部内容。</p><p>其他需要获取的字段：group_id（帖子id字段，为获取帖子的评论内容）</p><p>下一页的offset字段：offset</p></li><li><p>获取每条评论的评论用户名，评论内容，以及评论获赞数</p><p>获取每条评论的评论用户，评论内容，以及评论获赞数</p><p>get请求：<code>https://ic.snssdk.com/article/v4/tab_comments/?group_id=&amp;count=20&amp;offset=0&amp;device_id=68611601593&amp;aid=35</code></p><p>deviced_id为可选字段，group_id是评论帖子的id</p><p>评论用户名字段：user_name</p><p>评论用户ID字段：user_id</p><p>评论内容字段：text</p><p>评论获赞字段：digg_count</p><p>创建时间字段：create_time</p><p>其他字段：id（评论的id）</p></li></ol><h3 id="五、今日头条APP爬虫其他功能实现"><a href="#五、今日头条APP爬虫其他功能实现" class="headerlink" title="五、今日头条APP爬虫其他功能实现"></a>五、今日头条APP爬虫其他功能实现</h3><ol><li><p>实现爬取隔天数据：</p><p>获取贴子的发表时间：</p><p>获取get请求：<code>https://ic.snssdk.com/api/feed/profile/v1/?category=profile_all&amp;visited_uid=&amp;offset=0&amp;device_id=68611601593&amp;channel=lite2_tengxun&amp;app_name=news_article_lite&amp;version_code=717&amp;device_platform=android&amp;device_type=HUAWEI+MLA-AL10&amp;os_version=4.4.2</code></p><p>提取字段’create_time’或者’behot_time’，（这里有两个字段，主要是在返回信息一部分的帖子没有‘create_time’字段）</p><p>利用这几个字段提取出隔天的帖子。</p></li><li><p>获取帖子的全部评论：</p><p>根据帖子的评论数以及count的大小确定offset的大小，并利用此获取到帖子的全部评论。</p></li><li><p>使用代理获取：</p><p>利用之前写好的proxy_models模块，加入到本次的今日头条爬虫中，按照proxy_models模块中的README实现在爬虫过程中使用代理进行爬取。</p><p>主要包括以下两个部分：</p><ol><li><p>在middlewares.py文件中修改XXXXDownloaderMiddleware中间件，主要是获取代理IP（get_proxy）和测试代理IP（check_proxy）使用示例 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> proxy_models.mongo_db <span class="keyword">import</span> ProxyMongoConnect</span><br><span class="line"><span class="keyword">from</span> proxy_models.get_proxy <span class="keyword">import</span> get_proxy   </span><br><span class="line"><span class="keyword">from</span> proxy_models.check_proxy <span class="keyword">import</span> MechanizeOpener   </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXXXDownloaderMiddleware</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># initial proxy models environment</span></span><br><span class="line">        <span class="comment"># 其中LOCAL_MONGO_HOST, LOCAL_MONGO_PORT, DB_NAME, DB_USER, DB_PWD都为代理IP数据库对应的信息</span></span><br><span class="line">        ProxyMongoConnect(LOCAL_MONGO_HOST, LOCAL_MONGO_PORT, DB_NAME, DB_USER, DB_PWD)</span><br><span class="line">        self.opener = MechanizeOpener()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetch_proxy</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        <span class="comment"># 如果需要加入代理IP，请重写这个函数</span></span><br><span class="line">        <span class="comment"># 这个函数返回一个代理ip，'ip:port'的格式，如'12.34.1.4:9090'</span></span><br><span class="line">        <span class="keyword">return</span> get_proxy(spider.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></span><br><span class="line">        <span class="comment"># Called for each request that goes through the downloader</span></span><br><span class="line">        <span class="comment"># middleware.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Must either:</span></span><br><span class="line">        <span class="comment"># - return None: continue processing this request</span></span><br><span class="line">        <span class="comment"># - or return a Response object</span></span><br><span class="line">        <span class="comment"># - or return a Request object</span></span><br><span class="line">        <span class="comment"># - or raise IgnoreRequest: process_exception() methods of</span></span><br><span class="line">        <span class="comment">#   installed downloader middleware will be called</span></span><br><span class="line">        current_proxy = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'proxy'</span> <span class="keyword">in</span> request.meta:</span><br><span class="line">            current_proxy = request.meta[<span class="string">'proxy'</span>]</span><br><span class="line">        <span class="keyword">if</span> current_proxy <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> len(current_proxy) &gt; <span class="number">0</span>:</span><br><span class="line">            cur_ip, cur_port = current_proxy.replace(<span class="string">"http://"</span>, <span class="string">""</span>).split(<span class="string">":"</span>)</span><br><span class="line">            used, _ = self.opener.check_proxy(cur_ip, cur_port)</span><br><span class="line">            <span class="keyword">if</span> used:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        proxy_data = self.fetch_proxy(spider)</span><br><span class="line">        <span class="keyword">if</span> proxy_data:</span><br><span class="line">            current_proxy = <span class="string">f'http://<span class="subst">&#123;proxy_data&#125;</span>'</span></span><br><span class="line">            spider.logger.debug(<span class="string">f"当前代理IP:<span class="subst">&#123;current_proxy&#125;</span>"</span>)</span><br><span class="line">            request.meta[<span class="string">'proxy'</span>] = current_proxy</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            spider.logger.debug(<span class="string">"There is no usable proxy now"</span>)</span><br><span class="line">            request.meta[<span class="string">'proxy'</span>] = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></li><li><p>在settings.py文件中激活middlewares </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'sina.middlewares.IPProxyMiddleware'</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">'scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware'</span>: <span class="number">101</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加mongodb信息 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_MONGO_HOST = <span class="string">'47.92.136.180'</span></span><br><span class="line">LOCAL_MONGO_PORT = <span class="number">27017</span></span><br><span class="line"></span><br><span class="line">PROXY_DB_NAME = <span class="string">'proxy'</span></span><br><span class="line">PROXY_DB_USER = <span class="string">'proxy'</span></span><br><span class="line">PROXY_DB_PWD = <span class="string">'Proxy#2019'</span></span><br></pre></td></tr></table></figure></li></ol><p>下面展示成功利用代理实现爬虫：</p><p><img src="//pl741.github.io/2019/10/31/今日头条app爬虫/1.png" alt="1"></p></li></ol><h3 id="六、获取评论人具体信息"><a href="#六、获取评论人具体信息" class="headerlink" title="六、获取评论人具体信息"></a>六、获取评论人具体信息</h3><p>访问网址：<code>https://ic.snssdk.com/user/profile/homepage/v7/?channel=update&amp;device_type=HUAWEI+MLA-AL10&amp;user_id=</code></p><p>其中 user_id 是在爬取评论时获取的评论用户的 ID 字段。</p><p>根据返回信息可以获取评论用户具体信息如下：<br>    今日头条用户认证字段：verified_content<br>    今日头条用户位置字段：area<br>    今日头条用户简介字段：description<br>    用户发帖数字段：publish_count<br>    用户关注账号个数字段：followings_count<br>    用户粉丝数字段：followers_count<br>    用户总获赞数字段：digg_count</p><p>   具体信息展示如下：<img src="//pl741.github.io/2019/10/31/今日头条app爬虫/评论人信息.png"></p><h3 id="七、爬虫账号"><a href="#七、爬虫账号" class="headerlink" title="七、爬虫账号"></a>七、爬虫账号</h3><p>整理要采集的头条号列表：</p><p>主要整理头条列表号中不是官方账号：爬虫文件夹下的<code>toutiao.txt</code>，其中包含130个账号，主要包括（CCTV / 央视 / 湖南卫视 / 江苏卫视 / 浙江卫视 / 东方卫视 / 北京卫视等旗下的各种节目账号。</p><h3 id="八、爬虫中遇到的问题"><a href="#八、爬虫中遇到的问题" class="headerlink" title="八、爬虫中遇到的问题"></a>八、爬虫中遇到的问题</h3><ol><li>在最近爬取到的帖子中，有一部分conten为空：</li></ol><p><img src="//pl741.github.io/2019/10/31/今日头条app爬虫/2.png" alt="1" style="zoom:50%;"></p><p>​        主要原因：一部分返回值中content和abstract都为空，可以直接利用title获取</p><ol><li><p>在帖子中关于时间的字段一共有三个：create_time, publish_time, behot_time，之前使用的是create_time和behot_time，但在最近的爬虫中出现了一个错误，类似下图的帖子没有获取到相关信息：</p><p><img src="//pl741.github.io/2019/10/31/今日头条app爬虫/3.png" alt="1" style="zoom:40%;"></p><p>这个帖子较为特殊，主要是直播的回放，题目加一个视频内容，这个帖子没有评论内容，点赞数，转发数，同时它的create_time为11月15日，但behot_time为11月16日，在要爬取的11月15日中将爬取不到此贴，同时若利用publist_time替换behot_time时，发现此贴没有publish_time。鉴于此贴子的特殊性质（无评论，点赞数和转发数），将不爬取此贴。</p></li><li><p>代理IP的问题：</p><p>出现错误：<code>json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</code></p><p>出现这个错误的主要原因是代理IP不可用，或是代理IP已使用完，代理IP池中已无可用的IP，将会使用本地IP开始爬虫，当爬虫一段时间后出现此错，主要是无法再次获得返回信息了（即返回信息为空）。</p><p>考虑增加User-Agent，每次更换使用：经过多次的测试，发现不可行，只修改User-Agent无法解决此问题。</p></li><li><p>代理IP多次出现： 由于目标计算机积极拒绝，无法连接的问题。</p><p>可用的代理IP很少，导致因代理IP经常出现以上各种错误。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;今日头条App爬虫&quot;&gt;&lt;a href=&quot;#今日头条App爬虫&quot; class=&quot;headerlink&quot; title=&quot;今日头条App爬虫&quot;&gt;&lt;/a&gt;今日头条App爬虫&lt;/h2&gt;&lt;h3 id=&quot;一、安装App爬虫模拟器与抓包软件&quot;&gt;&lt;a href=&quot;#一、安装App爬
      
    
    </summary>
    
    
      <category term="Python爬虫" scheme="http://pl741.github.io/categories/Python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="今日头条App爬虫 + Scrapy框架" scheme="http://pl741.github.io/tags/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1App%E7%88%AC%E8%99%AB-Scrapy%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫</title>
    <link href="http://pl741.github.io/2019/10/29/Python%E7%88%AC%E8%99%AB/"/>
    <id>http://pl741.github.io/2019/10/29/Python爬虫/</id>
    <published>2019-10-29T04:37:21.000Z</published>
    <updated>2019-11-04T02:27:25.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h4 id="安装python库：-pip-install-pymongo"><a href="#安装python库：-pip-install-pymongo" class="headerlink" title="安装python库： pip install pymongo"></a>安装python库： <code>pip install pymongo</code></h4><h4 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h4><h5 id="emsp-emsp-连接到MongoClient"><a href="#emsp-emsp-连接到MongoClient" class="headerlink" title="&emsp;&emsp;连接到MongoClient"></a>&emsp;&emsp;连接到MongoClient</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接到数据库，为空默认ip为localhost，端口为27017</span></span><br><span class="line"><span class="comment"># 以下三种方式都相同</span></span><br><span class="line">client = pymongo.MongoClient()</span><br><span class="line">client = pymongo.MongoClient(<span class="string">'localhost'</span>, <span class="number">27017</span>)</span><br><span class="line">client = pymongo.MongoClient(<span class="string">'mongodb://localhost:27017/'</span>)</span><br></pre></td></tr></table></figure><h5 id="emsp-emsp-连接指定的数据库"><a href="#emsp-emsp-连接指定的数据库" class="headerlink" title="&emsp;&emsp;连接指定的数据库"></a>&emsp;&emsp;连接指定的数据库</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db = client.test_database</span><br><span class="line">db = client[<span class="string">'test_database'</span>]</span><br></pre></td></tr></table></figure><h5 id="emsp-emsp-连接指定的表"><a href="#emsp-emsp-连接指定的表" class="headerlink" title="&emsp;&emsp;连接指定的表"></a>&emsp;&emsp;连接指定的表</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collection = db.test_collection</span><br><span class="line">collection = db[<span class="string">'test_collection'</span>]</span><br></pre></td></tr></table></figure><h5 id="emsp-emsp-插入文档"><a href="#emsp-emsp-插入文档" class="headerlink" title="&emsp;&emsp;插入文档"></a>&emsp;&emsp;插入文档</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">post = &#123;</span><br><span class="line">    <span class="string">'author'</span>:<span class="string">'Mike'</span>,</span><br><span class="line">    <span class="string">'text'</span>:<span class="string">'My first blog post!'</span>,</span><br><span class="line">    <span class="string">'tags'</span>:[<span class="string">'mongodb'</span>, <span class="string">'python'</span>, <span class="string">'pymongo'</span>],</span><br><span class="line">    <span class="string">'date'</span>;datetime.datetime.utcnow()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到test_collection表,插入一条数据</span></span><br><span class="line">collection.insert_one(post)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找一条数据</span></span><br><span class="line">collection.find_one()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定条件查询，如果没有查询到，返回空值</span></span><br><span class="line">collection.find_one(&#123;<span class="string">'author'</span>:<span class="string">'Mike'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定id查询，需要使用ObjectId()</span></span><br><span class="line">collection.find_one(&#123;<span class="string">'_id'</span>:ObjectId(<span class="string">'_id值'</span>)&#125;)</span><br></pre></td></tr></table></figure><h5 id="emsp-emsp-插入多条数据"><a href="#emsp-emsp-插入多条数据" class="headerlink" title="&emsp;&emsp;插入多条数据"></a>&emsp;&emsp;插入多条数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">new_posts = [&#123;<span class="string">"author"</span>: <span class="string">"Mike"</span>,</span><br><span class="line">              <span class="string">"text"</span>: <span class="string">"Another post!"</span>,</span><br><span class="line">               <span class="string">"tags"</span>: [<span class="string">"bulk"</span>, <span class="string">"insert"</span>],</span><br><span class="line">               <span class="string">"date"</span>: datetime.datetime(<span class="number">2009</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">14</span>)&#125;,</span><br><span class="line">              &#123;<span class="string">"author"</span>: <span class="string">"Eliot"</span>,</span><br><span class="line">               <span class="string">"title"</span>: <span class="string">"MongoDB is fun"</span>,</span><br><span class="line">               <span class="string">"text"</span>: <span class="string">"and pretty easy too!"</span>,</span><br><span class="line">               <span class="string">"date"</span>: datetime.datetime(<span class="number">2009</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">45</span>)&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入多条数据</span></span><br><span class="line">result = collection.insert_many(new_posts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回插入的id</span></span><br><span class="line">result.inserted_ids</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询所有结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result.find():</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#查询指定结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result.find(&#123;<span class="string">'author'</span>:<span class="string">'Mike'</span>&#125;):</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 总数</span></span><br><span class="line">result.count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定查询的条数</span></span><br><span class="line">result.find(&#123;<span class="string">'author'</span>:<span class="string">'Mike'</span>&#125;).count()</span><br></pre></td></tr></table></figure><h5 id="emsp-emsp-插入或者更新"><a href="#emsp-emsp-插入或者更新" class="headerlink" title="&emsp;&emsp;插入或者更新"></a>&emsp;&emsp;插入或者更新</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果有找到x=1, 则改成x=3,否则插入&#123;‘x':3&#125;,单条</span></span><br><span class="line">result = collection.update_one(&#123;<span class="string">'x'</span>:<span class="number">1</span>&#125;, &#123;<span class="string">'$set'</span>:&#123;<span class="string">'x'</span>:<span class="number">3</span>&#125;&#125;, upsert=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有找到x=1,则改成x='mangmang',否则插入&#123;'x':'mangmang'&#125;,多条</span></span><br><span class="line">result = collection.update_many(&#123;<span class="string">'x'</span>:<span class="number">1</span>&#125;, &#123;<span class="string">'$set'</span>:&#123;<span class="string">'x'</span>:<span class="string">'mangmang'</span>&#125;&#125;, upsert=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="Scrapy中POST请求"><a href="#Scrapy中POST请求" class="headerlink" title="Scrapy中POST请求"></a>Scrapy中POST请求</h2><h4 id="Fiddler中抓取到的请求网址在postman中的使用方式："><a href="#Fiddler中抓取到的请求网址在postman中的使用方式：" class="headerlink" title="Fiddler中抓取到的请求网址在postman中的使用方式："></a>Fiddler中抓取到的请求网址在postman中的使用方式：</h4><ol><li><p>首先获取Fiddler中的网址，即右键——&gt;复制——&gt;仅复制URL</p></li><li><p>Postman中，粘贴刚复制好的URL，将请求方式修改为POST</p></li><li><p>然后在Fiddler中获取请求的body字段：TextView中的文本</p></li><li><p>Postman中在body中的raw字段下粘贴复制好的body字段</p></li></ol><h4 id="scrapy框架下的post请求"><a href="#scrapy框架下的post请求" class="headerlink" title="scrapy框架下的post请求"></a>scrapy框架下的post请求</h4><p>在Fiddler左侧的抓取结果区域中显示的则都是该域名相关的抓取结果：</p><img src="/2019/10/29/Python爬虫/1.png"><p><img src="//pl741.github.io/2019/10/29/Python爬虫/1.png" alt="1"></p><p>在该图中可以得到得信息如下：</p><ul><li>请求地址：</li><li>设备信息：deviceinfos</li><li>认证信息：authorization</li><li>请求方式：POST</li><li>媒体类型：Content-Type: application/json;charset=utf-8</li><li>主机信息：host:</li><li>用户标识：User-Agent: okhttp/3.6.0</li></ul><p>经验证，请求得头信息中，authorization、Content-Type、User-Agent是必填项。</p><h4 id="开始构造spider"><a href="#开始构造spider" class="headerlink" title="开始构造spider"></a>开始构造spider</h4><h5 id="1-settings-py："><a href="#1-settings-py：" class="headerlink" title="1. settings.py："></a>1. settings.py：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Crawl responsibly by identifying yourself (and your website) on the user-agent</span></span><br><span class="line">USER_AGENT = <span class="string">" "</span>   <span class="comment"># 你获取的User-Agent</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable cookies (enabled by default)</span></span><br><span class="line">COOKIES_ENABLED = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure maximum concurrent requests performed by Scrapy (default: 16)</span></span><br><span class="line"><span class="comment">#CONCURRENT_REQUESTS = 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure a delay for requests for the same website (default: 0)</span></span><br><span class="line"><span class="comment"># See https://doc.scrapy.org/en/latest/topics/settings.html#download-delay</span></span><br><span class="line"><span class="comment"># See also autothrottle settings and docs</span></span><br><span class="line">DOWNLOAD_DELAY = <span class="number">0</span></span><br><span class="line"><span class="comment"># The download delay setting will honor only one of:</span></span><br><span class="line">CONCURRENT_REQUESTS_PER_DOMAIN = <span class="number">16</span></span><br><span class="line">CONCURRENT_REQUESTS_PER_IP = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Override the default request headers:</span></span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line"><span class="string">'authorization'</span>: <span class="string">''</span>   <span class="comment"># authorization的值为抓取的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">'wltx_app.pipelines.BidPipeline'</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-定义Item："><a href="#2-定义Item：" class="headerlink" title="2. 定义Item："></a>2. 定义Item：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXXItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h5 id="3-编写spider"><a href="#3-编写spider" class="headerlink" title="3. 编写spider:"></a>3. 编写spider:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> XXX.items <span class="keyword">import</span> XXXItem</span><br><span class="line"><span class="keyword">from</span> scrapy.exceptions <span class="keyword">import</span> CloseSpider</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXXSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'XXX'</span></span><br><span class="line">    allowed_domains = [<span class="string">' '</span>]</span><br><span class="line">    Num = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 为当前时间到当天0点的秒数、86400为1天的秒数、北京时间的time.timezone值是-28800，所以是+</span></span><br><span class="line">    zeroPoint = int(time.time()) - int(time.time()-time.timezone) % <span class="number">86400</span> </span><br><span class="line">    <span class="comment"># 昨天0点时间戳</span></span><br><span class="line">    yesterdayZeroPoint = zeroPoint - <span class="number">86400</span> * <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">    url = <span class="string">" "</span></span><br><span class="line">    payloads = &#123;<span class="string">" "</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> payload <span class="keyword">in</span> payloads:</span><br><span class="line">    <span class="keyword">yield</span> scrapy.Request(url, body=json.dumps(payload), callback=self.parse, method=<span class="string">'POST'</span>, headers=&#123;<span class="string">'Content-Type'</span>:<span class="string">'application/json'</span>&#125;, dont_filter=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        data = response.text.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">        results = json.loads(data)[<span class="string">'results'</span>][<span class="number">0</span>]</span><br><span class="line">        print(<span class="string">"- "</span>*<span class="number">50</span>, type(results))</span><br><span class="line">        hits = results[<span class="string">'hits'</span>]</span><br><span class="line">        <span class="keyword">for</span> hit <span class="keyword">in</span> hits:</span><br><span class="line">        print(<span class="string">"- "</span>*<span class="number">50</span>, type(hit))</span><br><span class="line">        item = EnsItem()</span><br><span class="line">        last_sale = hit[<span class="string">'last_sale'</span>]</span><br><span class="line">        print(<span class="string">"- "</span>*<span class="number">50</span>, type(last_sale))</span><br><span class="line">        item[<span class="string">'Num'</span>] = self.Num</span><br><span class="line">        <span class="keyword">if</span> last_sale[<span class="string">'timestamp'</span>] &gt;= self.yesterdayZeroPoint:</span><br><span class="line">        item[<span class="string">'name'</span>] = hit[<span class="string">'name'</span>]</span><br><span class="line">        item[<span class="string">'total_price_eth'</span>] = last_sale[<span class="string">'total_price_eth'</span>]</span><br><span class="line">        deal_time = time.strftime(<span class="string">'%Y/%m/%d %H:%M:%S'</span>,time.localtime(last_sale[<span class="string">'timestamp'</span>]))</span><br><span class="line">        item[<span class="string">'timestamp'</span>] = deal_time</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># self.crawler.engine.close_spider(self, '结束爬虫!')</span></span><br><span class="line">        <span class="keyword">raise</span> CloseSpider(<span class="string">'结束爬虫'</span>)</span><br><span class="line">        self.Num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><h5 id="4-总结："><a href="#4-总结：" class="headerlink" title="4. 总结："></a>4. 总结：</h5><ol><li><p>headers信息中的Content-Type在settings.py中设置是没有效果的。</p></li><li><p>重写start_requests()方法,中data列表的值必须是str、bytes，不能为int</p></li><li><p>post请求中formdata和body的效果是一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> scrapy.FormRequest(url, method = <span class="string">'POST'</span>, headers = headers, body=json.dumps(data), callback = self.parse_list, dont_filter = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> scrapy.FormRequest(url, method = <span class="string">'POST'</span>, headers = headers, formdata=data, callback = self.parse_list, dont_filter = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li><p>重复爬取的地址需要设置 dont_filter = True</p></li></ol><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><h3 id="1-解决scrapy爬虫问题：Connection-was-refused-by-other-side-10061-由于目标计算机积极拒绝，无法连接"><a href="#1-解决scrapy爬虫问题：Connection-was-refused-by-other-side-10061-由于目标计算机积极拒绝，无法连接" class="headerlink" title="1. 解决scrapy爬虫问题：Connection was refused by other side: 10061: 由于目标计算机积极拒绝，无法连接"></a>1. 解决scrapy爬虫问题：Connection was refused by other side: 10061: 由于目标计算机积极拒绝，无法连接</h3><p>参考：<a href="https://blog.csdn.net/Edisonleeee/article/details/90383256" target="_blank" rel="noopener">https://blog.csdn.net/Edisonleeee/article/details/90383256</a></p><p>网络设置中的代理关掉：</p><img src="/2019/10/29/Python爬虫/2.png"><p><img src="//pl741.github.io/2019/10/29/Python爬虫/2.png" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MongoDB&quot;&gt;&lt;a href=&quot;#MongoDB&quot; class=&quot;headerlink&quot; title=&quot;MongoDB&quot;&gt;&lt;/a&gt;MongoDB&lt;/h2&gt;&lt;h4 id=&quot;安装python库：-pip-install-pymongo&quot;&gt;&lt;a href=&quot;#安装p
      
    
    </summary>
    
    
      <category term="Python爬虫" scheme="http://pl741.github.io/categories/Python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="MongoDB + Scrpay爬虫框架" scheme="http://pl741.github.io/tags/MongoDB-Scrpay%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>《Modeling Vehicle Interactions via Modified LSTM Models for Trajectory Prediction》</title>
    <link href="http://pl741.github.io/2019/10/10/%E3%80%8AModeling-Vehicle-Interactions-via-Modified-LSTM-Models-for-Trajectory-Prediction%E3%80%8B/"/>
    <id>http://pl741.github.io/2019/10/10/《Modeling-Vehicle-Interactions-via-Modified-LSTM-Models-for-Trajectory-Prediction》/</id>
    <published>2019-10-10T07:42:13.000Z</published>
    <updated>2019-10-17T06:31:09.775Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://xs.scihub.ltd/https://ieeexplore.ieee.org/abstract/document/8672889/" target="_blank" rel="noopener">《Modeling Vehicle Interactions via Modified LSTM Models for Trajectory Prediction》</a></p><h3 id="通过改进的LSTM模型对车辆相互作用进行轨迹预测建模"><a href="#通过改进的LSTM模型对车辆相互作用进行轨迹预测建模" class="headerlink" title=" 通过改进的LSTM模型对车辆相互作用进行轨迹预测建模 "></a><center> 通过改进的LSTM模型对车辆相互作用进行轨迹预测建模 </center></h3><h3 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h3><p>长短期记忆（<code>LSTM</code>）模型是最常用的车辆轨迹预测模型之一。在本文中，我们研究了现有的<code>LSTM</code>模型在密集交通中进行长期轨迹预测的两个问题。首先，现有的<code>LSTM</code>模型无法同时描述不同车辆之间的空间相互作用以及轨迹时间序列之间的时间关系。因此，现有的模型不能准确地估计车辆交互在密集交通中的影响。其次，基本的<code>LSTM</code>模型经常会遇到梯度消失的问题，因此很难长期训练。这两个问题有时会导致车辆轨迹预测中存在较大的预测误差。 在本文中，我们提出了一种基于时空<code>LSTM</code>的轨迹预测模型（<code>STLSTM</code>），其中涵盖了两个地方的修改。我们将空间交互嵌入到<code>LSTM</code>模型中，以隐式测量相邻车辆之间的交互。 我们还在两个连续<code>LSTM</code>层的输入和输出之间的引入了<code>shortcut connection</code>，以处理梯度消失问题。在<code>I-80</code>和<code>US-101</code>数据集上评估了提出的新模型。 结果表明，我们的新模型比一种最新模型（<code>maneuver-LSTM</code>（<code>M-LSTM</code>））具有更高的轨迹预测精度。</p><h3 id="INDEX-TERMS"><a href="#INDEX-TERMS" class="headerlink" title="INDEX TERMS"></a>INDEX TERMS</h3><p>轨迹预测     车辆交互作用   <code>Shortcut Connection</code>  <code>LSTM</code>（<code>long short-term memory</code>)</p><h3 id="I-INTRODUCTION"><a href="#I-INTRODUCTION" class="headerlink" title="I. INTRODUCTION"></a>I. INTRODUCTION</h3><p>自主车辆始终通过各种传感器来感知静态交通设施以及周围车辆和行人的运动，以预测其轨迹以用于将来的运动计划。车辆轨迹预测模型的输入是最近几秒钟内目标车辆的历史轨迹，输出是接下来几秒钟内的预测轨迹。</p><p>根据详细的预测过程，可以将先前工作中使用的预测模型大致分为两种类型：基于<code>Maneuver</code>的模型和端到端模型。</p><h4 id="A-MANEUVER-BASED-MODELS"><a href="#A-MANEUVER-BASED-MODELS" class="headerlink" title="A. MANEUVER-BASED MODELS"></a>A. MANEUVER-BASED MODELS</h4><img src="/2019/10/10/《Modeling-Vehicle-Interactions-via-Modified-LSTM-Models-for-Trajectory-Prediction》/1.png" title="Figure1. 两类轨迹预测模型:(a)基于Maneuver的模型，(b)端到端模型"><p>如图<code>Fig.1(a)</code>所示，基于<code>Maneuver</code>的轨迹预测模型包含两个连续步骤：机动识别步骤和预测步骤 [1] – [4]。机动识别步骤输出中间结果，该中间结果指示预定类型的目标车辆的操纵。例如，在直行的情况下，车辆的运动可以分为两种：直行和换道。</p><p>在机动识别步骤中，常规方法使用SVM<sup> [5]，[6]</sup> 或概率图形模型，例如HMM <sup>[3]，[5]，[7]</sup>，贝叶斯网络<sup>[4]</sup>，随机森林分类器<sup>[8]</sup>。最近的一些工作还使用RNN<sup> [9]，[10]</sup>来提高识别精度。在预测步骤中，常规方法使用原型轨迹方法<sup>[2]，[11]</sup>，基于簇的模型<sup>[3]</sup>，动力学模型<sup>[12]</sup>，多项式模型<sup>[13]-[15]</sup>，高斯过程<sup>[16]，[ 17]</sup>，RRT <sup>[18]</sup>，高斯混合模型<sup>[1]，[19]</sup>等。然而，但是，由于车辆的轨迹是非线性的<sup>[9]</sup>，并且运动模型的特征很复杂，因此许多先前的方法不能用于长期预测<sup>[4]，[20]</sup>。因此，最近的一些工作开始将RNN用于基于长期机动的轨迹预测<sup>[9]</sup>。</p><p>基于<code>Maneuver</code>的模型具有两个优点。首先，车辆的运动可以分解为几个相对容易识别的简洁的动作<sup>[2]</sup>。 其次，预定义的操纵类别与驾驶员的直觉一致。 因此，基于<code>Maneuver</code>的模型通常是可以解释的。</p><p>但是，基于机动的模型有两个缺点，可能导致较大的预测误差。首先，当场景或车辆运动变得复杂时，很难自然地将车辆的运动合理地分为几类。 例如，一些明显不同的轨迹可以被分类为同一操作，但是它们不能通过一个简单的轨迹模型来建模。其次，我们必须为训练过程手动标记轨迹的操作； 然而标签任务既费时又昂贵。 同时错误的标签也可能会增加训练模型的错误。</p><h4 id="B-END-TO-END-MODELS"><a href="#B-END-TO-END-MODELS" class="headerlink" title="B. END-TO-END MODELS"></a>B. END-TO-END MODELS</h4><p>如图<code>Fig.1(b)</code>所示，端到端模型试图跳过机动识别过程并直接执行轨迹预测。一些研究证明，即使没有操纵识别步骤，<code>LSTM</code>模型也能够为车辆或行人的复杂运动建模<sup>[21] – [23]</sup>。此外，使用端到端模型可以避免因不正确的机动划分而导致的错误。</p><p>但是，端到端<code>LSTM</code>模型仍然存在两个问题。首先，基本的<code>LSTM</code>模型不能同时对车辆和轨迹序列之间的空间相互作用进行建模。其次，在训练长期轨迹预测模型时，很难训练基本的<code>LSTM</code>模型。在对长时间序列进行建模时，此类<code>LSTM</code>模型在时间维度上等效于非常深的神经网络。因此，这种<code>LSTM</code>模型在反向传播中可能会遇到梯度消失的问题<sup>[24]</sup>。</p><p>为了解决上述两个问题，我们提出了一种新的模型<code>ST-LSTM</code>，该模型对基本<code>LSTM</code>模型的结构进行了两处结构修改，以进行轨迹预测。</p><p>第一个修改是，我们采用了<code>Structural-RNN（S-RNN）</code><sup>[25]</sup>的想法，并通过新的<code>LSTM</code>模型对所有车辆轨迹和车辆之间的相互作用进行建模。特别地，我们将时间关系和空间相互作用构造为不同的时间序列，并通过<code>LSTM</code>模型分别处理它们。与在时间关系和空间交互作用之间没有明确区分的那些模型（例如<code>S-RNN</code>）相比，新模型更适合交通场景。</p><p>第二个修改是在每个<code>LSTM</code>层的输入和输出之间引入<code>shortcut connections</code>，旨在将历史轨迹的先验信息直接传递到后续层。 这种结构可以减轻反向传播中的梯度消失<sup>[26]</sup>。</p><p>我们在<code>NGSIM I-80</code>和<code>US-101</code>数据集上训练和评估<code>ST-LSTM</code>。 所获得的预测结果比一种最新模型（即[9]中的<code>M-LSTM</code>）的结果具有更高的准确性，这证明了我们所做修改的有效性。</p><p>为了更好地展示我们的发现，本文的其余部分安排如下。 第二节介绍了我们研究的问题，声明了本文的符号并列出了<code>ST-LSTM</code>的预测步骤。 第三节详细介绍了<code>ST-LSTM</code>的结构。 第四节介绍了详细的训练过程，介绍了实验结果并讨论了<code>ST-LSTM</code>的有效性。 最后，第五节总结了论文。</p><h3 id="II-PROBLEM-PRESENTATION-AND-THE-MODEL-问题描述与模型"><a href="#II-PROBLEM-PRESENTATION-AND-THE-MODEL-问题描述与模型" class="headerlink" title="II. PROBLEM PRESENTATION AND THE MODEL 问题描述与模型"></a>II. PROBLEM PRESENTATION AND THE MODEL 问题描述与模型</h3><h4 id="A-THE-FRAMEWORK-OF-ST-LSTM"><a href="#A-THE-FRAMEWORK-OF-ST-LSTM" class="headerlink" title="A. THE FRAMEWORK OF ST-LSTM"></a>A. THE FRAMEWORK OF ST-LSTM</h4><h5 id="1-RESEARCH-SCENARIO-研究场景"><a href="#1-RESEARCH-SCENARIO-研究场景" class="headerlink" title="1) RESEARCH SCENARIO  研究场景"></a>1) RESEARCH SCENARIO  研究场景</h5><p>在本文中，我们研究了密集交通中的端到端长期轨迹预测。这里的“长期”是指该模型能够预测整个非平凡运动（除了直线运动以外的运动）的轨迹，同时保持较低的预测误差。这里的“密集交通”意味着每辆车都可以影响周围车辆的行驶轨迹，但道路并未完全阻塞。在这种情况下，由于周围车辆的影响，车辆的运动变得复杂。</p><p>我们将轨迹预测的目标载体表示为$V_{S}$。我们假设，当且仅当周围的车辆$V_{i}$靠近目标车辆时，它才能影响$V_{s}$的未来运动。如果$V_{i}$和$V_{s}$之间的纵向距离（以及车道）大于$80 m$，我们将忽略$V_{i}$对$V_{s}$的影响。我们仅注意在六个方向（左前，前，右前，右后，后，左，后）的六个最接近的周围车辆，分别表示为$V_{1}〜V_{6}$。参见<code>Fig.2</code>。</p><img src="/2019/10/10/《Modeling-Vehicle-Interactions-via-Modified-LSTM-Models-for-Trajectory-Prediction》/2.png" title="Figure2. ST-LSTM的整体结构和计算过程"><h5 id="2-INPUT-AND-OUTPUT"><a href="#2-INPUT-AND-OUTPUT" class="headerlink" title="2) INPUT AND OUTPUT"></a>2) INPUT AND OUTPUT</h5><p>我们将$V_{s}$和$V_{1}〜V_{6}$的历史轨迹表示为$ \boldsymbol{x}^{t}_{s}$和$\boldsymbol{x}_{i}^{t}(i=1,2, \dots, 6)$。如图<code>Fig2</code>所示，我们的端到端模型的输入为$\boldsymbol{x}^{t}=\left[\boldsymbol{x}_{s}^{t}, \boldsymbol{x}_{1}^{t}, \boldsymbol{x}_{2}^{t}, \ldots, \boldsymbol{x}_{6}^{t}\right]$。输出$\boldsymbol{y}^{t}_{s}$是$V_{s}$的预测轨迹。</p><p>我们将车辆轨迹表示为位置位移序列$[\Delta X, \Delta Y]$。$X$和$Y$分别是横向和纵向的坐标。也就是说，输入和输出是：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}{\boldsymbol{x}_{s}^{t}=\left[\Delta X_{s}^{\left(t-t_{h}+\Delta t\right)}, \Delta Y_{s}^{\left(t-t_{h}+\Delta t\right)}, \ldots, \Delta X_{s}^{t}, \Delta Y_{s}^{t}\right]} \\ {\boldsymbol{x}_{i}^{t}=\left[\Delta X_{i}^{\left(t-t_{h}+\Delta t\right)}, \Delta Y_{i}^{\left(t-t_{h}+\Delta t\right)}, \ldots, \Delta X_{i}^{t}, \Delta Y_{i}^{t}\right]}\end{array}\right.            \tag{1}</script><script type="math/tex; mode=display">\boldsymbol{y}_{s}^{t}=\left[\Delta X_{s}^{(t+\Delta t)}, \Delta Y_{s}^{(t+\Delta t)}, \cdots, \Delta X_{s}^{\left(t+t_{p}\right)}, \Delta Y_{s}^{\left(t+t_{p}\right)}\right]  \tag{2}</script><p>其中$t$是当前时间。$t_{h}$定义了历史时间范围。 $t_{p}$定义了预测时间范围。 $\Delta t$定义预测步长。 $[\Delta X_{s}^{t}; \Delta Y_{s}^{t}]$和$[\Delta X_{i}^{t}; \Delta Y_{i}^{t}]$定义从时间$(t-\Delta t)$到$t$的$V_{s}$和$V_{i}$的位置位移。 预测时间数$n_{p}=t_{p}/\Delta t$。 历史时间数$n_{h}=t_{h}/\Delta t$。</p><h5 id="3-THE-STRUCTURE-OF-ST-LSTM"><a href="#3-THE-STRUCTURE-OF-ST-LSTM" class="headerlink" title="3) THE STRUCTURE OF ST-LSTM"></a>3) THE STRUCTURE OF ST-LSTM</h5><p>我们通过<code>LSTM</code>模型<sup>1</sup>对所有车辆轨迹和所有交互进行建模，并将它们集成到高级结构中。 如图<code>Fig2</code>所示，$V_{i}(V_{s})$轨迹的<code>LSTM</code>模型表示为$C_{i}(C_{s})$。 $V_{i}$和$V_{s}$之间相互作用的<code>LSTM</code>模型表示为$I_{i}$。 为简单起见，图中仅显示<code>LSTM</code>模型的一部分。</p><h4 id="B-A-THREE-STEP-TRAJECTORY-PREDICTION-三步轨迹预测"><a href="#B-A-THREE-STEP-TRAJECTORY-PREDICTION-三步轨迹预测" class="headerlink" title="B. A THREE-STEP TRAJECTORY PREDICTION 三步轨迹预测"></a>B. A THREE-STEP TRAJECTORY PREDICTION 三步轨迹预测</h4><p>如图<code>Fig2</code>所示，我们将整个轨迹预测过程分为三个步骤：</p><p><strong>Step 1:</strong> 通过$C_{i}（C_{s}）$初步预测$V_{i}（V_{s}）$的轨迹。</p><p>$C_{i}（C_{s}）$的输入是历史轨迹$\boldsymbol{x}^{t}_{i}（\boldsymbol{x}^{t}_{s}）$。输出表示为$\boldsymbol{h}^{t}_{i}（\boldsymbol{h}^{t}_{s}）$，是$V_{i}（V_{s}）$的初步预测轨迹：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}{\boldsymbol{h}_{i}^{t}=\left[\Delta X_{i}^{(t+\Delta t)}, \Delta Y_{i}^{(t+\Delta t)}, \ldots, \Delta X_{i}^{\left(t+t_{p}\right)}, \Delta Y_{i}^{\left(t+t_{p}\right)}\right]} \\ {\boldsymbol{h}_{s}^{t}=\left[\Delta X_{s}^{(t+\Delta t)}, \Delta Y_{s}^{(t+\Delta t)}, \ldots, \Delta X_{s}^{\left(t+t_{p}\right)}, \Delta Y_{s}^{\left(t+t_{p}\right)}\right]}\end{array}\right.  \tag{3}</script><p><strong>Step 2:</strong> 通过$I_{i}$评估空间相互作用，并输出$V_{s}$的轨迹校正序列。</p><p>$I_{i}$的输入是$\boldsymbol{h}^{t}_{s}$和$\boldsymbol{h}^{t}_{i}$。输出$\boldsymbol{h}^{t}_{i,s}$是$\boldsymbol{h}^{t}_{s}$的轨迹校正序列，它考虑了$V_{i}$和$V_{s}$之间的空间相互作用对$V_{s}$运动的影响。 $\boldsymbol{h}^{t}_{i, s}$，$\boldsymbol{h}^{t}_{s}$和$\boldsymbol{h}^{t}_{i}$的长度都等于$2n_{p}$。</p><p><strong>Step 3:</strong> 校正$V_{s}$的预测轨迹并输出最终的预测轨迹。</p><p>此步骤的输入为$\boldsymbol{h}^{t}_{s}$和所有$\boldsymbol{h}^{t}_{i, s}$，最终输出预测序列$y^{t}_{s}$由输入的加权和计算得出：</p><script type="math/tex; mode=display">\boldsymbol{y}_{s}^{t}=\boldsymbol{h}_{s}^{t}+\sum_{i} w_{i} \boldsymbol{h}_{i,s}^{t}=\boldsymbol{h}_{s}^{t}+\left(\boldsymbol{W}^{t}\right)^{T} \boldsymbol{H}^{t}      \tag{4}</script><p>其中$\boldsymbol{W}^{t}=\left[w_{1}, w_{2}, \cdots, w_{6}\right]^{T}$，$\boldsymbol{H}^{t}=\left[\boldsymbol{h}_{1, s}^{t}, \boldsymbol{h}_{2, s}^{t}, \cdots, \boldsymbol{h}_{6,s}^{t}\right]^{T}$</p><p>权重$w_{i}$反映了$I_{i}$对$V_{s}$未来轨迹的影响程度。我们可以从安全距离的角度估计$w_{i}$，因为每辆车都会主动保持与周围车辆的安全距离，从而产生空间相互作用。</p><p>在本文中，我们通过[27]，[28]中提出的安全间隙公式来测量安全距离。令$V_{l}（V_{f}）$为$V_{i}$和$V_{s}$之中的领先（跟随）车辆。两辆车之间的安全距离为：</p><script type="math/tex; mode=display">D_{i, s}=v_{f} \rho+\frac{\left(v_{f}\right)^{2}-\left(v_{l}\right)^{2}}{2 a_{b r a k e}}+L=\frac{\bar{v} \Delta v}{a_{b r a k e}}+\left(v_{f} \rho+L\right)  \tag{5}</script><p>其中$v_{l}（v_{f}）$是$V_{l}（V_{f}）$的纵向速度。 $L$是两辆车的平均长度。 $ρ$是驾驶员的平均响应时间。 $a_{brake}$是两辆车的制动减速度。平均速度$\bar{v}=\left(v_{f}+v_{l}\right) / 2$，相对速度$\Delta v=v_{f}-v_{l}$。</p><p>该安全距离设想了一个汽车跟随的情况，先行车辆通过$a_{brake}$制动直到完全停止，随后的车辆在响应时间$ρ$内保持均速，然后通过$a_{brake}$制动直到完全停止。该公式可被视为安全距离的下限，因为当两辆车的距离小于$D_{i,s}$时，随后的车可能无法通过制动避免碰撞。</p><p>我们假设$α = 1/a_{brake}$和$β=v_{2}ρ+ L$，并进一步简化$β$为常数。我们考虑以下一种权重的先验知识：</p><script type="math/tex; mode=display">w_{i} \propto \frac{D_{i, s}}{\Delta d_{i, s}}=\frac{\alpha \bar{v} \Delta v+\beta}{\Delta d_{i, s}} \tag{6}</script><p>其中$\Delta d_{i, s}$定义了$V_{i}$和$V_{s}$之间的纵向距离。 在训练过程中需要确定常数项$α$和$β$。 在执行<strong>Step 3</strong>之前，应将所有$w_{i}$标准化。</p><p>在公式（6）中，$\bar{v}$或$\Delta v$的增加和$\Delta d_{i, s}$的减少将导致$w_{i}$的增加。 这表明$V_{i}$将对$V_{s}$产生更大的影响，这与我们的直觉是一致的。</p><p>如果$V_{i}$不存在或$\Delta d_{i, s}$太大，我们可以直接设置$w_{i}=0$，这样$V_{i}$的缺乏将不会影响预测过程。 因此，ST-LSTM可以应用于具有任意数量的周围车辆的车辆，反映了ST-LSTM的灵活性。</p><h3 id="III-MODEL-DESIGN"><a href="#III-MODEL-DESIGN" class="headerlink" title="III. MODEL DESIGN"></a>III. MODEL DESIGN</h3><h4 id="A-THE-STRUCTURE-AND-FEATURES-OF-ST-LSTM"><a href="#A-THE-STRUCTURE-AND-FEATURES-OF-ST-LSTM" class="headerlink" title="A. THE STRUCTURE AND FEATURES OF ST-LSTM"></a>A. THE STRUCTURE AND FEATURES OF ST-LSTM</h4><p>为了使<code>LSTM</code>模型能够同时对车辆之间的空间相互作用和轨迹序列之间的时间关系进行建模，Jain等人。在[25]中提出了一种高级时空模型，称为S-RNN（S-RNN）。关键思想是将空间相互作用视为可以由<code>LSTM</code>模型处理的时间序列。</p><p>如<code>Fig2</code>所示，我们采用<code>S-RNN</code>的思想，并类似地构建时空模型。但是，<code>ST-LSTM</code>和<code>S-RNN</code>之间有两个主要区别：</p><p>第一个区别是$C_{i}$和$I_{i}$（$\boldsymbol{h}^{t}_{i}$和$\boldsymbol{h}^{t}_{i, s}$）的输出定义。 在<code>S-RNN</code>中，未指定$C_{i}$和$I_{i}$的输出。 相反，<code>ST-LSTM</code>清楚地区分了$\boldsymbol{h}^{t}_{i}$（时间关系）和$\boldsymbol{h}^{t}_{i, s}$（空间相互作用），以突出它们在轨迹预测中的不同作用。 这是因为时间关系通常主导着整个驾驶行为，而不是空间相互作用。</p><p>第二个差异是<strong>Step 3</strong>中的权重$\boldsymbol{W}^{t}$。在S-RNN中，所有$I_{i}$的输出都通过在训练过程中直接学习的加权总和进行积分。 不同地，我们根据等式（4）-（6）中所示的相互作用影响程度的先验知识来评估$w_{i}$。 引入这些先验知识也将有助于加速学习。</p><p>根据比较，ST-LSTM比S-RNN更适合表征交通场景。</p><h4 id="B-THE-SHORTCUT-CONNECTIONS-FOR-LSTM-MODELS"><a href="#B-THE-SHORTCUT-CONNECTIONS-FOR-LSTM-MODELS" class="headerlink" title="B. THE SHORTCUT CONNECTIONS FOR LSTM MODELS"></a>B. THE SHORTCUT CONNECTIONS FOR LSTM MODELS</h4><p>由于基本的LSTM模型很难在长期轨迹预测中进行训练，因此我们对基本LSTM模型的结构进行了一些修改，如图3所示。</p><img src="/2019/10/10/《Modeling-Vehicle-Interactions-via-Modified-LSTM-Models-for-Trajectory-Prediction》/3.png" title="Figure3. 带有shortcut connections的修改后的LSTM模型结构。"><p>受ResNet [26]的启发，我们引入了<code>shortcut connections</code>来解决梯度消失的问题。输入序列的信息可以直接传输到后续的层。因此，修改后的<code>LSTM</code>模型可以减轻反向传播时的梯度消失。换句话说，修改后的<code>LSTM</code>模型的学习对象变成了类似残差的序列，而不是轨迹序列。我们将证明此更改可以使<code>LSTM</code>在<code>IV-D</code>部分中更容易训练。</p><p>为了构造<code>shortcut connections</code>，输入和输出序列的长度应相等（$n=2n_{h}$）。 <code>LSTM</code>层的数量（<code>Fig3</code>中的$m$）和每层中的<code>LSTM</code>单元的数量（<code>Fig3</code>中的$n$）是修改后的<code>LSTM</code>模型的两个主要结构参数。</p><h4 id="C-NETWORK-PARAMETER-SELECTION"><a href="#C-NETWORK-PARAMETER-SELECTION" class="headerlink" title="C. NETWORK PARAMETER SELECTION"></a>C. NETWORK PARAMETER SELECTION</h4><p>现在，我们专注于每个<code>LSTM</code>（$C_{i}$和$I_{i}$）的详细网络结构。 具体来说，我们需要设置历史时间范围$t_{h}$（$n=2n_{h}=2t_{h}/\Delta t$）和隐藏的<code>LSTM</code>层数$N_{hidden}$（$m=N_{hidden}$）。</p><p>$t_{h}$和$N_{hidden}$的值可以直接影响修改后的<code>LSTM</code>模型的性能。 通常，当$t_{h}$太小时，它无法提供足够的有效历史信息来进行轨迹预测； 当$t_{h}$太大时，冗余的历史信息可能会降低预测的准确性。 当$N_{hidden}$太小时，<code>LSTM</code>模型可能无法对复杂的车辆轨迹进行建模。 当$N_{hidden}$太大时，网络可能太深且收敛速度较慢。</p><p>所有$C_{i}$和$I_{i}$的详细网络参数选择如附录A所示。选择结果如<code>IV-B</code>节所示。</p><h3 id="IV-TRAINING-RESULTS-AND-DISCUSSIONS"><a href="#IV-TRAINING-RESULTS-AND-DISCUSSIONS" class="headerlink" title="IV. TRAINING RESULTS AND DISCUSSIONS"></a>IV. TRAINING RESULTS AND DISCUSSIONS</h3><h4 id="A-DATASET"><a href="#A-DATASET" class="headerlink" title="A. DATASET"></a>A. DATASET</h4><p>本文的研究场景是一条多车道的直路。在这种情况下，我们可以将车辆运动分为两种：直行和换道。</p><p>我们使用<code>NGSIM I-80</code>和<code>US-101</code>轨迹数据集来训练和评估ST-LSTM。</p><p><code>I-80</code>数据集于2005年4月13日在加利福尼亚州埃默里维尔的80号州际公路的东行方向上收集，其中包含下午4:00到下午4:15，下午5:00到下午5:15以及下午5:15到下午5:30。</p><p><code>US-101</code>数据集于2005年6月15日在加利福尼亚州洛杉矶的<code>US Highway 101</code>的南行方向上收集，其中包含从7:50 AM至8:05 AM，8:05 AM至8:20 AM，8:20 AM至8:35 AM。这两个数据集的实验场景都是交通密集的直行道路，其中包括大量的车道变换和跟随汽车的运动。因此，数据集非常适合我们在本文中研究的场景。</p><p>在<code>I-80</code>数据集中，在三个时间段内分别收集了2052、1836、1790个轨迹。这三个数据集分别包含1025、913、945个成功的车道变更。在US-101数据集中，在三个时间段内收集了2169、2017、1915个轨迹，分别包含1006、660、657个成功的车道变换。每个数据帧都包括车辆的位置，速度，偏航角，大小等。数据集的采样频率为10 Hz，因此我们在本文中设置$\Delta t=0.1s$。</p><img src="/2019/10/10/《Modeling-Vehicle-Interactions-via-Modified-LSTM-Models-for-Trajectory-Prediction》/4.png" title="Table 1. I-80中不同类型轨迹的统计信息。"><img src="/2019/10/10/《Modeling-Vehicle-Interactions-via-Modified-LSTM-Models-for-Trajectory-Prediction》/5.png" title="Table 2. US-101中不同类型轨迹的统计数据。"><p>但是，如表1和表2所示，两个数据集严重不平衡。 因此，我们仅对<strong>left only</strong>和<strong>no lane change</strong>进行降采样，而对<strong>right only</strong>进行过采样，以确保不同类型轨迹的比例大致相等[29]。</p><p>为了便于学习车道变更的特性，我们使用车道变更来修剪每个轨迹，并且仅保留包含车道变更的部分数据。 我们还在不改变车道的情况下随机修整了轨迹，以保证不同类型轨迹的平衡。</p><p>我们从平衡数据集中随机抽取N条轨迹（表1和表2中所示）进行训练，剩下的轨迹进行测试。 我们将在附录B中讨论训练集大小<code>N</code>的选择。选择结果在<code>IV-B</code>节中显示。</p><h4 id="B-TRAINING-DETAILS"><a href="#B-TRAINING-DETAILS" class="headerlink" title="B. TRAINING DETAILS"></a>B. TRAINING DETAILS</h4><p>根据附录A中的参数选择，我们为所有$C_{i}$和$I_{i}$设置$N_{hidden} =3$和$t_{h} =3s$。也就是说，所有的$C_{i}$和$I_{i}$都有三个隐藏层，每个层都有60个<code>LSTM</code>单元。根据附录B中训练集规模的选择，我们分别采用临界规模（具有580条轨迹）和较大规模（具有1350条轨迹）来训练ST-LSTM模型。</p><p>由于大多数车辆具有相似的轨迹特性，因此<code>ST-LSTM</code>中的所有$C_{i}$都共享一个公共<code>LSTM</code>模型。相反，由于周围车辆在不同方向上对$V_{s}$的影响是不同的，因此每个$I_{i}$都是独立训练的，彼此之间不共享网络参数。</p><p>使用<code>Tensorflow</code>对<code>ST-LSTM</code>进行了逐步训练。我们首先对$C_{i}$进行预训练，然后根据$C_{i}$对$I_{i}$进行预训练。所有的预训练LSTM模型都以$0.001$的初始学习率进行了约$20k$次迭代的训练。最后，将所有预训练的LSTM模型进行组合并训练约$5k$次迭代，以训练等式（6）的常数项$α$和$β$。</p><p>在训练过程中，每个训练步骤的批次大小$N_{b}$设置为$50×50$，即每个批次含有50条轨迹，并且每个轨迹序列的长度为$50$（即$5 s$）。 所有网络参数都是随机初始化的。 与其他参数不同，$α$和$β$具有特定的物理含义，但是我们测试了$α$和$β$的初始化值对整体训练结果的影响很小。 我们在训练过程中使用50％的随机失活。 优化器采用<code>ADAM</code>优化器。 训练过程的损失函数在预测位移序列$\boldsymbol{y}_{s}^{t}$和地面真实位移序列$\boldsymbol{y}^{t}$之间采用$MSE$（均方误差）。</p><script type="math/tex; mode=display">\boldsymbol{y}^{t}=\left[\Delta \hat{X}^{(t+\Delta t)}, \Delta \hat{Y}^{(t+\Delta t)}, \cdots, \Delta \hat{X}^{\left(t+t_{p}\right)}, \Delta \hat{Y}^{\left(t+t_{p}\right)}\right]  \tag{7}</script><p>每条轨迹的$MSE$损失函数为：</p><script type="math/tex; mode=display">\operatorname{loss}=\sum_{i=1}^{n_{p}}\left(\delta_{i}^{t}\right)^{T} \delta_{i}^{t}  \tag{8}</script><p>其中$\delta_{i}^{t}=\left[a\left(\Delta X^{(t+i \Delta t)}-\Delta \hat{X}^{(t+i \Delta t)}), \Delta Y^{(t+i \Delta t)}-\right. \Delta \hat{Y}^{(t+i \Delta t)}\right]^{T} $。我们在本文中设置常数$a =10$来放大横向误差对损失函数的影响。</p><p>总体MSE损失函数为：</p><script type="math/tex; mode=display">\text {Loss}=\frac{1}{N_{b}} \sum \text {loss}  \tag{9}</script><p>其中$N_{b}$是训练数据集中的轨迹总数。</p><h4 id="C-TESTING-RESULTS"><a href="#C-TESTING-RESULTS" class="headerlink" title="C. TESTING RESULTS"></a>C. TESTING RESULTS</h4><p>我们比较以下模型之间的$RMS$预测误差：<code>Mabeuver-LSTM</code>（<code>M-LSTM</code>，在[9]中提出），由$580$条轨迹训练的<code>ST-LSTM</code>（表示为<code>ST-LSTM-580</code>）和由$1350$条轨迹训练的<code>ST-LSTM</code>（表示为<code>ST-LSTM-1350</code>）。根据我们的统计，车道变更过程的平均时间为$4$到$5s$，因此我们将预测范围设置为$t_{p} =6s$。由于$t_{p}&gt; t_{h}$，我们应该重复几次预测过程以执行更大范围的轨迹预测。</p><p>在此，根据预测轨迹和地面真实轨迹计算出$RMS$预测误差。因此，我们需要累加位移序列$\boldsymbol{y}^{t}_{s}$和$\boldsymbol{y}^{t}$以获得轨迹表示$z^{t}_{s}$和$z^{t}$：</p><script type="math/tex; mode=display">z_{s}^{t}=\left[X^{(t+\Delta t)}, Y^{(t+\Delta t)}, \cdots, X^{\left(t+t_{p}\right)}, Y^{\left(t+t_{p}\right)}\right]\tag{10}</script><script type="math/tex; mode=display">z^{t}=\left[\hat{X}^{(t+\Delta t)}, \hat{Y}^{(t+\Delta t)}, \cdots, \hat{X}^{\left(t+t_{p}\right)}, \hat{Y}^{\left(t+t_{p}\right)}\right]\tag{11}</script><script type="math/tex; mode=display">\left\{\begin{array}{l}{X^{(t+i \Delta t)}=\sum_{j=1}^{i} \Delta X^{(t+j \Delta t)}} \\ {Y^{(t+i \Delta t)}=\sum_{j=1}^{i} \Delta^{(t+j \Delta t)}} \\ {\hat{X}^{(t+i \Delta t)}=\sum_{j=1}^{i} \Delta \hat{X}^{(t+j \Delta t)}} \\ {\hat{Y}^{(t+i \Delta t)}=\sum_{j=1}^{i} \Delta \hat{Y}^{(t+j \Delta t)}}\end{array}\right.  \tag{12}</script><p>因此，在给定预测范围$P$的情况下，每个单个轨迹的$RMS$预测误差为：</p><script type="math/tex; mode=display">r m s^{P}=\left(\frac{1}{P} \sum_{i=1}^{P}\left(\sigma_{i}^{t}\right)^{T} \sigma_{i}^{t}\right)^{\frac{1}{2}}\tag{13}</script><script type="math/tex; mode=display">R M S^{P} =\frac{1}{N_{t}} \sum r m s^{P} \tag{14}</script><p>其中$\sigma_{i}^{t}=\left[X^{(t+i \Delta t)}-\hat{X}^{(t+i \Delta t)}, Y^{(t+i \Delta t)}-\hat{Y}^{(t+i \Delta t)}\right]^{T}$。$N_{t}$是测试数据集中的轨迹总数。</p><img src="/2019/10/10/《Modeling-Vehicle-Interactions-via-Modified-LSTM-Models-for-Trajectory-Prediction》/6.png" title="Table 3.预测误差的RMS值。"><p>$RMS$值显示在表3中，该值说明<code>ST-LSTM-580</code>和<code>ST-LSTM-1350</code>均胜过<code>M-LSTM</code>。从<code>ST-LSTM-580</code>和<code>ST-LSTM-1350</code>之间的比较中，我们可以发现后者模型使用了较大的训练集，但预测准确率仅得到了一点改进。这种现象证明了“临界点”的有效性，它可以指导我们适当地减少训练量，从而损失一点预测精度，以换取训练速度的显着提高。</p><img src="/2019/10/10/《Modeling-Vehicle-Interactions-via-Modified-LSTM-Models-for-Trajectory-Prediction》/7.png" title="Fig. 4 速度偏差的平均值和标准偏差的统计数据（I-80数据集上的ST-LSTM-1350）。"><img src="/2019/10/10/《Modeling-Vehicle-Interactions-via-Modified-LSTM-Models-for-Trajectory-Prediction》/8.png" title="Fig. 5 位置偏差的平均绝对偏差（I-80数据集上的ST-LSTM-1350）。"><p>为了分析轨迹预测误差的主要来源，我们计算了不同预测范围内速度偏差（表示为$VD_{i}$）的平均值和标准偏差，如Fig. 4所示。在Fig. 5中绘制了不同预测范围的位置偏差（表示为$PD_{i}$）的平均绝对偏差。$VD_{i}$和$PD_{i}$的定义为：</p><script type="math/tex; mode=display">V D_{i}=\frac{1}{\Delta t}\left[\Delta X^{(t+i \Delta t)}-\Delta \hat{X}^{(t+i \Delta t)}, \Delta Y^{(t+i \Delta t)}-\Delta \hat{Y}^{(t+i \Delta t)}\right]^{T}\tag{15}</script><script type="math/tex; mode=display">P D_{i}=\sigma_{t}^{i}\tag{16}</script><p>$Fig. 4$显示了不同预测水平下$VD_{i}$的分布大致相同。速度误差的累积极大的影响了总的长期预测误差。这就是我们使用位置误差的$RMS$评估<code>ST-LSTM</code>的原因。</p><p>当预测范围变得太大时，平均绝对偏差会增加，并且由于误差累积，预测会变得非常不稳定。从另一个角度看，历史轨迹不足以为大时间间隔的预测提供有效的信息。因此，本文选择的预测范围（$6s$）已经足够大。</p><img src="/2019/10/10/《Modeling-Vehicle-Interactions-via-Modified-LSTM-Models-for-Trajectory-Prediction》/9.png" title="Fig. 6 一个典型情况下的几个快照的预测轨迹和地面真实轨迹的示意图：(a) T=0s, (b) T=0.5s, (c) T=1s, (d) T=1.5 s, (e) T=2s, (f) T=4s。"><p>为了更直观地显示轨迹预测结果，我们随机选择车道变化轨迹，并在整个车道变化过程中观察预测结果。如图$6$所示，我们在此时间间隔中拍摄了六个快照。图$6(a)(b)$说明了预测的轨迹在车道变更过程的最开始还没有呈现出车道变更的特征。图$6(c)-(e)$中的预测轨迹显示了车道变化的典型特征。图$6(f)$说明了预测的轨迹在车道变化结束时变回直线。</p><h4 id="D-THE-ROLE-OF-SHORTCUT-CONNECTIONS"><a href="#D-THE-ROLE-OF-SHORTCUT-CONNECTIONS" class="headerlink" title="D. THE ROLE OF SHORTCUT CONNECTIONS"></a>D. THE ROLE OF SHORTCUT CONNECTIONS</h4><p>在训练过程中，我们发现修改后的<code>LSTM</code>模型更容易训练，并且可以将$RMS$误差降低到较低的值。</p><p>在一个实验中，我们通过基本的LSTM模型训练了另一个$C_{s}$，并将其与$IV-C$节中的$C_{s}$进行了比较。 除了<code>shortcut connections</code>外，这两个模型的其他部分都相同，例如输入和输出，$N_{hidden}$，$t_{h}$，训练过程等。在训练过程中没有人工干预。 损失函数的值绘制在$Fig. 7$中，表明修改后的LSTM模型收敛速度快于基本LSTM模型。</p><img src="/2019/10/10/《Modeling-Vehicle-Interactions-via-Modified-LSTM-Models-for-Trajectory-Prediction》/10.png" title="Fig. 7 训练过程中两个模型的损失变化。"><h3 id="V-CONCLUSION"><a href="#V-CONCLUSION" class="headerlink" title="V. CONCLUSION"></a>V. CONCLUSION</h3><p>在本文中，我们提出了一种用于密集交通的新颖的端到端长期轨迹预测模型。 为了解决密集交通中长期预测的两个问题，我们通过添加<code>shortcut connections</code>来修改经典<code>LSTM</code>模型，并通过修改后的<code>LSTM</code>模型对所有空间相互作用和时间关系进行建模。 最后，我们构建了一个时空轨迹预测模型。 在<code>NGSIM I-80​</code>和<code>US-101</code>上进行的实验证明，与最新模型（<code>M-LSTM</code>）相比，<code>ST-LSTM</code>可以获得更精确的轨迹预测。</p><p>但是，我们仅在<code>NGSIM I-80</code>和<code>US-101</code>上测试<code>ST-LSTM</code>，它们在单个简单场景中是相对较小的数据集。 在将来的工作中，我们将收集更多数据并在更复杂的情况下评估<code>ST-LSTM</code>。</p><h3 id="APPENDIX-A"><a href="#APPENDIX-A" class="headerlink" title="APPENDIX A"></a>APPENDIX A</h3><h5 id="NETWORK-PARAMETER-SELECTION"><a href="#NETWORK-PARAMETER-SELECTION" class="headerlink" title="NETWORK PARAMETER SELECTION"></a>NETWORK PARAMETER SELECTION</h5><p>我们通过$N_{\text {hidden}} \in\{2,3,4\}$和$t_{h} \in\{2s,3s,4s,5s\}$来训练$C_{i}$。在本实验中，我们在<code>I-80</code>数据集上随机选择一个轨迹数量$N =1200$的训练集。详细的训练过程与第<code>IV-B</code>节中所描述的相同。我们对训练集采用10倍交叉验证，以计算不同预测范围内的均方根误差（$RMS$)。</p><img src="/2019/10/10/《Modeling-Vehicle-Interactions-via-Modified-LSTM-Models-for-Trajectory-Prediction》/11.png" title="Fig. 8 比较具有不同$N_{hidden}$和$t_{h}$的修改LSTM模型之间的RMS误差: (a) $N_{hidden} = 2$，(b) $N_{hidden} =3$, (c) $N_{hidden}= 4$。"><p>如图8所示，我们比较了这些模型在不同预测范围内的RMS误差。 我们选择最佳组合（$t_{h} =3s$和$N_{hidden} =3$）作为$C_{i}$的参数，因为具有该组参数的模型的RMS误差几乎总是最低的（$t_{p} =2s$时第二低）。 我们还测试了更深的网络和更大$t_{h}$的网络，但是这些模型的性能并不比所选模型更好。</p><p>由于模型结构的限制，$I_{i}$的$t_{h}$应该等于$C_{i}$的$t_{h}$。 我们重复前面的步骤，发现$N_{hidden} =3$对于$I_{i}$也是一个很好的值。 </p><p>同样，我们尝试使用不同的训练集大小和不同的数据集（即<code>US-101</code>），发现上述$t_{h}$和$N_{hidden}$值也相对适合这些训练集。 因此，我们在<code>ST-LSTM</code>中为所有$C_{i}$和$I_{i}=3$和$N_{hidden} =3$。</p><h3 id="APPENDIX-B"><a href="#APPENDIX-B" class="headerlink" title="APPENDIX B"></a>APPENDIX B</h3><h5 id="OVERFITTING-ANALYSIS-AND-TRAINING-SET-SCALE-SELECTION"><a href="#OVERFITTING-ANALYSIS-AND-TRAINING-SET-SCALE-SELECTION" class="headerlink" title="OVERFITTING ANALYSIS AND TRAINING SET SCALE SELECTION"></a>OVERFITTING ANALYSIS AND TRAINING SET SCALE SELECTION</h5><p>深度学习模型（包括ST-LSTM）需要大量的数据进行训练。训练数据不足会导致拟合过度（泛化能力低），但是过多的数据也无法无限地提高模型泛化能力。特别是，通常很难获得用于深度学习的大规模数据集，因此我们需要找到数据量的“临界值”，以在提高模型泛化能力和减少训练数据需求之间达成折衷。该临界点也可以视为有效训练集的最小大小。</p><p>在本文中，我们分别使用不同大小的训练集来训练<code>ST-LSTM</code>模型，并计算它们的训练和测试误差（具有不同的预测范围），以观察模型是否过度拟合。</p><p>我们以<code>US-101</code>数据集为例。根据<code>IV-A</code>节，平衡数据集总共包含$1919$条有效轨迹。我们分别随机采样$40、95、190、380、580、960、1350、1540$轨迹（约占总数据集的$2％，5％，10％，20％，30％，50％，70％，80％$）进行训练，并在图9中绘制训练和测试误差。网络参数遵循附录A的结果。详细的训练过程遵循<code>IV-B</code>节）。</p><img src="/2019/10/10/《Modeling-Vehicle-Interactions-via-Modified-LSTM-Models-for-Trajectory-Prediction》/12.png" title="Fig. 9 .通过不同规模的训练集训练的ST-LSTM模型之间的训练和测试误差（不同预测范围）的比较。"><p>$Fig.9$说明了当训练集太小时，训练得到的<code>ST-LSTM</code>会产生严重的过拟合。随着轨迹数量的增加，过度拟合现象会减弱，而当训练集包含$580$多个轨迹时，这种过度拟合现象几乎可以消除。之后，尽管训练集数量大大增加，但是模型泛化能力仅略有改善。因此，我们认为$580$条轨迹是适合于我们的<code>ST-LSTM</code>模型的训练量。在其他数据集（例如<code>I-80</code>）上训练<code>ST-LSTM</code>模型时，我们构建了具有$580$条随机轨迹的训练集，并且还可以获得训练较好的模型。</p><p>上面的方法探讨了模型的“边际”性能，即对于特定模型，“临界点”代表我们至少应使用多少训练数据进行训练。我们认为，我们上面提出的方法值得推广。基于“临界点”，我们可以直接比较不同深度网络模型对训练数据的需求。当我们的训练数据规模有限时，我们可以基于该指标选择在此条件下具有更强泛化能力（并且不能过度拟合）的模型，并获得更好的性能。确定模型后，还可以根据该指标设置合理的训练集规模，避免训练数据冗余造成的计算资源浪费。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://xs.scihub.ltd/https://ieeexplore.ieee.org/abstract/document/8672889/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Modeling Vehicle I
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://pl741.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="LSTM" scheme="http://pl741.github.io/tags/LSTM/"/>
    
  </entry>
  
  <entry>
    <title>《Long Short Term Memory Networks for Anomaly Detection in Time Series》</title>
    <link href="http://pl741.github.io/2019/09/19/%E3%80%8ALong-Short-Term-Memory-Networks-for-Anomaly-Detection-in-Time-Series%E3%80%8B/"/>
    <id>http://pl741.github.io/2019/09/19/《Long-Short-Term-Memory-Networks-for-Anomaly-Detection-in-Time-Series》/</id>
    <published>2019-09-19T01:24:08.000Z</published>
    <updated>2019-09-19T11:52:34.929Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.elen.ucl.ac.be/Proceedings/esann/esannpdf/es2015-56.pdf" target="_blank" rel="noopener">Long Short Term Memory Networks for Anomaly Dection in Time Series</a></p><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>&emsp;&emsp;长短期记忆（LSTM）网络已被证明对于学习包含未知长度的长期模式的序列特别有用，因为它们能够维持长期记忆。在这样的网络中堆叠循环隐藏层还能够学习更高级别的时间特征，以便通过更稀疏的表示来更快地学习。在本文中，我们使用堆叠式LSTM（Stacked LSTM）网络进行时间序列中的异常检测。网络在非异常数据上进行训练，并用作多个时间步长的预测器。预测误差被建模为多变量高斯分布，用于评估异常行为的可能性。此方法的有效性在四个数据集上得到证实：ECG（心电图），航天飞机，电力需求和多传感器引擎数据集。</p><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>&emsp;&emsp;传统的过程监控技术在时间窗<sup>[1]</sup>上使用统计测量值，如累积和（CUSUM）和指数加权移动平均值（EWMA），以检测基础分布的变化。该时间窗口的长度通常需要预先确定，同时结果很大程度上取决于该参数。LSTM神经网络<sup>[2]</sup>通过采用乘法门来克服递归神经网络（RNN）所遇到的梯度消失问题。<u>该乘法门能保证常量错误一定从“内存单元”的内部状态通过</u>。输入$(IG)$，输出$(OG)$和遗忘$(FG)$门防止记忆内容被不相关的输入和输出扰动（参见$Fig.1(a)$），从而允许长期记忆存储。由于能够在序列中学习长期相关性，LSTM网络避免了对预先指定时间窗口的需要，并且能够精确地建模复杂的多变量序列。在本文中，我们通过堆叠式LSTM网络对时间序列的正常行为进行建模，我们可以准确地检测出与正常行为的偏差，而无需任何预先指定的上下文窗口或预处理。</p><img src="/2019/09/19/《Long-Short-Term-Memory-Networks-for-Anomaly-Detection-in-Time-Series》/1.png" title="$Fig.1:(a)$长短期记忆单元$(b)$堆叠结构"><p>&emsp;&emsp;已经表明，在网络中$Sigmoid$激活单元的堆叠循环隐藏层能更轻易地捕获时间序列的结构，并允许在不同的时间尺度处理时间序列<sup>[3]</sup>。使用分层时间处理技术进行异常检测的一个值得注意的例子是分层时间记忆（HTM）系统，它试图模仿新皮层中细胞，区域和水平的层次结构<sup>[4]</sup>。此外，像[5,6]这样的时间异常检测方法学习预测时间序列并使用预测误差来检测新颖性。然而，据我们所知，LSTM提供的记忆性功能尚未与循环分层处理层相结合，以用于预测时间序列并进行异常检测。</p><p>&emsp;&emsp;如[5]中所述，我们使用预测器建模正常行为，然后使用预测误差来识别异常行为。（这在现实世界的异常检测场景中特别有用，在这种场景中，正常行为的实例可能很多，但异常行为的实例很少见。）为了确保网络捕获序列的时间结构，我们预测未来的几个时间步骤。因此，序列中的每个点具有在过去的不同点处产生的多个对应的预测值，从而产生多个误差值。然后使用预测正常数据时的错误概率分布来获得在测试数据上正常行为的可能性。当控制变量（例如车辆加速器或制动器）也存在时，除了因变量之外，网络还用来预测控制变量。这迫使网络通过控制和相关传感器变量预测误差的联合分布来学习正常的使用模式：结果，当控制输入改变时已经捕获了明显的预测误差，并且不会有助于声明异常。</p><p>&emsp;&emsp;本文的其余部分安排如下：第2节描述了我们的方法。在第3节中，我们使用堆叠式LSTM方法（LSTM-AD）以及循环$Sigmoid$单元的堆叠RNN方法（RNN-AD），在四个真实世界数据集上呈现时间异常检测结果。第4节提供结论性意见。</p><h3 id="2-LSTM-AD：基于LSTM的异常检测"><a href="#2-LSTM-AD：基于LSTM的异常检测" class="headerlink" title="2. LSTM-AD：基于LSTM的异常检测"></a>2. LSTM-AD：基于LSTM的异常检测</h3><p>&emsp;&emsp;考虑一个时间序列$X=\left\{\mathbf{x}^{(1)}, \mathbf{x}^{(2)}, \dots, \mathbf{x}^{(n)}\right\}$，时间序列中的每个点$\mathbf{x}^{(t)} \in R^{m}$是一个$m$维的向量$\left\{x_{1}^{(t)}, x_{2}^{(t)}, \ldots, x_{m}^{(t)}\right\}$，，这些元素对应于输入变量。预测模型学习去预测输入变量$d$ $(s.t. 1 \leq d \leq m)$的接下来$l$个值。正常序列$(s)$被分为四组：正常训练集$(s_{N})$，正常验证集-1$(v_{N1})$，正常验证集-2$(v_{N2})$和正常测试集$(t_{N})$。异常序列$(s)$被分为两组：异常验证集$(v_{A})$和异常测试集$(t_{A})$。我们首先使用堆叠式LSTM网络学习一个预测模型，然后计算我们检测到异常的预测误差分布：</p><p>&emsp;&emsp;<strong>基于堆叠式LSTM的预测模型：</strong>我们考虑以下LSTM网络架构：对于$m$个维度中的每一个维度，我们都会对输入层放置一个单元，输出层有$d×l$个单元，使其满足对每一个维度的$l$个预测输出都有一个单元对应。隐藏层中的LSTM单元通过循环连接完全连接。我们基于如下方式堆叠LSTM层：较低层的LSTM隐藏层中的每个单元通过前馈连接完全连接到其上方的较高层的LSTM隐藏层中的每个单元（参见$Fig. 1(b)$）。使用$s_{N}$中的序列来学习预测模型。集合$v_{N1}$用于在学习网络权重时的提前停止。</p><p>&emsp;&emsp;<strong>基于预测误差分布的异常检测：</strong>在预测长度为$l$的情况下，对于$l&lt;t \leq n-1$，$\mathbf{x}^{(t)} \in X$中每个$d$维被预测$l$次。我们计算点$\mathbf{x}^{(t)}$的误差向量$ \mathbf e^{(t)}$,$\mathbf{e}^{(t)}=\left[e_{11}^{(t)}, \ldots, e_{1 l}^{(t)}, \ldots, e_{d 1}^{(t)}, \ldots, e_{d l}^{(t)}\right]$，其中$e_{ij}^{(t)}$表示$x_{i}^{(t)}$和其在$t-j$时间上的预测值之间的差。</p><p>&emsp;&emsp;在$s_{N}$上训练的预测模型用于计算验证和测试序列中每个点的误差向量。对误差向量进行建模以拟合多元高斯分布$\mathcal{N}=\mathcal{N}(\mu, \mathbf{\Sigma})$。观察误差向量$\mathbf e^{(t)}$的似然性$p^{(t)}$由$\mathcal{N}$在$\mathbf e^{(t)}$处的值给出（类似于使用基于卡尔曼滤波器的动态预测模型<sup>[5]</sup>的新颖性检测所使用的基于归一化新息平方$(NIS)$）。来自$v_{N1}$的点的误差向量用于使用最大似然估计来估计参数$μ$和$Σ$。如果$p^{(t)}&lt;τ$，则观察值$\mathbf x^{(t)}$被分类为“异常”，否则观察值被分类为“正常”。集合$v_{N2}$和$v_{A}$用于通过最大化$F_{β}-socre$来学习$τ$（其中异常点属于正类，而正常点属于负类）。</p><h3 id="3-实验"><a href="#3-实验" class="headerlink" title="3. 实验"></a>3. 实验</h3><p>&emsp;&emsp;我们在四个真实世界数据集上呈现LSTM-AD的结果，这些数据集在检测它们中的异常时具有不同的难度级别。在使用第2节中描述的验证集选择最大化$F_{0.1}-score$的网络架构以及和$τ$后，我们在表1中展示了采用LSTM-AD和RNN-AD两种方法的精度，召回率，$F_{0.1}-score$和架构。</p><h4 id="3-1-数据集"><a href="#3-1-数据集" class="headerlink" title="3.1 数据集"></a>3.1 数据集</h4><p>&emsp;&emsp;<em>心电图（ECGs)</em>：qtdb / sel102心电图数据集包含对应于心室前收缩的单个短期异常$(Fig.2 (a))$。由于ECG数据集只有一个异常，我们不计算该数据集的阈值和相应的$F_{0.1}-score$；我们只使用正常的ECG子序列学习预测模型，并计算剩余序列的误差向量的可能性。</p><p>&emsp;&emsp;<em>航天飞机Marotta阀门时间序列</em>：该数据集具有短时间段模式和长时间段模式，持续100个时间步长。数据集中存在三个异常区域在$Fig.2 (b)$中被标记为$a_{1}, a_{2}, a_{3}$。区域$a_{3}$是更容易辨别的异常，而区域$a_{1}$和$a_{2}$对应于在该方法下不易辨别的更微妙的异常。</p><p>&emsp;&emsp;<em>电力需求数据集</em>：电力消耗的正常行为是在每周中有五个峰值对应于五个工作日和两个低谷对应于周末。该数据集属于长期模式具有跨越数百个的时间步长。此外，此数据集有噪声，因为峰值不会在每条的同一时间出现。</p><p>&emsp;&emsp;<em>多传感器引擎数据</em>：该数据集具有来自12个不同的传感器：其中一个传感器是发动机的“控制”部件，其余的测量依赖如温度，扭矩等变量。我们使用对应于三个独立故障的序列来训练异常检测模型，并在三个不同的独立故障集上测量$F_{β}-score$。我们选择“控制”传感器和其他一个因变量作为要预测的值。</p><img src="/2019/09/19/《Long-Short-Term-Memory-Networks-for-Anomaly-Detection-in-Time-Series》/2.png" title="Fig.2: 样本序列（正常：绿色， 异常：蓝色）和相关似然$p$（红色）具有相同$S_{i}(i = 1,2,3)$的图具有相同的y轴"><h4 id="3-2-结果"><a href="#3-2-结果" class="headerlink" title="3.2 结果"></a>3.2 结果</h4><p>&emsp;&emsp;我们的实验结果的主要观察结果如下：</p><p>&emsp;&emsp;（i）在$Fig.2$ 中，对于所有数据集，异常区域中的似然值$p^{(t)}$显着低于正常区域。而且，$p^{(t)}$值在整个异常区域中不会保持低值。我们使用$β&lt;&lt; 1(0.1)$以便更加重视召回率的精确度：请注意，异常子序列中的所有点都具有“异常”标签，但实际上在这些中，也会存在许多“正常”行为点。因此，如果“异常”子序列中的很大一部分点被预测为异常就足够了。获得的$τ$值（$Fig.2. (a)- (f)$中的$p^{(t)}$图中的红色虚线）表明$F_{β}-score$（表1）是所考虑的数据集的合适度量。</p><p>&emsp;&emsp;（ii）对于所有数据集，发现阳性似然比（真阳性率/假阳性率）高（超过34.0）。高正似然比值表明在异常区域是异常的概率远高于在正常区域是异常的概率。</p><p>&emsp;&emsp;（iii）$Fig.2$ （f.1）和（f.2）显示了所选隐藏单元的激活，分别来自功率数据集的LSTM-L1（30个单元的低隐藏层）和LSTM-L2（20个单元的高隐藏层）各4个。在$Fig.2$ （f.2）中所示的最后激活序列中标记为$w_{1}$和$w_{2}$的子序列表示该隐藏单元激活在工作日期间高而在周末期间低。这些是由较高隐藏层学习的<em>high-level</em>特征的实例，其似乎以周为时间尺度操作。</p><p>&emsp;&emsp;（iv）如表1所示，对于没有任何长期时间依赖性的“ECG”和“引擎”数据集，LSTM-AD和RNN-AD的表现同样良好。另一方面，对于具有长期时间依赖性和短期依赖性的“航天飞机”和“电力需求”数据集，在$F_{0.1}-score$上LSTM-AD比RNN-AD分别显着提高了18％和30％。 </p><p>&emsp;&emsp;（v）“发动机”数据集故障前检测到的异常点的比例高于正常运行期间的异常点。这表明我们的方法可能对早期故障预测很有用。</p><img src="/2019/09/19/《Long-Short-Term-Memory-Networks-for-Anomaly-Detection-in-Time-Series》/3.png" title="Table 1: RNN和LSTM结构的精度，召回和$F_{0.1}-score$ 注意:（30-20）分别表示第一和第二隐藏层中的30和20个单位。"><h3 id="4-结论"><a href="#4-结论" class="headerlink" title="4.结论"></a>4.结论</h3><p>&emsp;&emsp;我们已经证明了（i）堆叠式LSTM网络能够在没有模式持续时间的先验知识的情况下学习更高级别的时间模式，因此（ii）堆叠的LSTM网络可能是建模正常时间序列行为的可行技术，然后可以用于检测异常。 我们的LSTM-AD方法在四个真实世界数据集上产生了有希望的结果，这些数据集涉及建模短期和长期时间依赖性。 与RNN-AD相比，LSTM-AD给出了更好或类似的结果，表明与基于RNN的模型相比，基于LSTM的预测模型可能更稳健，特别是当我们事先不知道正常行为是否涉及长期依赖性时。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] M. Basseville and I. V. Nikiforov. Detection of abrupt changes: theory and application. Prentice Hall, 1993.<br>[2] S. Hochreiter and J. Schmidhuber. Long short-term memory. Neural computation,9(8):1735–1780, 1997.<br>[3] M. Hermans and B. Schrauwen. Training and analysing deep recurrent neural networks. Advances in Neural Information Processing Systems 26, pages 190–198, 2013.<br>[4] D. George. How the brain might work: A hierarchical and temporal model for learning and recognition. PhD Thesis, Stanford University, 2008.<br>[5] P. Hayton et al. Static and dynamic novelty detection methods for jet engine health monitoring. Philosophical Transactions of the Royal Society of London, 365(1851):493–514, 2007.<br>[6] J. Ma and S. Perkins. Online novelty detection on temporal sequences. In Proceedings of the ninth ACM SIGKDD international conference on Knowledge discovery and data mining, pages 613–618. ACM, 2003. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.elen.ucl.ac.be/Proceedings/esann/esannpdf/es2015-56.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Long Short Term Memory Netwo
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://pl741.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="时间序列异常检测" scheme="http://pl741.github.io/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Detecting Spacecraf Anomalies Using LSTMs and Nonparametric Dynamic Thresholding》</title>
    <link href="http://pl741.github.io/2019/09/16/%E3%80%8ADetecting-Spacecraf-Anomalies-Using-LSTMs-and-Nonparametric-Dynamic-Thresholding%E3%80%8B/"/>
    <id>http://pl741.github.io/2019/09/16/《Detecting-Spacecraf-Anomalies-Using-LSTMs-and-Nonparametric-Dynamic-Thresholding》/</id>
    <published>2019-09-16T10:00:30.000Z</published>
    <updated>2019-10-09T03:11:31.363Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://arxiv.org/pdf/1802.04431.pdf" target="_blank" rel="noopener">Detecting Spacecraf Anomalies Using LSTMs and Nonparametric Dynamic Thresholding</a></p><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>异常检测&emsp;神经网络&emsp;RNN&emsp;LSTM&emsp;时间序列</p><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><h4 id="利用LSTMs进行遥测值预测"><a href="#利用LSTMs进行遥测值预测" class="headerlink" title="利用LSTMs进行遥测值预测"></a>利用LSTMs进行遥测值预测</h4><p>&emsp;&emsp;模型确定后，提供一种非参数、动态无监督的阈值方法来评估残差。</p><p>&emsp;&emsp;为每个单通道创建一个单独的模型，使用每个模型预测该通道的值。为每个通道单独建模还可以跟踪通道级别，实现航天器异常模式的细粒度检测。考虑时间序列$X=\left\{\mathbf{x}^{(1)}, \mathbf{x}^{(2)}, \ldots, \mathbf{x}^{(n)}\right\}$，其中时间序列中的每一步$\mathbf{x}^{(t)} \in R^{m}$为$m$维向量$\left\{x_{1}^{(t)}, x_{2}^{(t)}, \ldots, x_{m}^{(t)}\right\}$对应于输入向量，对于每个点$\mathbf{x}^{(t)}$，序列长度$l_s$决定输入模型进行预测的点的数量，预测长度$l_p$决定预测的步长，预测维度$d$的范围为$1 \leq d \leq m$。要预测单个通道的遥测值则$d=1$，同时使用$l_p=1$限制每个步骤$t$的预测数量，以减少运行时间。在每个步骤$t$为实际遥测值生成单个标量预测值$\hat{y}^{(t)}$。在本次实验中输入到LSTM中的$x^{(t)}$包括给定信道的先验遥测值和发送到航天器的编码命令信息。发出命令的模块和发送或接收命令的模块的组合是一个 one-hot 编码的模块，插入到每个步骤$t$中。</p><img src="/2019/09/16/《Detecting-Spacecraf-Anomalies-Using-LSTMs-and-Nonparametric-Dynamic-Thresholding》/1.png" title="图1. 每个时间步长$t$预测所用输入矩阵的可视化表示。将当前预测误差与过去预测误差进行比较，以确定是否异常"><h4 id="动态误差阈值"><a href="#动态误差阈值" class="headerlink" title="动态误差阈值"></a>动态误差阈值</h4><p>&emsp;&emsp;本文提出一种方法，可以在不做对过去平滑误差分布做高斯假设的情况下有效地标识极值。每一步$t$产生一个预测值$\hat{y}^{(t)}$，预测误差$e^{(t)}=\left|y^{(t)}-\hat{y}^{(t)}\right|$，其中$y^{(t)}=x_{i}^{(t+1)}$，其中$i$对应于真实遥测值得维度，将每个误差$e^{(t)}$添加到一维误差$e$ 向量中，</p><script type="math/tex; mode=display">\mathbf{e}=\left[e^{(t-h)}, \ldots, e^{\left(t-l_{s}\right)}, \ldots, e^{(t-1)}, e^{(t)}\right]</script><p>其中$h$表示用于评估当前误差的历史误差值的数量，然后对误差集$\mathbf e$进行平滑以抑制LSTM预测中的尖锐误差值，这些尖锐误差会影响预测结果，即使在正常情况下，也会出现误差值的急剧峰值。本文使用指数加权平均（EWMA）来产生平滑误差$\mathbf{e}_{s}=\left[e_{s}^{(t-h)}, \ldots, e_{s}^{(t-l s)}, \ldots, e_{s}^{(t-1)}, e_{s}^{(t)}\right]$。为评估这些值是否为正常值，本文将为平滑预测误差设置一个阈值，将阈值以上的平滑预测误差值对应的值分类为异常。</p><p>&emsp;&emsp;<strong>阈值计算和异常评分</strong>：本文提出一种无监督的异常阈值计算方法，可以在低开销、不使用标记数据或误差统计假设的情况下实现高效的阈值计算。阈值$\epsilon$从以下集合中选出：</p><script type="math/tex; mode=display">\boldsymbol{\epsilon}=\mu\left(\mathbf{e}_{s}\right)+\mathbf{z} \sigma\left(\mathbf{e}_{s}\right)</script><p>其中$\epsilon$取决于：</p><script type="math/tex; mode=display">\epsilon=\arg \max (\boldsymbol{\epsilon})=\frac{\Delta \mu\left(\mathbf{e}_{s}\right) / \mu\left(\mathbf{e}_{s}\right)+\Delta \sigma\left(\mathbf{e}_{s}\right) / \sigma\left(\mathbf{e}_{s}\right)}{\left|\mathbf{e}_{a}\right|+\left|\mathbf{E}_{s e q}\right|^{2}}</script><p>其中：</p><script type="math/tex; mode=display">\begin{array}{l}{\Delta \mu\left(\mathbf{e}_{s}\right)=\mu\left(\mathbf{e}_{s}\right)-\mu\left(\left\{e_{s} \in \mathbf{e}_{s} | e_{s}<\epsilon\right\}\right)} \\ {\Delta \sigma\left(\mathbf{e}_{s}\right)=\sigma\left(\mathbf{e}_{s}\right)-\sigma\left(\left\{e_{s} \in \mathbf{e}_{s} | e_{s}<\epsilon\right\}\right)} \\ {\mathbf{e}_{a}=\left\{e_{s} \in \mathbf{e}_{s} | e_{s}>\epsilon\right\}} \\ {\mathbf{E}_{s e q}=\text { continuous sequences of } e_{a} \in \mathbf{e}_{a}}\end{array}</script><p>使用$z \in \mathbf{z}$来确定$\epsilon$的评估值，其中$\mathbf z$是一个有序正值集，表示标准差大于$\mu\left(\mathbf{e}_{s}\right)$的数量。$\mathbf z$的值取决于上下文，但根据实验结果，$2 - 10$之间的范围可以很好的工作。$z &lt;2$的值通常会导致过多的假阳性。一旦确定了$\arg \max (\boldsymbol{\epsilon})$，每个得到的平滑错误序列$\mathbf{e}_{s e q} \in \mathbf{E}_{s e q}$都会得到一个异常分数$s$，用来表示异常的严重程度：</p><script type="math/tex; mode=display">s^{(i)}=\frac{\max \left(\mathbf{e}_{s e q}^{(i)}\right)-\arg \max (\boldsymbol{\epsilon})}{\mu\left(\mathbf{e}_{s}\right)+\sigma\left(\mathbf{e}_{s}\right)}</script><p>也就是说，如果找到一个阈值，去掉超过它的所有值，平滑误差$\mathbf e_{s}$的均值和标准差都会下降最大的百分比。该函数还惩罚具有最大异常值$\left(\left|\mathbf{e}_{a}\right|\right)$和序列$\left(\left|\mathbf{E}_{s e q}\right|\right)$以防止过度贪心行为。然后根据每个异常误差序列到所选阈值的距离，给出平滑误差最大值的归一化分数。</p><h4 id="减少误报"><a href="#减少误报" class="headerlink" title="减少误报"></a>减少误报</h4><p>&emsp;&emsp;<strong>修剪异常</strong>：基于预测的异常检测方法的精度很大程度上取决于用于设置阈值和判定当前预测误差的历史数据量$(h)$。为了减少误报、限制内存和计算成本，我们引入了一个剪枝过程，创建一个新集合$\mathbf{e}_{m a x}$，包含按照降序排序的所有$\mathbf{e}_{s e q}$的$\max \left(\mathbf{e}_{s e q}\right)$。同时在$\mathbf e_{max}$的末尾添加一个非异常$\max \left(\left\{e_{s} \in \mathbf{e}_{s} \in \mathbf{E}_{s e q} | e_{s} \in \mathbf{e}_{a}\right\}\right)$的最大平滑误差。之后以增量的方式逐步执行序列，计算每一步的减少百分比$d^{(i)}=\left(e_{\max }^{(i-1)}-e_{\max }^{(i)}\right) / e_{\max }^{(i-1)}$，其中$i \in\left\{1,2, \ldots,\left(\left|\mathbf{E}_{s e q}\right|+1\right)\right\}$。如果在某个步骤$i$中，$d^{(i)}$超过了最小百分比降幅$p$，则所有$e_{m a x}^{(j)} \in \mathbf{e}_{m a x} | j&lt;i$及其对应的异常序列均为异常。如果$d^{(i)}$没有满足最小减少量$p$，对于所有后续平滑的误差序列$d^{(i)}, d^{(i+1)}, \ldots, d^{\left(i+\left|\mathbf{E}_{s e q}\right|+1\right)}$都将被重新分类为正常误差。这种剪枝有助于确保异常序列不是流中常规噪声的结果，并且可通过阈值处理来初始识别异常序列。将评估仅限于少数潜在异常序列中的最大误差比没有阈值处理所需的大量值 - 值比较要有效得多。</p><img src="/2019/09/16/《Detecting-Spacecraf-Anomalies-Using-LSTMs-and-Nonparametric-Dynamic-Thresholding》/2.png" title="图2. 展示异常修剪过程的例子"><p>&emsp;&emsp;在这种情况下，$\mathbf{e}_{m a x}=[0.01396,0.01072,0.00994]$，最小下降百分比 $p=0.1$。从异常$2$到异常$1$的下降幅度为 $d^{(1)}=0.23&gt;p$，该序列保留为异常分类。从异常$1$到下一个最高平滑误差$\left(e_{s}=0.0099 \right)$的下降幅度为 $d^{(2)}=.07&lt;p$，因此这个序列被重新分类为正常序列。</p><p>&emsp;&emsp;<strong>学习历史数据</strong>：一旦收集到少量异常历史纪录或标记数据，就可以使用这种学习策略来抑制假阳性。基于相似度$s$的异常通常不会在同一频道内频繁重复出现的假设，可以设置最小分数$s_{min}$，以便在$\boldsymbol{s}&lt;\boldsymbol{s}_{\min }$时，将未来的异常重新分类为正常。最低分数只适用于系统产生异常率超过某一比率的数据通道，并为所有这些通道单独设置$s_{min}$。可以使用通道的先验异常得分来设置适当的$s_{min}$，具体取决于精确度和召回率之间的期望平衡。此外，如果异常检测系统有一种机制，用户可以通过该机制为异常提供标签，那么这些标签还可以用于为给定流设置$s_{min}$。例如，如果一个流或通道有多个合并的假阳性异常，那么$s_{min}$可以设置在这些假阳性异常分数的上界附近。</p><img src="/2019/09/16/《Detecting-Spacecraf-Anomalies-Using-LSTMs-and-Nonparametric-Dynamic-Thresholding》/3.png" title="图3 包含上下文异常的遥测流命令信息编码"><p>&emsp;&emsp;这种异常不太可能使用基于限制或距离的方法进行识别。使用已编码的命令信息和信道的先前遥测值生成下一个时间步骤的预测，并产生误差。在这个例子中，一步预测和实际遥测值非常接近，如顶部时间序列所示。利用非参数阈值化方法设置误差阈值，得到标记异常区域内的两个预测异常序列，一个为假阳性，一个为真阳性。假阳性表明需要对序列进行修剪，如果该序列相对接近阈值以下的值，则将该序列重新分类为正常序列（参见图2）。</p><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>&emsp;&emsp;我们将异常分为两类：点异常和上下文异常，以区分可能由适当设置的警报或忽略时间信息的基于距离的方法（点异常）识别的异常和需要更复杂的方法（如LSTMs或分层时间记忆（HTM）方法）来检测（上下文异常）的异常。这个特征是从前面提到的三个类别中改编而来的——点异常、上下文异常、集合异常。由于上下文异常和集合异常都需要时间上下文，并且比较难以检测，因此它们都被合并到上下文类别中。</p><p>&emsp;&emsp;<strong>设置：</strong>对于主要发生在时间$t_{a}$包含一个或多个异常序列的每个唯一数据流，我们评估从$t_{s}=t_{a}-3 d$到$t_{f}=t_{a}+2 d$ 时间帧之间的所有遥测值， 其中$d$表示天。使用从$t_{s_{\text {train}}}=t_{s}-2 d$到$t_{f_{\text {train}}}=t_{s}$的值和命令数据为每个唯一流训练模型。如果在这些时间范围内没有足够的数据，则增加额外的天数。5天的异常周期被选择用来平衡两个目标：精度和计算成本。预测异常区域略微扩大，以便将扩展后重叠或邻近的异常区域合并为一个区域，来解释多个异常区域代表一个时间的情况。根据系统识别出的最后一组预测异常序列，对每个标记的遥测异常序列$x_{a} \in \mathbf{x}_{a}$按照下面规则进行评估：</p><p>&emsp;&emsp;（1）真阳性：</p><script type="math/tex; mode=display">\left|e_{a}^{(t)} \in e_{s e q} \in \mathbf{e}_{s e q} : x_{i}^{(t)} \in x_{a}\right|>0</script><p>&emsp;&emsp;对于任意的$x_{a} \in \mathbf{x}_{a}$，换句话说，预测异常序列的任何一部分都属于任何真实标记序列，则结果为真阳性。即使许多预测序列的一部分属于标记序列也仅纪录一个真阳性。</p><p>&emsp;&emsp;（2）如果没有预测序列与阳性标记序列重叠，标记为假阴性。</p><p>&emsp;&emsp;（3）所有没有与标记异常区域重叠的预测序列，标记为假阳性。</p><p>&emsp;&emsp;为简单起见，我们不会根据检测到异常的早期程度或误报与标记区域之间的距离进行评分调整。</p><p>&emsp;&emsp;<strong>批处理：</strong>遥测数据被聚合到一分钟窗口中，按照SMAP和当前系统实现的下行计划，以70分钟/组进行评估。使用$h=2100$计算每70分钟批处理的值，其中$h$是用于计算错误阈值和评估当前批处理的先前值的数量。该系统还非常适合以实时流式方式处理值。</p><p>&emsp;&emsp;<strong>模型参数和评估：</strong>在实验中所有模型使用相同的架构和参数：</p><img src="/2019/09/16/《Detecting-Spacecraf-Anomalies-Using-LSTMs-and-Nonparametric-Dynamic-Thresholding》/4.png"><p>&emsp;&emsp;每个模型都是只含有两层隐藏层和80个（/层）单元的浅层模型。我们发现这种结构能够提供足够的能力来很好的预测单个通道，增加额外的能力在增加模型大小和训练时间的同时对提供预测效益没有任何用处。所有通道不一定都需要这么大的容量，未来的改进可能包括根据信道复杂度自动选择合适的模型容量。类似地，序列长度$l_{s}=250$提供了性能和训练时间之间的平衡。SMAP和MSL在输入维度上的差异是由于每个任务都有不同的命令模块集。在模型训练过程中，早期停止被用来防止过度拟合，并不是所有的模型都经过了完整35次迭代的训练。预测生成后，采用3.2节的方法计算平滑误差的异常阈值，其中$\mathbf{z}=\{2.5,3.0,3.5, \ldots, 10.0\}$，并且后续异常值之间的最小百分比只差$p=0.13$。参数$p$是控制精确度和召回率的重要标准，当标签可用时可推断出一个适当的值。在我们的设置中，在$0.05&lt;p&lt;0.20$达到了合理的结果。</p><img src="/2019/09/16/《Detecting-Spacecraf-Anomalies-Using-LSTMs-and-Nonparametric-Dynamic-Thresholding》/5.png" title="图4 参数方法和本文提出的方法（标记为“非参数”）在不同参数设置下的总体精度和召回结果的比较的图。"><p>&emsp;&emsp;<strong>参数阈值比较：</strong>使用原始的LSTM进行误差预测，我们还使用参数误差评估方法生成异常，该方法与Numenta异常基准的最精确模型相协调。这种方法递增地处理原始误差-在每个步骤$t$，将历史误差的窗口$W$建模为正态分布，并且在每个步骤$t$更新均值$μ_{w}$和方差$σ_{W}^{2}$。我们设置$W$的长度为$l_{w}=h=2100$，并对两种方法使用相同的预测误差集。然后计算预测误差长度$l_{short}$的短期平均值$μ_{s}$，其平滑效果与第3.2节中的EWMA平滑相似。然后使用尾概率$Q$来定义异常$L$的可能性:</p><script type="math/tex; mode=display">L=1-Q\left(\frac{\mu_{s}-\mu_{W}}{\sigma_{W}^{2}}\right)</script><p>如果$L \geq 1-\epsilon_{n o r m}$的值为分类为异常。在下一节中，使用$l_{short}=10$和$\epsilon_{n o r m}=\{0.01,0.0001\}$生成的结果与3.2节中的方法进行比较。</p><h3 id="复现实验"><a href="#复现实验" class="headerlink" title="复现实验"></a>复现实验</h3><p>&emsp;&emsp;GitHub地址：<a href="https://github.com/khundman/telemanom" target="_blank" rel="noopener">https://github.com/khundman/telemanom</a></p><p>&emsp;&emsp;<strong>遥测数据：包含两个分支</strong>  </p><p>&emsp;&emsp;&emsp;1.  master：包含标记异常的数据并用于复现KDD论文中的实验<br>&emsp;&emsp;&emsp;2.  no-labels：未标记的数据（一组时间序列流）</p><p>&emsp;&emsp;<strong>开始</strong>：</p><p>&emsp;&emsp;&emsp;克隆仓库——<code>git clone https://github.com/khundman/telemanom.git &amp;&amp; cd telemanom</code></p><p>&emsp;&emsp;&emsp;Curl和Unzip数据——<code>curl -O https://s3-us-west-2.amazonaws.com/telemanom/data.zip &amp;&amp; unzip data.zip &amp;&amp; rm data.zip</code></p><p>&emsp;&emsp;&emsp;使用Python 3.6+安装依赖项——<code>pip install -r requirements.txt</code></p><p>&emsp;&emsp;&emsp;在<code>config.yaml</code>文件中配置系统/模型参数：<br>&emsp;&emsp;&emsp;&emsp;&emsp;<code>train:</code> 如果是<code>True</code>，将为每个输入流训练一个新模型；如果是 <code>False</code> ，将加载现有的训练模型并用于生成预测。<br>&emsp;&emsp;&emsp;&emsp;&emsp;<code>predict:</code> 如果是<code>Ture</code>，使用模型生成新的预测；如果是<code>False</code>，请在评估中使用现有的已保存预测（用于调整错误阈值并跳过先前的处理步骤）<br>&emsp;&emsp;&emsp;&emsp;&emsp;<code>l_s:</code> 250 确定在每个时间步$t$上输入到模型的先前时间步数（用于生成预测）</p><p>&emsp;&emsp;&emsp;开始实验——<code>python run.py</code></p><p>&emsp;&emsp;&emsp;利用<code>Jupyter notebook</code>来进行结果评估并比较不同参数的运行结果在<code>results/</code>下提供。启动notebook——<code>jupyter notebook results/result-viewer.ipynb</code><br>&emsp;&emsp;&emsp;Plotly用于生成交互式内联图，例如：</p><img src="/2019/09/16/《Detecting-Spacecraf-Anomalies-Using-LSTMs-and-Nonparametric-Dynamic-Thresholding》/6.png"><p>&emsp;&emsp;<strong>数据</strong>：</p><p>&emsp;&emsp;&emsp;&emsp;<strong>使用你自己的数据</strong></p><p>&emsp;&emsp;&emsp;首先划分数据集为训练数据集和测试数据集并分别放在<code>data/train/</code>和<code>data/test/</code>文件夹下。对于训练集和测试集为每个通道或流生成形状为<code>(n_timesteps, n_inputs)</code>的一个<code>.npy</code>文件。每个文件名应该具有唯一的名称或ID。在测试数据中预测的遥测值必须是输入中的第一个特征。</p><p>&emsp;&emsp;&emsp;例如，<code>T-1</code>通道应该具有被命名为<code>T-1.npy</code>的训练集/测试集，形状类似于<code>(4900, 61)</code>和<code>(3925, 61)</code>，其中输入维度大小是<code>(61)</code>。实际遥测值应沿第一维<code>(4900, 1)</code>和<code>(3925, 1)</code>。</p><p>&emsp;&emsp;&emsp;&emsp;<strong>原始数据</strong></p><p>&emsp;&emsp;&emsp;可供下载的原始数据代表了来自SMAP卫星和MSL卫星真实的航天器遥测数据和异常。所有数据都已在时间上匿名化，并且所有遥测值都根据测试集中的最小值/最大值在<code>(-1,1)</code>之间预先缩放。通道ID也被匿名化，但是第一个字母表示出通道的类型（<code>P</code>=功率，<code>R</code>=辐射）。模型输入数据还包括有关特定航天器模块在给定时间窗口内发送或接收的命令的<code>one-hot</code>编码信息。模型输入数据还包括有关特定航天器模块在给定时间窗口内发送或接收的命令的一键编码信息。数据中不包含与命令的时间或特性有关的识别信息。 例如：</p><img src="/2019/09/16/《Detecting-Spacecraf-Anomalies-Using-LSTMs-and-Nonparametric-Dynamic-Thresholding》/3.png"><p>&emsp;&emsp;&emsp;此数据还包括使用<code>config.yaml</code>中的默认设置生成的预分割测试和训练数据，预训练模型，预测和平滑错误。当熟悉仓库时，可通过运行<code>result-viewer.ipynb</code>来可视化结果。数据对于隔离系统的各个部分也很有用。例如，如果你希望在不训练新模型的情况下看到阈值参数更改的影响，可以在<code>config.yaml</code>中将<code>Train</code>和<code>Predict</code>设置为<code>False</code>，以使用从之前模型生成的预测。</p><p>&emsp;&emsp;<strong>异常标签和元数据</strong>：</p><p>&emsp;&emsp;&emsp;异常标签和元数据可在<code>labeled_anomalies.csv</code>中使用，包括：</p><p>&emsp;&emsp;&emsp; <code>channel_id</code>: 匿名的频道ID———首字母代表频道的性质（<code>P</code>=功率，<code>R</code>=辐射）。<br>&emsp;&emsp;&emsp; <code>spacecraft</code>: 产生遥测流的航天器<br>&emsp;&emsp;&emsp; <code>anomaly_sequences</code>: 流中真实异常开始和结束的索引<br>&emsp;&emsp;&emsp; <code>class</code>: 异常的类别<br>&emsp;&emsp;&emsp; <code>num values</code>: 每个流中的遥测值数量</p><p>&emsp;&emsp;&emsp;要提供自己的标签，请使用<code>labeled_anomalies.csv</code>文件作为模板。  唯一需要的字段/列是<code>channel_id</code>和<code>anomaly_sequences</code>。 <code>anomaly_sequences</code>是列表中的一列，其中包含通道的测试数据集中异常区域的开始和结束索引。</p><p>&emsp;&emsp;<strong>数据集和性能统计</strong>：</p><p>&emsp;&emsp;&emsp;&emsp;数据：</p><img src="/2019/09/16/《Detecting-Spacecraf-Anomalies-Using-LSTMs-and-Nonparametric-Dynamic-Thresholding》/7.png"><p>&emsp;&emsp;&emsp;&emsp;性能统计：</p><img src="/2019/09/16/《Detecting-Spacecraf-Anomalies-Using-LSTMs-and-Nonparametric-Dynamic-Thresholding》/8.png"><p>&emsp;&emsp;<strong>处理</strong>：</p><p>&emsp;&emsp;每次启动系统时，唯一的日期时间ID（例如2018-05-17_16.28.00）将用于创建以下内容:</p><p>&emsp;&emsp;<code>results</code>文件：（在<code>results /</code>中），该文件扩展了<code>labeled_anomalies.csv</code>包括已识别的异常序列和相关信息。</p><p>&emsp;&emsp;<code>data subdirectory</code>: 包含用于每个通道的已创建模型，预测和平滑错误的数据文件。 还创建了一个名为<code>params.log</code>的文件，其中包含参数设置和处理期间的日志记录输出。</p><p>&emsp;&emsp;如前所述，jupyter notebook的<code>results / result-viewer.ipynb</code>可用于可视化每个流的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1802.04431.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Detecting Spacecraf Anomalies Using LSTMs and Nonparametric
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://pl741.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="时间序列异常检测" scheme="http://pl741.github.io/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>使用链接</title>
    <link href="http://pl741.github.io/2019/09/16/%E9%93%BE%E6%8E%A5/"/>
    <id>http://pl741.github.io/2019/09/16/链接/</id>
    <published>2019-09-16T07:38:06.000Z</published>
    <updated>2019-09-16T10:09:59.426Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="noopener">搭建个人博客</a></p><p><a href="http://blog.rexking6.top/2017/03/30/hexo%E4%B8%BB%E9%A2%98%E5%92%8C%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E3%80%81%E6%89%93%E8%B5%8F%E3%80%81%E6%90%9C%E7%B4%A2%E3%80%81%E9%98%85%E8%AF%BB%E9%87%8F%E7%AD%89%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">博客个性化设置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/4eaddcbe4d12&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;搭建个人博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.rexking6.top/2017/
      
    
    </summary>
    
    
    
      <category term="配置" scheme="http://pl741.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>机器学习评价标准</title>
    <link href="http://pl741.github.io/2019/09/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86/"/>
    <id>http://pl741.github.io/2019/09/16/机器学习评价标准/</id>
    <published>2019-09-16T05:38:06.000Z</published>
    <updated>2019-09-16T07:24:19.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p><strong>True真&emsp; False假&emsp;Positive正&emsp;Negative负</strong></p><p>&emsp;&emsp;异常检测中，P和N一般是针对预测来说的，Positive正类指的是你更关心的那一类！即“异常”，P指预测为正类，即预测为异常。T和F针对预测与真实情况的比较， True指正确匹配，F指错误匹配。</p><div class="table-container"><table><thead><tr><th></th><th style="text-align:center">实际正例</th><th style="text-align:center">实际负例</th><th style="text-align:center"></th></tr></thead><tbody><tr><td>预测正例P</td><td style="text-align:center">TP</td><td style="text-align:center">FP</td><td style="text-align:center">所有预测为正的个数TP+FP</td></tr><tr><td>预测负例N</td><td style="text-align:center">FN</td><td style="text-align:center">TN</td><td style="text-align:center">所有预测为负的个数FN+TN</td></tr><tr><td></td><td style="text-align:center">所有实际正例的个数TP+FN</td><td style="text-align:center">所有实际负例的个数FP+TN</td></tr></tbody></table></div><img src="/2019/09/16/机器学习评价标准/72.png"><ul><li><p>TPR：真正类率，代表预测是异常实际也是异常的样本数，占实际总异常数的比例——值越大 性能越好</p></li><li><p>FPR：假正类率，代表预测是异常但实际是正常的样本数，占实际正常总数的比例——值越小 性能越好</p></li><li><p>R：召回率，意义同TPR——值越大 性能越好</p></li><li><p>P：精确率Precision，代表预测是异常实际也是异常的样本数，占预测是异常的总数的比例——值越大 性能越好</p></li><li><p>F：P和R的加权调和平均，常用的是F1值——值越大 性能越好</p></li><li><p>A：正确率Accuracy，与精确率的区别是，不仅考虑异常类也考虑正常类，即所有匹配样本数，占所有样本的比例——值越大 性能越好</p></li></ul><p>另外还有两个，分别为：虚警率和漏警率</p><ul><li>虚警率（<strong>False alarm</strong>）表示负类样本被分为正类样本在所有负类样本中的比例</li></ul><img src="/2019/09/16/机器学习评价标准/71.png"><ul><li>漏警率表示（漏警率表示（Missing alarm）表示正类样本被分为负类样本在所有正类样本中的比例Missing alarm）表示正类样本被分为负类样本在所有正类样本中的比例</li></ul><img src="/2019/09/16/机器学习评价标准/70.png"><h1 id="Tensorflow实现"><a href="#Tensorflow实现" class="headerlink" title="Tensorflow实现"></a>Tensorflow实现</h1><p><strong>&emsp;损失值：</strong><br>    tf.nn.softmax_cross_entropy_with_logits(logits, labels, name=None)<br><strong>&emsp;参数解析：</strong><br>&emsp; logits:神经网络最后一层的输出，如果有batch，大小为[batch_size, n_classes]<br>&emsp; labels:实际标签，大小同上</p><p><strong>&emsp;执行过程：</strong><br>&emsp;&emsp;先对网络最后一层的输出做一个softmax，通常是求取输出属于某一类的概率，对于单样本而言，输出就是一个num_classes大小的向量。</p><img src="/2019/09/16/机器学习评价标准/73.png"><p>&emsp;然后将softmax的输出向量与样本的实际标签做一个交叉熵。</p><img src="/2019/09/16/机器学习评价标准/74.png"><p>&emsp;其中 y’ 指代实际的标签中第i个的值（用mnist数据举例，如果是3，那么标签是[0，0，0，1，0，0，0，0，0，0]，除了第4个值为1，其他全为0）; y就是softmax的输出向量[Y1，Y2,Y3…]中，第i个元素的值</p><p>&emsp;&emsp;显而易见，预测越准确，结果的值越小（别忘了前面还有负号），最后求一个平均，得到我们想要的loss</p><p>&emsp;&emsp;注意！！！这个函数的返回值并不是一个数，而是一个向量，如果要求交叉熵，我们要再做一步tf.reduce_sum操作,就是对向量里面所有元素求和，最后才得到H(y)，如果求loss，则要做一步tf.reduce_mean操作，对向量求均值！</p><pre><code>tf.reduce_mean(input_tensor, axis=None,keep_dims=False,name=None,               reduction_indices=None)</code></pre><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><ul><li>&emsp; 第一个参数input_tensor： 输入的待降维的tensor;</li><li>&emsp; 第二个参数axis： 指定的轴，如果不指定，则计算所有元素的均值;</li><li>&emsp; 第三个参数keep_dims：是否降维度，设置为True，输出的结果保持输入tensor的形状，设置为False，输出结果会降低维度;</li><li>&emsp; 第四个参数name： 操作的名称;</li><li>&emsp; 第五个参数 reduction_indices：在以前版本中用来指定轴，已弃用;</li></ul><p>&emsp;predict是预测结果，也就是神经网络的输出，real是真实的标签，sess就是tensorflow当前的会话，feed_dict是需要喂的数据。</p><p>&emsp;tf.equal(A, B)是对比这两个矩阵或者向量的相等的元素，如果是相等的那就返回True，反正返回False，返回的值的矩阵维度和A是一样的。</p><p>&emsp;tf.cast()函数的作用是执行 tensorflow 中张量数据类型转换，<br>    tf.cast(x, dtype, name=None)</p><h4 id="参数解析-1"><a href="#参数解析-1" class="headerlink" title="参数解析"></a>参数解析</h4><ul><li>&emsp;第一个参数 x:   待转换的数据（张量）</li><li>&emsp;第二个参数 dtype： 目标数据类型</li><li>&emsp;第三个参数 name： 可选参数，定义操作的名称</li></ul><p>&emsp;tf.loical_and()将数值变成逻辑值<br>    tf.logical_and(x, y, name=None)</p><p>&emsp;tf.argmax()返回值是是数值最大值的索引位置，如果最大值位置相同，则分类正确，反之则分类错误<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">predictions = tf.argmax(predict, <span class="number">1</span>)</span><br><span class="line">actuals = tf.argmax(real, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上述获得的变量设置成元素为0或者为1的矩阵</span></span><br><span class="line">ones_like_actuals = tf.ones_like(actuals)</span><br><span class="line">zeros_like_actuals = tf.zeros_like(actuals)</span><br><span class="line">ones_like_predictions = tf.ones_like(predictions)</span><br><span class="line">zeros_like_predictions = tf.zeros_like(predictions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照前面的计算公式编写如下计算代码</span></span><br><span class="line"></span><br><span class="line">tp_op = tf.reduce_sum(tf.cast(tf.logical_and(</span><br><span class="line">            tf.equal(actuals, ones_like_actuals),</span><br><span class="line">            tf.equal(predictions, ones_like_predictions)),<span class="string">"float"</span>))</span><br><span class="line"> </span><br><span class="line">tn_op = tf.reduce_sum(tf.cast(tf.logical_and(</span><br><span class="line">            tf.equal(actuals, zeros_like_actuals),</span><br><span class="line">            tf.equal(predictions, zeros_like_predictions)),<span class="string">"float"</span>))</span><br><span class="line"> </span><br><span class="line">fp_op = tf.reduce_sum(tf.cast(tf.logical_and(</span><br><span class="line">            tf.equal(actuals, zeros_like_actuals),</span><br><span class="line">            tf.equal(predictions, ones_like_predictions)),<span class="string">"float"</span>))</span><br><span class="line"> </span><br><span class="line">fn_op = tf.reduce_sum(tf.cast(tf.logical_and(</span><br><span class="line">            tf.equal(actuals, ones_like_actuals),</span><br><span class="line">            tf.equal(predictions, zeros_like_predictions)),<span class="string">"float"</span>))</span><br><span class="line">            </span><br><span class="line">tp, tn, fp, fn = session.run([tp_op, tn_op, fp_op, fn_op], feed_dict)</span><br><span class="line">tpr = float(tp)/(float(tp) + float(fn))</span><br><span class="line">fpr = float(fp)/(float(fp) + float(tn))</span><br><span class="line">fnr = float(fn)/(float(tp) + float(fn))</span><br><span class="line">accuracy = (float(tp) + float(tn))/(float(tp) + float(fp) + float(fn) + float(tn))</span><br><span class="line">recall = tpr</span><br><span class="line">precision = float(tp)/(float(tp) + float(fp))</span><br><span class="line">f1_score = (<span class="number">2</span> * (precision * recall)) / (precision + recall)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本内容&quot;&gt;&lt;a href=&quot;#基本内容&quot; class=&quot;headerlink&quot; title=&quot;基本内容&quot;&gt;&lt;/a&gt;基本内容&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;True真&amp;emsp; False假&amp;emsp;Positive正&amp;emsp;Negative负&lt;/stro
      
    
    </summary>
    
    
    
      <category term="机器学习" scheme="http://pl741.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>jupyter主题设置</title>
    <link href="http://pl741.github.io/2019/09/16/jupyter_%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/"/>
    <id>http://pl741.github.io/2019/09/16/jupyter_主题设置/</id>
    <published>2019-09-16T05:38:06.000Z</published>
    <updated>2019-09-16T09:57:34.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jupyter-主题设置"><a href="#jupyter-主题设置" class="headerlink" title="jupyter 主题设置"></a>jupyter 主题设置</h2><p>安装主题：pip install jupyterthemes</p><p>如果之前安装过可以更新一下：pip install —upgrade jupyterthemes</p><p>设置主题：蓝色主题——jt -t onedork -fs 95 -altp -tfs 11 -nfs 115 -cellw 88% -T</p><p>​                    黑色主题——jt -t monokai -f fira -fs 13 -cellw 90% -ofs 11 -dfs 11 -T -N</p><p>​                    部分参数：-f(字体)  -fs(字体大小) -cellw(占屏比或宽度)  </p><p>​                                      -ofs(输出段的字号)  -T(显示工具栏)  -N(显示自己主机名)</p><h4 id="Conda环境自由切换："><a href="#Conda环境自由切换：" class="headerlink" title="Conda环境自由切换："></a>Conda环境自由切换：</h4><p>​        看一下是否已经把 Anaconda 中创建的所有定制环境作为核心添加在了 Jupyter Notebook 中。这样我们就能简单地利用 Kernel 按钮切换环境。换核的时候不需要重启 notebook。</p><p>​        假设你的 Anaconda 环中有两个自定义的环境 my_NLP 和 gym。按照下面的步骤将这些添加到你的 Jupyter Notebook 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conda activate my_NLP</span><br><span class="line"># Install the IPython Kernel </span><br><span class="line">pip install ipykernel</span><br><span class="line"># Link your environment with Jupyter </span><br><span class="line"># Repeat steps for the other environment, gym</span><br><span class="line">python -m ipykernel install --user --name=my_NLP</span><br><span class="line">pip install ipykernel </span><br><span class="line">python -m ipykernel install --user --name=gym</span><br></pre></td></tr></table></figure><p>​        现在打开你的 Jupyter Notebook，找到 kernel 按钮下的 Change Kernel 选项，接下来就是见证奇迹的时刻：所有的核都被列举出来了，你可以通过简单地点击来激活一个服务核。</p><h4 id="其他功能："><a href="#其他功能：" class="headerlink" title="其他功能："></a>其他功能：</h4><p>​        安装 nbextensions for Jupyter Notebooks</p><p>​        安装 nbextensions 是很容易的，简单地遵循下面的步骤就行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Stop and exit your Jupyter Notebook server </span><br><span class="line"># Make sure you are in the base environment</span><br><span class="line">conda activate base</span><br><span class="line"># Install the nbextensions </span><br><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line"># Install the necessary JS and CSS files </span><br><span class="line">jupyter contrib nbextension install --system</span><br></pre></td></tr></table></figure><p>​        启动 Jupyter notebook 服务，你可以在起始页看到第四个叫做 Nbextensions 的选项。点击这个选项，然后就可以看到极妙的功能集，这些都是你一直希望在 Jupyter Notebooks 中拥有的。</p><p>其中一些的简单介绍：</p><p>​          Table of Contents(2)：单击生成整个笔记本的目录，不同的 section 都有对应的超链接。</p><p>​         Scratchpad：在我看来绝对是最好的扩展了。这是一个你可以在里面做代码实验的独立空间，不会干扰笔记本中的其他部分。</p><p>​        Codefolding ：代码折叠，这个不需要做过多的解释。</p><p>​        Hide Input All：隐藏所有的代码单元，同时保持所有的输出和 markdown 单元可见。如果你要向非技术人员解释你的结果，那么这就会是一个很有用的功能。</p><p>​        Variable Inspector：将你从调试的忧伤中拯救出来，这与 Spyder IDE 中的变量检查窗口有些类似。</p><p>​        Spellchecker：对 markdown 单元中的内容进行拼写检查。</p><p>​        Zenmode：移除掉屏幕中杂乱无关的内容，以便你能够聚焦于重要的东西上，例如代码。</p><p>​        Snippets Menu：从 list comprehension 到 pandas 以及它们之间的所有常用代码片段的一个很酷的集合。这是最好的部分？你可以修改窗口的小部件来添加你自己的定制片段。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jupyter-主题设置&quot;&gt;&lt;a href=&quot;#jupyter-主题设置&quot; class=&quot;headerlink&quot; title=&quot;jupyter 主题设置&quot;&gt;&lt;/a&gt;jupyter 主题设置&lt;/h2&gt;&lt;p&gt;安装主题：pip install jupyterthemes
      
    
    </summary>
    
    
    
      <category term="配置" scheme="http://pl741.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
