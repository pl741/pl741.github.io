<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木木的笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-16T05:29:45.491Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>木木</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>评价标准</title>
    <link href="http://yoursite.com/2019/09/16/%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86/"/>
    <id>http://yoursite.com/2019/09/16/评价标准/</id>
    <published>2019-09-16T05:12:47.864Z</published>
    <updated>2019-09-16T05:29:45.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p><strong>True真    False假    Positive正     Negative负</strong></p><p>异常检测中，P和N一般是针对预测来说的，Positive正类指的是你更关心的那一类！即“异常”，P指预测为正类，即预测为异常。T和F针对预测与真实情况的比较， True指正确匹配，F指错误匹配。<br>空| 实际正例|实际负例|<br> —|:–:|:–:|:–:<br> 预测正例P | TP | FP|所有预测为正的个数TP+FP<br> 预测负例N | FN | TN |所有预测为负的个数FN+TN<br>  | 所有实际正例的个数TP+FN | 所有实际负例的个数FP+TN |</p><p><img src="/2019/09/16/评价标准/C:%5CUsers%5Cwarrior%5Cpl741.github.io%5Csource_posts%5C72.png" alt="img"></p><p>TPR：真正类率，代表预测是异常实际也是异常的样本数，占实际总异常数的比例——值越大 性能越好</p><p>FPR：假正类率，代表预测是异常但实际是正常的样本数，占实际正常总数的比例——值越小 性能越好</p><p>R：召回率，意义同TPR——值越大 性能越好</p><p>P：精确率Precision，代表预测是异常实际也是异常的样本数，占预测是异常的总数的比例——值越大 性能越好</p><p>F：P和R的加权调和平均，常用的是F1值——值越大 性能越好</p><p>A：正确率Accuracy，与精确率的区别是，不仅考虑异常类也考虑正常类，即所有匹配样本数，占所有样本的比例——值越大 性能越好</p><p>另外还有两个，分别为：虚警率和漏警率</p><p>虚警率（<strong>False alarm</strong>）表示负类样本被分为正类样本在所有负类样本中的比例</p><p><img src="/2019/09/16/评价标准/C:%5CUsers%5Cwarrior%5Cpl741.github.io%5Csource_posts%5C71.png" alt="img"></p><p>漏警率表示（漏警率表示（Missing alarm）表示正类样本被分为负类样本在所有正类样本中的比例Missing alarm）表示正类样本被分为负类样本在所有正类样本中的比例</p><p><img src="/2019/09/16/评价标准/C:%5CUsers%5Cwarrior%5Cpl741.github.io%5Csource_posts%5C70.png" alt="img"></p><h1 id="Tensorflow实现"><a href="#Tensorflow实现" class="headerlink" title="Tensorflow实现"></a>Tensorflow实现</h1><h3 id="损失值："><a href="#损失值：" class="headerlink" title="损失值："></a>损失值：</h3><pre><code>tf.nn.softmax_cross_entropy_with_logits(logits, labels, name=None)</code></pre><h4 id="参数解析："><a href="#参数解析：" class="headerlink" title="参数解析："></a>参数解析：</h4><p>&emsp; logits:神经网络最后一层的输出，如果有batch，大小为[batch_size, n_classes]<br>&emsp; labels:实际标签，大小同上</p><h4 id="执行过程："><a href="#执行过程：" class="headerlink" title="执行过程："></a>执行过程：</h4><p>&emsp;先对网络最后一层的输出做一个softmax，通常是求取输出属于某一类的概率，对于单样本而言，输出就是一个num_classes大小的向量</p><p><img src="/2019/09/16/评价标准/C:%5CUsers%5Cwarrior%5Cpl741.github.io%5Csource_posts%5C20161128203449282.png" alt="img"></p><p>&emsp;然后将softmax的输出向量与样本的实际标签做一个交叉熵</p><p><img src="/2019/09/16/评价标准/Users/warrior/pl741.github.io/source/_posts/20161128203840317.png" alt="img"></p><p>&emsp;其中 y’ 指代实际的标签中第i个的值（用mnist数据举例，如果是3，那么标签是[0，0，0，1，0，0，0，0，0，0]，除了第4个值为1，其他全为0）; y就是softmax的输出向量[Y1，Y2,Y3…]中，第i个元素的值</p><p>&emsp;显而易见，预测越准确，结果的值越小（别忘了前面还有负号），最后求一个平均，得到我们想要的loss</p><p>&emsp;注意！！！这个函数的返回值并不是一个数，而是一个向量，如果要求交叉熵，我们要再做一步tf.reduce_sum操作,就是对向量里面所有元素求和，最后才得到H(y)，如果求loss，则要做一步tf.reduce_mean操作，对向量求均值！</p><pre><code>tf.reduce_mean(input_tensor, axis=None,keep_dims=False,name=None,               reduction_indices=None)</code></pre><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p>&emsp; 第一个参数input_tensor： 输入的待降维的tensor;<br>&emsp; 第二个参数axis： 指定的轴，如果不指定，则计算所有元素的均值;<br>&emsp; 第三个参数keep_dims：是否降维度，设置为True，输出的结果保持输入tensor的形状，设置为False，输出结果会降低维度;<br>&emsp; 第四个参数name： 操作的名称;<br>&emsp; 第五个参数 reduction_indices：在以前版本中用来指定轴，已弃用;</p><p>&emsp;predict是预测结果，也就是神经网络的输出，real是真实的标签，sess就是tensorflow当前的会话，feed_dict是需要喂的数据。</p><p>&emsp;tf.equal(A, B)是对比这两个矩阵或者向量的相等的元素，如果是相等的那就返回True，反正返回False，返回的值的矩阵维度和A是一样的。</p><p>&emsp;tf.cast()函数的作用是执行 tensorflow 中张量数据类型转换，<br>    tf.cast(x, dtype, name=None)</p><h4 id="参数解析-1"><a href="#参数解析-1" class="headerlink" title="参数解析"></a>参数解析</h4><p>&emsp;第一个参数 x:   待转换的数据（张量）<br>&emsp;第二个参数 dtype： 目标数据类型<br>&emsp;第三个参数 name： 可选参数，定义操作的名称</p><p>&emsp;tf.loical_and()将数值变成逻辑值<br>    tf.logical_and(x, y, name=None)</p><p>&emsp;tf.argmax()返回值是是数值最大值的索引位置，如果最大值位置相同，则分类正确，反之则分类错误</p><pre><code>predictions = tf.argmax(predict, 1)actuals = tf.argmax(real, 1)# 将上述获得的变量设置成元素为0或者为1的矩阵ones_like_actuals = tf.ones_like(actuals)zeros_like_actuals = tf.zeros_like(actuals)ones_like_predictions = tf.ones_like(predictions)zeros_like_predictions = tf.zeros_like(predictions)# 按照前面的计算公式编写如下计算代码tp_op = tf.reduce_sum(tf.cast(tf.logical_and(            tf.equal(actuals, ones_like_actuals),            tf.equal(predictions, ones_like_predictions)),&quot;float&quot;))tn_op = tf.reduce_sum(tf.cast(tf.logical_and(            tf.equal(actuals, zeros_like_actuals),            tf.equal(predictions, zeros_like_predictions)),&quot;float&quot;))fp_op = tf.reduce_sum(tf.cast(tf.logical_and(            tf.equal(actuals, zeros_like_actuals),            tf.equal(predictions, ones_like_predictions)),&quot;float&quot;))fn_op = tf.reduce_sum(tf.cast(tf.logical_and(            tf.equal(actuals, ones_like_actuals),            tf.equal(predictions, zeros_like_predictions)),&quot;float&quot;))tp, tn, fp, fn = session.run([tp_op, tn_op, fp_op, fn_op], feed_dict)tpr = float(tp)/(float(tp) + float(fn))fpr = float(fp)/(float(fp) + float(tn))fnr = float(fn)/(float(tp) + float(fn))accuracy = (float(tp) + float(tn))/(float(tp) + float(fp) + float(fn) + float(tn))recall = tprprecision = float(tp)/(float(tp) + float(fp))f1_score = (2 * (precision * recall)) / (precision + recall)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本内容&quot;&gt;&lt;a href=&quot;#基本内容&quot; class=&quot;headerlink&quot; title=&quot;基本内容&quot;&gt;&lt;/a&gt;基本内容&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;True真    False假    Positive正     Negative负&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/09/16/%E8%AE%BA%E6%96%87/"/>
    <id>http://yoursite.com/2019/09/16/论文/</id>
    <published>2019-09-16T05:12:47.850Z</published>
    <updated>2019-07-31T11:56:42.447Z</updated>
    
    <content type="html"><![CDATA[<p>论文</p><p>abstract</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In the process of dairy farming, the traditional manual cow estrus detection method has the disadvantages of long time, large workload and low accuracy, which has always restricted the development of large-scale and intensive intelligent livestock. Massive Internet of Things (IoT) technology provide technical means to solve this problem in dairy farming. The monitoring system collects the activity data of the target cow through the sensor which worn on the cow neck, and then uploads it to the cloud through the NB-IoT network after being locally processed into 6-dimensional data. A LSTM warning of estrus algorithm combining continuous estrus factors is proposed. Compared with the K-means clustering algorithm, the LSTM neural network algorithm has higher accuracy and lower false detection rate in detection of estrus. By comparison, the most suitable continuous estrus factor is 4. This system provides an effective method for cow estrus detection.</span><br></pre></td></tr></table></figure><p>奶牛养殖过程中，传统的人工奶牛发情检测方法存在耗时长、工作量大、准确率低等缺点，一直制约着大规模、集约化智慧畜牧的发展。大规模物联网技术为解决奶牛养殖中的这一难题提供了技术手段。监测系统通过佩戴在牛脖上的项圈传感器采集目标奶牛行为特征数据，经本地处理为6维数据后通过NB-IoT网络上传至云端；提出一种结合连续发情因子数的LSTM奶牛发情预警算法。与K-means聚类算法相比，LSTM神经网络算法在奶牛发情检测中准确率较高和误检率较低。经对比，得出最为合适的连续发情因子数为4。该系统为奶牛发情检测提供了有效的方法。</p><p>介绍 introduction</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In the dairy farming, accurate and effective detection of estrus in cows is crucially to improve milk production and reproduction rate of dairy cows. In order to obtain the greatest economica benefits, dairy farmers need to keep abreast of the estrus status of the cows and successfully breed them during the estrus period. Traditional methods of cow estrus detection include external observation, trial methods, rectal examination, vaginal examination and so on[1]. However, these manual detection methods require a large amount of human resources, and are labor intensive and inefficient for large dairy farms.For the traditional manual detection method, there are some problems such as low estrus exposure rate, easy to miss detection and inaccurate estrus time. The ideal breeding cycle for dairy cows is about 365 days, but the traditional detection methods often make the average breeding cycle of dairy cows more than 400 days[2]. It not only reduces the efficiency of producing calves, but also shortens the proportion of lactation in the breeding cycle, thus affecting milk production.For those cows who missed the estrus period, some of the pastures use estrous synchronization, that is, drug aphrodisiac. This method is not only expensive, but also affects the quality of the milk and the health of the cow.</span><br></pre></td></tr></table></figure><p>在奶牛养殖业中，准确、有效的奶牛发情监测对提高奶牛产奶量和繁殖率至关重要，奶牛养殖业者需要及时抓住奶牛的发情期成功配种，才能获取最大经济效益。传统的奶牛检测方法包括外部观察法、试情法、直肠检查法、阴道检查法等[1]。但这些人工检测方法需要大量的人力资源，对于大型的奶牛养殖场而言，劳动强度大且效率低。对于传统的人工检测法，存在发情揭发率较低、易漏检和发情时间判别不准等一些问题。奶牛理想的繁殖周期为365天左右，但传统的监测方法往往使得奶牛的平均繁殖周期达400余天[2]，不仅降低了生产牛犊的效率，还缩短了哺乳期在繁殖周期中占有的比重，从而影响产奶量。对于错过发情期的奶牛，部分牧场采用同期发情的手段，即药物催情。这种方法不仅价格高昂，而且会影响牛奶品质和奶牛健康。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">With the advent of large-scale Internet of Things technology, real-time monitoring of cows can be realized at low cost. The collected real-time data stream is analyzed to determine the estrus status, and an estrus alarm is sent, so that the cow breeders can accurately grasp the estrus information and perform artificial breeding in time. This can effectively shorten the breeding cycle of dairy cows, reduce labor costs, and improve economic efficiency.</span><br></pre></td></tr></table></figure><p>随着大规模物联网等技术的出现，通过低成本的对目标奶牛全天候实时监控、发出发情警报的方式，让牧场工作人员能够准确掌握奶牛发情信息，及时进行人工配种，可有效地缩短奶牛的繁殖周期，降低人工成本，提高经济效益。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. System principle and framework</span><br></pre></td></tr></table></figure><p>1  系统原理和框架</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.1 Behavioral characteristics and breeding time of estrus</span><br></pre></td></tr></table></figure><ol><li>1  母牛发情的行为特征和配种时间</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In general, the increased activity and the significantly reduced ruminant time of cows during estrus can be used as a basis for judging the estrus of cows. The estrus period of dairy cows can be divided into three periods: early estrus, estrus, and late estrus.In the early days of estrus, the cows showed excitement, sensitivity and restlessness. At this time, the cows screamed frequently, sniffed other cows, and often chased other cows to crawled, but did not accept others. Cows with estrus are frequently moving, willing to accept other cattle to crawled, and stand still when they are crawled by other cattle. In the later stages of estrus, only a part of cows will continue to show estrus behavior.The behavioral changes associated with cow estrus provide the possibility to monitor estrus status through cow activity characteristics. The ovaries do not ovulate until 10 to 14 hours after the end of the estrus period. The appropriate breeding time is after the onset of estrus or 12 to 18 hours before ovulation. That is, artificial insemination is carried out at 12 to 18 hours after the onset of estrus, and the cow has the highest conception rate[3]. Therefore, accurate detection of early and prolonged estrus is beneficial to improve the success rate of breeding.</span><br></pre></td></tr></table></figure><p>一般而言，奶牛发情时活动量增大，反刍时间明显减少，可作为判断奶牛发情的依据。奶牛的发情期可分为发情早期、发情旺期、发情后期三个时期。在发情早期，奶牛表现兴奋不安，敏感而躁动，活动量增加。这时候的母牛吼叫频繁，闻嗅其他牛，并常常追逐其他奶牛试图爬跨，但其本身并不接受其他牛爬跨。而发情旺期的奶牛频繁走动，愿意接受其他牛爬跨，且在被其他牛爬跨时站立不动。在发情后期，只有部分奶牛会继续表现发情行为。奶牛发情所伴随的行为变化为通过奶牛活动特征监测发情状况提供了可能性。在发情旺期结束后10<del>14小时，卵巢才会排卵。适宜的配种时间为发情开始后或排卵前12</del>18小时，即在发情旺期之后12~18小时进行人工授精，母牛的受孕率最高[3]。因此准确地监控发情早期和旺期，有利于提升配种成功率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.2 Existing smart livestock programme</span><br></pre></td></tr></table></figure><ol><li>2  现有智慧畜牧方案</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">According to the wearing position sensors can be roughly divided into three categories: cow hoof, cow ear and cow neck. The comparison of three types sensors is shown in Table 1.The sensor worn on the hoof is relatively accurate in collecting the number of cattle steps, but impossible to collect data such as ruminants and food intake.The body temperature data collected by the sensor worn on the ear of the cow is relatively accurate, but due to the involuntary movement of the ear, there is a large noise disturbance in the collected activity data. The sensor worn on the cow&apos;s neck can obtain multi-dimensional data such as high activity state, medium activity state, low activity state, feeding state and rumbling state of the cow by algorithm. These data can be used not only to accurately detect the estrus condition of the cow but can also be used for health monitoring, disease warning, abortion warning.In this detection of estrus, the data comes from sensors worn on the cow&apos;s neck and the hooves.</span><br></pre></td></tr></table></figure><p>奶牛佩戴的传感器按照佩戴部位大致可分为三类：牛蹄、牛耳和牛脖，这三类传感器的对比如表1所示。佩戴在牛蹄上的传感器在采集牛步数方面相对准确，但无法采集奶牛的反刍和吃料等数据；佩戴在牛耳上的传感器所采集到的体温数据相对准确，但由于牛耳自身的不自主活动，所采集的活动量数据中存在着较大的噪音干扰。佩戴在牛脖上的传感器，能通过算法获得奶牛的高活动状态、中活动状态、低活动状态及吃料状态、反刍状态、步数等多维度的数据，这些数据不仅可用于精确监测牛的发情状况，还能用于健康监测、疾病预警、流产预警等方面，在本次发情检测中，数据来源于佩戴在牛脖和牛蹄上的传感器。。</p><p>Table 1 Sensor comparison of different wearing parts</p><table><thead><tr><th></th><th>HOOF</th><th>EAR</th><th>NECK</th></tr></thead><tbody><tr><td>Data Type</td><td>Step、Activity</td><td>Body Temperature、Activity</td><td>Step、Activity、Ruminate、Feed</td></tr><tr><td>Disadvantage</td><td>Unable to collect ruminant and food data</td><td>Large noise in the activity data</td><td>Unable to collect body temperature data、high requirements for recognition algorithms</td></tr></tbody></table><p>表1 不同佩戴部位的传感器对比</p><table><thead><tr><th></th><th>牛脖</th><th>牛蹄</th><th>牛耳</th></tr></thead><tbody><tr><td>采集数据类型</td><td>步数，活动量，反刍，吃料</td><td>步数，活动量</td><td>体温，活动量</td></tr><tr><td>缺点</td><td>无法采集体温数据，对识别算法要求高</td><td>无法采集反刍和吃料数据</td><td>活动量数据中存在较大的噪音</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">After the sensors collect the data, it needs to upload to the cloud through the communication network.At present, there are some devices and programs for automatic monitoring of dairy activity. Afimilk&apos;s Afitag cow pedometer adopts Bluetooth communication mode, which can only read the cow&apos;s movement step data when milking and can&apos;t be read in other time periods, so it can&apos;t monitor cow estrus in real time[4].The system developed by Liu Zhongchao[5] and Yin Ling[6] can collect the real time physical data such as the movement status of the cow, and transmit the data to the small base station through short-distance communication methods such as ZigBee, then upload it to the information management platform.This solution has the disadvantages of requiring the installation of independent communication base stations, complex systems, high operating costs, and the number of collectors and network coverage that the communication base station can accommodate is relatively limited.</span><br></pre></td></tr></table></figure><p>奶牛所佩戴的传感器在采集到数据后，需要通过通信网络上传云端。目前，市场上已经存在一些奶牛活动量自动监测的装置和方案。以色列阿菲金（Afimilk）的Afitag奶牛计步器采用蓝牙通信方式，只能在挤奶的时候才能读取奶牛运动步数数据，其他时间段不能读取，无法做到实时监测奶牛发情 [4]。刘忠超[5]和尹令[6]203-208等人所开发的系统，能实时采集奶牛的运动状态等体征数据，通过ZigBee等短距离通信方式传输数据到小基站，再上传至信息管理平台。这一方案存在着需要独立安装通讯基站，系统复杂，运营成本较高，且通讯基站所能容纳的采集器数量、网络覆盖范围相对有限等缺点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Narrow Band Internet of Things (NB-IoT) is an emerging technology in the Internet of Things (IoT). It has the advantages of large network capacity, security and reliability, and wide signal coverage. At the same time, it supports the Operator network that can directly connects products to a relatively stable and does not require user maintenance.The low power consumption of NB-IoT allows the collar sensors to be used for 5 years without charging.Therefore, NB-IoT is very suitable for data transmission between sensors and the cloud. The pairs of IoT technologies such as Bluetooth, ZigBee and NB-IoT are shown in Table 2.</span><br></pre></td></tr></table></figure><p>窄带物联网（NB-IoT）是物联网（IoT）领域一个新兴的技术，网络容量大、安全可靠、信号覆盖广，支持直接将产品接入相对稳定、无需用户维护的运营商网络。NB-IoT的低功耗特性，使得项圈可使用5年而无需充电。因此NB-IoT非常适合用于进行传感器与云端之间的数据传输。蓝牙、ZigBee和NB-IoT等物联网技术的对比如表2所示。</p><p>Table 2 Comparison of different communication methods of the Internet of Things</p><table><thead><tr><th></th><th>NB-IoT</th><th>ZigBee</th><th>蓝牙</th></tr></thead><tbody><tr><td>Networking</td><td>Based on existing cellular networking</td><td>Based on ZigBee Gateway</td><td>Bluetooth based Mesh gateway</td></tr><tr><td>Typical Transmission Distance</td><td>10 km</td><td>100m</td><td>10m</td></tr><tr><td>Typical Battery Life (AA battery)</td><td>Theory about 10 years</td><td>Theory about 2 years</td><td>Days</td></tr><tr><td>Transfer Speed</td><td>The actual rate is generally less than 100Kbps</td><td>The actual rate is generally less than 100Kbps</td><td>The actual rate is about 1Mbps</td></tr></tbody></table><p>表2 物联网不同通信方式对比</p><table><thead><tr><th></th><th>NB-IoT</th><th>ZigBee</th><th>蓝牙</th></tr></thead><tbody><tr><td>组网方式</td><td>基于现有蜂窝组网</td><td>基于ZigBee网关</td><td>基于蓝牙Mesh网关</td></tr><tr><td>典型传输距离</td><td>10公里</td><td>100米</td><td>10米</td></tr><tr><td>典型续航（AA电池）</td><td>理论约10年</td><td>理论约2年</td><td>数天</td></tr><tr><td>传输速度</td><td>实际速率一般小于100Kbps</td><td>实际速率一般小于100Kbps</td><td>实际速率约1Mbps</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.3 system framework</span><br></pre></td></tr></table></figure><ol><li>3  系统框架</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The system architecture includes acquisition layer, data transmission layer, cloud algorithm layer, and application layer, as shown in Figure 1.</span><br></pre></td></tr></table></figure><p>本文采用方案包括采集层、数据传输层、云端算法层和应用层，系统架构如图1所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The smart collar 3D accelerometer worn on the cow&apos;s neck can capture 100 frames per second. On behalf of adapt to the transmission rate of NB-IoT, the local processing module on the sensor first converts the data to seconds, then converts to the hour level. A data is generated every 2 hours, including steps and the number of minutes in high activity, medium activity, low activity, feeding and rumbling. The high activity minutes refers to the time when the cow is walking fast, walking slowly or climbing. The low activity minutes refers to the time when the cow is lying or standing without any other action.The number of minutes in the medium activity refers to the time when the cow is still chewing, shaking head or raising head while lying or standing.To further reduce power consumption, every 2 hours the sensor uploads two pieces of data to the cloud via the NB-IoT network.After receiving the data, the cloud will use the big data processing technology to detect the cow estrus.Finally, the detection result will be sent to the user&apos;s device through the application layer.</span><br></pre></td></tr></table></figure><p>佩戴在牛脖上的智能项圈三维加速度传感器每秒能采集100帧数据。为适应NB-IoT的传输速率，项圈上的本地处理模块先把这些数据先转换为秒级，然后转换为小时级，每2小时生成一条包括牛处于高活动状态、中活动状态、低活动状态、吃料状态、反刍状态所占的分钟数以及牛的步数的数据。其中高活动量分钟数指奶牛在快走、慢走或爬跨的时间，低活动量分钟数是指奶牛在平躺或站立而不做任何其他动作的时间，中活动量分钟数则是指奶牛在平躺或站立时仍做一些咀嚼、摇头或抬头等动作的时间。项圈每隔2小时通过NB-IoT网络向云端上传一条数据。云端收到数据后，使用大数据技术进行奶牛发情监测，最终通过应用层将监测结果发送到目标用户的设备上。</p><p>2  （不知道）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.1 RELATED RESEARCH</span><br></pre></td></tr></table></figure><ol start="2"><li>1 相关研究</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Many scholars had completed plenty of research work on detection of estrus in cows. Tan Yi et al. design and implementation real-time monitoring system for cow estrus based on Storm[7];According to the acceleration data, Wang Jun developed a cow behavior classification system based on semi-supervised fuzzy clustering algorithm[8]. The above two discriminating methods are based on the activity and steps. The method of object recognition based on image entropy was proposed by Gu Jingqiu et al, aiming at effectively detection of cow estrus and hoof disease[9].According to the characteristics of increasing activity, shorter repose time and increasing animal heat during cow oestrus, Tian Fuyang et al. built a LVQ neural network model for estrus detection and prediction in dairy cows[10]. Yin Ling et al used acceleration data to construct binary decision tree support vector machines based on wireless sensor network[11] and K-means clustering algorithm for cow behavioral features recognition[6]. Watanab et al. present novel methods to analyze whether the cow has a leg higher than the other legs per unit time by using a wireless network with an acceleration sensor to detection of estrus[12]. The above discriminating methods are all classified according to single point data.</span><br></pre></td></tr></table></figure><p>针对奶牛发情监测国内外学者已经完成了很多研究工作，谭益等基于SVM预测模型，支持奶牛发情实时监测[7]；王俊等依据采集到的奶牛运动加速度数据研发了一种基于半监督模糊聚类算法的奶牛行为实时判别系统[8]。上述两种判别方式依据奶牛的活动量和步数进行分类，特征参数的种类较少。顾静秋等融合被识别奶牛的运动量提出了一种基于图像熵的奶牛目标对象识别方法，有效监控奶牛发情和蹄病行为[9]；田富洋等根据奶牛发情期活动量上升、静卧时间变短和体温升高等生理学特征，建立了以奶牛行为特征为输出的LVQ神经网络发情行为辨识模型与预测模型[10]，尹令等用加速度传感器构建基于二叉决策树支持向量机模型[11]和基于K-均值聚类算法进行奶牛行为特征分类识别[6]203-208；Watanab等通过加速度传感器分析奶牛在单位时间内是否有一条腿高于其他腿来判断奶牛是否处于发情期[12]，以上三种判别方法均是根据单点数据进行分类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The study will increase the feed time per hour and ruminant time per hour based on the detection of estrus using the activity and steps.  At the same time, the study reclassified the activity into high activity time per hour, medium activity time per hour and low activity time per hour. A total of 6-dimensional features were used for detection of estrus.</span><br></pre></td></tr></table></figure><p>该研究将在利用奶牛活动量和步数进行发情检测的基础上，增加奶牛的吃料时间/每小时和反刍时间/每小时。同时该研究将活动量重新划分成成高活动量时间/每小时、中活动量时间/每小时和低活动量时间/每小时。共采用6维特征进行奶牛发情检测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.2 Datasets</span><br></pre></td></tr></table></figure><ol start="2"><li>2 数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A total of 40 cows were used as experimental animals and six cows showed estrus during the experimental period. Each piece of data collected in the experiment  includes high activity minutes, medium activity minutes, low activity minutes, feeding minutes, ruminate minutes and steps.</span><br></pre></td></tr></table></figure><p>该研究共获得了40头奶牛的相关数据，在实验期间共有6头母牛发情了。实验中收集到的每条数据包括奶牛的高活动量分钟数、中活动量分钟数、低活动量分钟数、吃料分钟数以及反刍分钟数和步数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.3 Feature Analysis</span><br></pre></td></tr></table></figure><ol start="2"><li>3  特征分析<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Partial features have obvious changes during estrus. Figure 2 depicts the curve of high activity time, feed time and ruminant time for a cow in the week before and after estrus.It can be seen from the figure that during the estrus period, the cows have a significant increase in high activity time and feeding time, but the ruminating time is reduced distinctly.In Figure 3, the curve of the steps during the estrus period is plotted. It can be seen from the figure that the steps in the estrus is significantly increased.</span><br><span class="line"></span><br><span class="line">The characteristics will change significantly during the estrus, and the data will only fluctuate in a small range during the rest of the time. Therefore, using only a single piece of data (without considering the correlation of each piece of data) for detection of estrus will not accurately determine the estrus period.In this study, the continuity of dairy cow estrus was considered, that is, the input data was time series, and the Long-short Time Memory of the improved model of Recurrent Neural Network was used to detect the estrus.</span><br></pre></td></tr></table></figure></li></ol><p>在奶牛发情时特征具有明显的变化，其余时间内数据的波动性较小。图2绘出了某头奶牛在发情期前后一周内高活动时间，吃料时间和反刍时间的变化曲线。从图中可以看出奶牛在发情期时高活动量时间， 吃料时间显著增加，但反刍时间显著减少。图3绘出了奶牛在发情期前后一周内步数的变化曲线。从图中可以看出奶牛在发情期步数显著增加。</p><p>同时奶牛发情是在某一时间段内的连续过程，因此仅利用单条数据，（不考虑每条数据的相关性）进行发情检测将无法准确判定奶牛的发情期。该研究中考虑了奶牛发情期的连续性，即输入数据为时间序列，利用循环神经网络的改进模型长短期记忆进行奶牛发情检测。<br><img src="E:%5CMachineLearning%5CCow_result%5Ccow1.png" alt="avatar"><br><img src="E:%5CMachineLearning%5CCow_result%5Ccow.png" alt="avatar"></p><p>3 实验与结论</p><ol start="3"><li>1 Recurrent Neural Network</li><li>1 循环神经网络</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Recurrent Neural Network (RNN) is a kind of neural network for processing time sequence data [13]. Figure 4 shows a simple RNN network structure in which the output of a neuron can be re-entered into the neuron as input. For the expanded RNN, as shown in Figure 5, the hidden neurons at time t receive the output from the hidden neurons at the previous moment and the inputs at the current time. Respectively, the same type of weights in the network structure are shared.Thus the data at time t-1 will affect the output at time t. Such a structure is very  effective for maintaining dependencies in sequence data.</span><br></pre></td></tr></table></figure><p>循环神经网络（RNN）是可以用来处理基于时间序列数据的神经网络模型[13]。图4展示了一个简单的RNN网络结构，可以将一个神经元的输出结果作为输入再次输入到神经元中。对于展开后的RNN，如图5，时刻t的隐藏神经元分别接收来自前一时刻隐藏神经元的输出和当前时刻的输入， 同时网络结构中的同一类型的权值是共享的。这样t-1时刻的数据将影响t时刻的输出。这样的结构特点对于保持序列数据中的依赖关系非常有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">According to the time sequence, the forward propagation of the RNN can be expressed as follows:</span><br><span class="line">At time t:</span><br><span class="line">Hidden neuron output: h=</span><br><span class="line">() is the activation function. U is the weight vector from the input unit to the hidden neuron. W is the connection weight vector between the hidden neurons, b is the offset vector</span><br><span class="line">Output at time t:</span><br><span class="line">The final output value:</span><br><span class="line">() is the activation function. If the RNN is used for classification, the softmax function is generally available.</span><br></pre></td></tr></table></figure><p>RNN的前向传播按照时间序列可表示成如下：</p><p>对于t时刻：</p><p>隐藏神经元的输出：<br>$$<br>h_{(t)}=\phi\left(U x_{(t)}+W h_{(t-1)}+b\right)<br>$$</p><p>$$<br>\phi( )<br>$$<br>为激活函数，<br>$$<br>\text { tanh }<br>$$<br>U为输入单元到隐藏神经元的权值，W为隐藏神经元之间的连接权重，b为偏置</p><p>t时刻的输出：<br>$$<br>o_{(t)}=V h_{(t)}+c<br>$$</p><p>最终的模型输出值：<br>$$<br>y_{(t)}=\sigma\left(o_{(t)}\right)<br>$$</p><p>$$<br>\sigma<br>$$<br>为激活函数，对于用于分类的RNN模型，一般可选用softmax函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RNN can map the input sequence data into sequence data as for output.However, if there is no a strict requirement for the input sequence, you can enter a fixed-length sequence or a sequence of variable length.</span><br></pre></td></tr></table></figure><p>RNN能将输入的序列数据映射成序列数据输出，但对于输入序列并没有严格的要求，即可输入定长的序列，也可输入不定长的序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Although RNN can be used to maintain the dependency of sequence data, it also faces the problem of gradient disappearance and gradient explosion, and it is difficult to achieve long-term retention of dependencies [14].In order to solve this problem, Hochreiter et al. improved RNN and proposed a Long-Short Time Memory (LSTM) network model [15], which can effectively overcome the gradient disappearance problem in RNN and become the most effective model for processing sequence data at present.</span><br></pre></td></tr></table></figure><p>虽然RNN可用来保持序列数据的依赖关系，但也面临这梯度消失和梯度爆炸的问题。难以实现依赖关系的长期保持[14]。为了解决这个问题，Hochreiter等人对RNN进行改进，提出了长短期记忆（Long-Short Time Memory, LSTM)网络模型[15]， 能够有效克服RNN中存在的梯度消失问题，成为了目前用于处理序列数据最有效的模型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">The structure of LSTM is basically same as RNN, but it has a more complex internal processing unit.Hochreiter et al. introduced memory cells and gated memory cells in the RNN internal unit, which can be used to control the flow of information[15].LSTM network architecture shown in Figure 6 is from Graves[16]. As shown in the figure, there are three kinds of gating in the LSTM network model: input gate, forgetting gate and output gate, and respectively expressed by i, f, and o.</span><br><span class="line"></span><br><span class="line">Gating can be represented by the following equation:</span><br><span class="line">Where (x)= is a Sigmoid function that can map real values to 0~1. W and b represent the weight and offset of the network, respectively. If the output of the gate is 0, it means that the information should be forgotten. If the output is 1, the information will be completely retained.</span><br><span class="line"></span><br><span class="line">The input gate is used to control how much of the current input data can be saved to ct, and is calculated by the following formula:</span><br><span class="line"></span><br><span class="line">The forgetting gate can control which information is retained and which is forgotten. That is, the influence of the information in the memory unit on the current memory unit at the previous moment. Can be expressed as follows:</span><br><span class="line"></span><br><span class="line">The output gate controls the influence of the memory unit ct on the current output ht. The value of the current output gate is as follows:</span><br></pre></td></tr></table></figure><p>LSTM的模型结构与RNN基本相同，却拥有更加复杂的内部处理单元。Hochreiter 等人在RNN内部单元中引入了记忆单元和门控记忆单元，使用门控来控制信息的流动[15]。如图6所示的LSTM网络架构图来自于于 Graves 等[16]，如图中所示，LSTM网络模型中存在三种门控：输入门、遗忘门和输出门，分别用i，f, 和o来表示。门控可由如下式子表示：<br>$$<br>f(\boldsymbol{x})=\sigma(\boldsymbol{W} \boldsymbol{x}+\boldsymbol{b})<br>$$<br>其中<br>$$<br>\sigma(x)=1 /(1+\exp (-x))<br>$$<br>是Sigmoid函数，可将实数值映射到0~1区间，W和b分别表示网络的权重和偏置。若门的输出值为0，表示将信息遗忘，若输出为1，则表示信息将被完全保留。</p><p>输入门用来控制当前输入数据有多少可以保存到ct中，用如下式子计算；<br>$$<br>f_{(t)}=\sigma\left(W_{f} \cdot\left[h_{(t-1)}, x_{(t)}\right]+b_{f}\right)<br>$$<br>遗忘门可以控制哪些信息被保留哪些要遗忘，即上一时刻记忆单元ct-1中的信息对当前记忆单元ct的影响，可表示成如下式子：<br>$$<br>i_{(t)}=\sigma\left(W_{i} \cdot\left[h_{(t-1)}, x_{(t)}\right]+b_{i}\right)<br>$$<br>$$<br>C_{(t)}=\tanh \left(W_{C} \cdot\left[h_{(t-1)}, x_{(t)}\right]+b_{C}\right)<br>$$<br>$$<br>C_{(t)}=f_{(t)} * C_{(t-1)}+i_{(t)} * C_{(t)}<br>$$<br>输出门控制记忆单元ct对当前输出值ht的影响，当前输出门的值如下式：<br>$$<br>o_{(t)}=\sigma\left(W_{o}\left[h_{(t-1)}, x_{(t)}\right]+b_{o}\right)<br>$$<br>$$<br>h_{(t)}=o_{(t)} * \tanh \left(C_{(t)}\right)<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.2 Result</span><br></pre></td></tr></table></figure><ol start="3"><li>2 结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The estrus is within a few hours of continuous, and the time correlation between the data is crucial for studying estrus. Therefore, an LSTM model that can be classified using time correlation between data is used. The K-means clustering algorithm in the unsupervised learning is selected and compared with the LSTM supervised model.</span><br></pre></td></tr></table></figure></li></ol><p>奶牛发情是在连续的几个小时之内，数据间的时间相关性对于研究奶牛发情具有至关重要的作用。因此本研究采用了可利用数据间的时间相关性进行分类的LSTM模型。选取无监督学习算法中的K-means聚类算法与LSTM监督模型进行对比分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For cow real-time estrus detection, when the data processing layer collects the characteristic data of a certain cow, the detection algorithm is used to determine the estrus, and the judgment result is used as the estrus factor of the data. If the estrus factor is 1, it indicates that the cow is in estrus. If the estrus factor is 0, the cow is currently not estrus. The system will issue an estrus warning only when there are several consecutive estrus factors is 1. That is to say, only when the data collected at present are judged to be estrus and the first few data with continuous current data are judged to be estrus, can the cow be judged to be really in estrus.</span><br></pre></td></tr></table></figure><p>对于奶牛实时发情检测，当数据处理层收集到某头奶牛的特征数据时，将利用检测算法进行发情判别，并将判别结果作为该条数据的发情因子。若发情因子为1则表明奶牛处于发情时期，若发情因子为0则该头奶牛目前处于未发情状态。系统会在有连续几个发情因子为1的情况下才发出发情预警。即只有在当前收集到的数据被判定为发情且当前数据连续的前几条数据均为判定为发情的情况下，才会判定该奶牛真正处于发情期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This study compared the estrus discrimination effects of two different types of algorithms. On this basis, the number of consecutive estrus factors (ie, how many consecutive estrus factors are 1 to send an estrus alarm) is selected, which is most suitable for the experimental data. The following will be expressed by the number of continuous estrus factors.</span><br></pre></td></tr></table></figure><p>该研究对比了两种不同类型算法下的发情判别效果。在此基础上选择出最适合本实验的发情因子连续窗口数（即多少个连续的发情因子为1才发送发情报警），以下将使用连续发情因子数来表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table 3 compares the accuracy, detection rate and false detection rate of the LSTM and K-means clustering algorithms. The accuracy rate refers to the probability that the estrus point is detected as estrus, and the estrus point is detected as unestrus. The detection rate refers to the ratio of the number of true estruss in the detected estrus to the number of detected estrus points. The false detection rate refers to the ratio of the number of detected estrus points that are detected as estrus but not actually estrus. It can be seen from Table 3 that the performance of the LSTM algorithm in terms of accuracy and false detection rate is better than the K-means clustering algorithm, but the detection rate is the same. It is shown that both algorithms can detect cow estrus, but the accuracy of K-means clustering algorithm is poor. The number of unestrus points detected as estrus points or estrus points detected as unestrus points is higher. At the same time, K-means algorithm will detect more non-estrus points as estrus, and determine the additional detection points as estrus, resulting in a higher false detection rate.</span><br></pre></td></tr></table></figure><p>表格3中对比了LSTM和K-means聚类两种算法的准确率，检出率和误检率。其中准确率是指奶牛发情点被检测成发情，未发情点被检测成未发情的概率。检出率是指检测出的发情点中真正发情的个数与检测出来的发情点的个数之比。误检率是指被检测为发情点但实际并未发情的与检测为发情点的个数之比。由表3可以看出，LSTM算法在准确率和误检率这方面的性能都比K-means聚类算法好，但检出率相同。表明两种算法都可检测出奶牛发情，但K-means聚类算法的准确率较差，即将未发情点检测为发情点或将发情点检测为未发情点的数目较多。同时K-means算法会将更多的未发情点检测为发情， 将发情点附加的检测点也判定为发情，造成误检率较高。</p><table><thead><tr><th>算法</th><th>准确率</th><th>检出率</th><th>误检率</th></tr></thead><tbody><tr><td>LSTM</td><td>96%</td><td>90%</td><td>0%</td></tr><tr><td>K-means</td><td>85%</td><td>90%</td><td>35%</td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table 4 shows the number of false detections and missed detections for the two algorithms with different consecutive estrus factors. In the table 4, the number of estrus factors is 3, indicating that when two continuous estrus factors are judged to be 1, the system sends an estrus warning when the third estrus factor is also 1, and so on. The table uses the number of false detections/missing numbers to indicate. It can be seen from the table that when the number of continuous estrus factors is 3, the K-means clustering algorithm has more false detections. However, when the number of continuous estrus factors is set to 5, the LSTM algorithm will generate a missed test. This is because the difference in the estrus of each cow is different. If the estrus time is shorter, the number of consecutive estrus factors Larger ones will result in missed detection. This is due to the individual differences, resulting in different durations of estrus. If the estrus period is short, the number of large consecutive estrus factors will lead to missed detection.  However, K-means clustering algorithm will determine the data points attached to the estrus point as estrus as much as possible, so that the algorithm will not miss the detection when the number of continuous estrus factors is 5. According to the above analysis, the estrus warning based on LSTM sets the number of consecutive estrus factors to four.</span><br></pre></td></tr></table></figure></td><td></td><td></td><td></td></tr></tbody></table><p>表格4展示了两种算法在不同连续发情因子数情况下误检数和漏检数。表格中发情因子数为3表示系统在判定有两个连续的发情因子为1时，在接收到第三个发情因子也为1时就发送发情预警，以此类推。表格中用误检数/漏检数来表示。从表格中可以看出当连续发情因子数为3时，K-means聚类算法的误检数较多。但当连续发情因子数设置为5时，LSTM算法会产生1个漏检。这是由于每头奶牛个体的差异性导致其发情持续时间不同，若奶牛的发情时间较短，则连续发情因子数较大就会产生漏检。然而K-means聚类算法会将发情点附加的数据点也尽可能判定为发情，使得算法在连续发情因子数为5时也不会产生漏检。根据以上分析，基于LSTM的发情预警将连续发情因子数设定为4个。</p><table><thead><tr><th>连续发情因子数</th><th>LSTM</th><th>K-means</th></tr></thead><tbody><tr><td>3</td><td>0  /  0</td><td>5  /  0</td></tr><tr><td>4</td><td>0  /  0</td><td>1  /  0</td></tr><tr><td>5</td><td>0  /  1</td><td>0  /  0</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 CONCLUSION</span><br></pre></td></tr></table></figure><p>4  总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The estrus warning system based on NB-IoT network and Long-Short Time Memory network combined with continuous estrus factors proposed in this paper is more efficient, accurate and saves labor cost compared with the traditional artificial estrus detection method, and can reduce the effects of drug aphrodisiac on milk quality and cow health. The system adopts NB-IoT technology which is more advantageous in terms of networking mode, coverage and battery life. Compared with the system using Bluetooth and ZigBee technology, it is not only suitable for the breeding scene of captivity, but also can be applied to scenes with wider scope and more complicated data transmission conditions, and has better applicability. The system uses the sensor worn on the cow&apos;s neck, in addition to being used to monitor the estrus, it can be further used for cow health monitoring, disease warning, abortion warning and so on.</span><br></pre></td></tr></table></figure><p>本文提出的基于NB-IoT网络和结合连续发情因子的LSTM奶牛发情预警系统，相比传统的人工奶牛发情检测方法，更为高效、准确，节省人力成本，并可以减少药物催情对牛奶品质和奶牛健康的影响。本系统采用组网方式、覆盖范围、续航时间方面更有优势的NB-IoT技术，对比基于采用蓝牙、ZigBee等技术的系统，不但适用于圈养的养殖场景，也能够很好地应用于放牧等范围更广、数据传输条件更复杂的场景，具有更好的适用性。相比佩戴在牛蹄、牛耳上的传感器，本系统采用佩戴在牛脖上的传感器除了可用于监测奶牛发情外，还能进一步用于奶牛的健康监测、疾病预警、流产预警等方面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This study increased the ruminant and feeding time, and estrus chould be detected by multi-dimensional behavior characteristics. Compared to using only activity and steps, detection of eatrus can be more accurately.Given the continuity of estrus in time, LSTM neural network model that can process time sequence data was used to detecte estrus.Compare the effects of LSTM and K-means in estrus detection. The estrus warning is proposed by using continuous estrus factor, and the optimal number of continuous estrus factors based on LSTM for estrus detection is obtained.</span><br></pre></td></tr></table></figure><p>本研究增加了反刍和吃料时间，可利用多维度奶牛行为特征进行发情检测。相比于仅利用活动量和步数，可以更准确的检测奶牛发情。鉴于奶牛发情在时间上具有连续性，采用可处理时间序列数据的LSTM神经网络模型来预测奶牛发情。对比了LSTM与K-means在奶牛发情检测中的效果。提出了利用连续发情因子进行发情预警，并得出了基于LSTM进行发情检测时最合适的连续发情因子数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In addition, limited by the current transmission bandwidth of NB-IoT, the collected data still needs to be pre-processed locally and then transmitted to the cloud. The estrus detection algorithm is greatly affected by the local pre-processing algorithm.With the evolution of 5G mass machine communication technology, a large amount of real-time data can be uploaded to the cloud in the future, which can further improve the estrus detection rate.</span><br></pre></td></tr></table></figure><p>此外，受限于目前NB-IoT较小的传输带宽，采集到的数据仍需在本地预处理再传输到云端，发情检测算法受本地预处理算法的影响大。随着5G海量机器通信技术演进，未来可将大量实时采集数据上传到云端，可进一步提升提高发情检测率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;论文&lt;/p&gt;
&lt;p&gt;abstract&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>链接</title>
    <link href="http://yoursite.com/2019/09/16/%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2019/09/16/链接/</id>
    <published>2019-09-16T05:12:47.841Z</published>
    <updated>2019-07-23T12:39:00.743Z</updated>
    
    <content type="html"><![CDATA[<p>搭建个人博客：<a href="https://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="noopener">https://www.jianshu.com/p/4eaddcbe4d12</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;搭建个人博客：&lt;a href=&quot;https://www.jianshu.com/p/4eaddcbe4d12&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/4eaddcbe4d12&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>jupyter主题设置</title>
    <link href="http://yoursite.com/2019/09/16/jupyter_%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/09/16/jupyter_主题设置/</id>
    <published>2019-09-16T05:12:47.831Z</published>
    <updated>2019-07-23T12:38:46.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jupyter-主题设置"><a href="#jupyter-主题设置" class="headerlink" title="jupyter 主题设置"></a>jupyter 主题设置</h2><p>安装主题：pip install jupyterthemes</p><p>如果之前安装过可以更新一下：pip install –upgrade jupyterthemes</p><p>设置主题：蓝色主题——jt -t onedork -fs 95 -altp -tfs 11 -nfs 115 -cellw 88% -T</p><p>​                    黑色主题——jt -t monokai -f fira -fs 13 -cellw 90% -ofs 11 -dfs 11 -T -N</p><p>​                    部分参数：-f(字体)  -fs(字体大小) -cellw(占屏比或宽度)  </p><p>​                                      -ofs(输出段的字号)  -T(显示工具栏)  -N(显示自己主机名)</p><h4 id="Conda环境自由切换："><a href="#Conda环境自由切换：" class="headerlink" title="Conda环境自由切换："></a>Conda环境自由切换：</h4><p>​        看一下是否已经把 Anaconda 中创建的所有定制环境作为核心添加在了 Jupyter Notebook 中。这样我们就能简单地利用 Kernel 按钮切换环境。换核的时候不需要重启 notebook。</p><p>​        假设你的 Anaconda 环中有两个自定义的环境 my_NLP 和 gym。按照下面的步骤将这些添加到你的 Jupyter Notebook 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conda activate my_NLP</span><br><span class="line"># Install the IPython Kernel </span><br><span class="line">pip install ipykernel</span><br><span class="line"># Link your environment with Jupyter </span><br><span class="line"># Repeat steps for the other environment, gym</span><br><span class="line">python -m ipykernel install --user --name=my_NLP</span><br><span class="line">pip install ipykernel </span><br><span class="line">python -m ipykernel install --user --name=gym</span><br></pre></td></tr></table></figure><p>​        现在打开你的 Jupyter Notebook，找到 kernel 按钮下的 Change Kernel 选项，接下来就是见证奇迹的时刻：所有的核都被列举出来了，你可以通过简单地点击来激活一个服务核。</p><h4 id="其他功能："><a href="#其他功能：" class="headerlink" title="其他功能："></a>其他功能：</h4><p>​        安装 nbextensions for Jupyter Notebooks</p><p>​        安装 nbextensions 是很容易的，简单地遵循下面的步骤就行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Stop and exit your Jupyter Notebook server </span><br><span class="line"># Make sure you are in the base environment</span><br><span class="line">conda activate base</span><br><span class="line"># Install the nbextensions </span><br><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line"># Install the necessary JS and CSS files </span><br><span class="line">jupyter contrib nbextension install --system</span><br></pre></td></tr></table></figure><p>​        启动 Jupyter notebook 服务，你可以在起始页看到第四个叫做 Nbextensions 的选项。点击这个选项，然后就可以看到极妙的功能集，这些都是你一直希望在 Jupyter Notebooks 中拥有的。</p><p>其中一些的简单介绍：</p><p>​          Table of Contents(2)：单击生成整个笔记本的目录，不同的 section 都有对应的超链接。</p><p>​         Scratchpad：在我看来绝对是最好的扩展了。这是一个你可以在里面做代码实验的独立空间，不会干扰笔记本中的其他部分。</p><p>​        Codefolding ：代码折叠，这个不需要做过多的解释。</p><p>​        Hide Input All：隐藏所有的代码单元，同时保持所有的输出和 markdown 单元可见。如果你要向非技术人员解释你的结果，那么这就会是一个很有用的功能。</p><p>​        Variable Inspector：将你从调试的忧伤中拯救出来，这与 Spyder IDE 中的变量检查窗口有些类似。</p><p>​        Spellchecker：对 markdown 单元中的内容进行拼写检查。</p><p>​        Zenmode：移除掉屏幕中杂乱无关的内容，以便你能够聚焦于重要的东西上，例如代码。</p><p>​        Snippets Menu：从 list comprehension 到 pandas 以及它们之间的所有常用代码片段的一个很酷的集合。这是最好的部分？你可以修改窗口的小部件来添加你自己的定制片段。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jupyter-主题设置&quot;&gt;&lt;a href=&quot;#jupyter-主题设置&quot; class=&quot;headerlink&quot; title=&quot;jupyter 主题设置&quot;&gt;&lt;/a&gt;jupyter 主题设置&lt;/h2&gt;&lt;p&gt;安装主题：pip install jupyterthemes
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/07/23/hello-world/"/>
    <id>http://yoursite.com/2019/07/23/hello-world/</id>
    <published>2019-07-23T05:04:49.483Z</published>
    <updated>2019-07-23T05:59:59.367Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line"><span class="comment"># 可以总结成下面这一句</span></span><br><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
