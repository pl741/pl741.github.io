<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法与数据结构-剑指offer,">





  <link rel="alternate" href="/atom.xml" title="木木的博客" type="application/atom+xml">






<meta name="description" content="参考：动图来自牛客网（ https://www.nowcoder.com/discuss/198840?type=1 ）和 RUNOOB.COM 面试题 3.1：数组中重复的数字长度为n的数组，所有数字都在0~n-1的范围内，找出数组中任意重复的数字。 三种方法：  首先将所有数字排序，然后从头到尾扫描排序后的数组。时间复杂度为$O(nlogn)$ 利用哈希表，从头到尾扫描数组，每一个数字利用$O">
<meta name="keywords" content="算法与数据结构-剑指offer">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指Offer-Python">
<meta property="og:url" content="http://pl741.github.io/2019/11/08/剑指offer-Python/index.html">
<meta property="og:site_name" content="木木的博客">
<meta property="og:description" content="参考：动图来自牛客网（ https://www.nowcoder.com/discuss/198840?type=1 ）和 RUNOOB.COM 面试题 3.1：数组中重复的数字长度为n的数组，所有数字都在0~n-1的范围内，找出数组中任意重复的数字。 三种方法：  首先将所有数字排序，然后从头到尾扫描排序后的数组。时间复杂度为$O(nlogn)$ 利用哈希表，从头到尾扫描数组，每一个数字利用$O">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://pl741.github.io/2019/11/08/剑指offer-Python/1.gif">
<meta property="og:image" content="http://pl741.github.io/2019/11/08/剑指offer-Python/2.gif">
<meta property="og:image" content="http://pl741.github.io/2019/11/08/剑指offer-Python/3.png">
<meta property="og:updated_time" content="2020-05-01T15:20:28.216Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指Offer-Python">
<meta name="twitter:description" content="参考：动图来自牛客网（ https://www.nowcoder.com/discuss/198840?type=1 ）和 RUNOOB.COM 面试题 3.1：数组中重复的数字长度为n的数组，所有数字都在0~n-1的范围内，找出数组中任意重复的数字。 三种方法：  首先将所有数字排序，然后从头到尾扫描排序后的数组。时间复杂度为$O(nlogn)$ 利用哈希表，从头到尾扫描数组，每一个数字利用$O">
<meta name="twitter:image" content="http://pl741.github.io/2019/11/08/剑指offer-Python/1.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'D7ALJV5SO6',
      apiKey: '6e20ed4f9126e4bd7125665a8b2f2a43',
      indexName: 'MUMU',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"找不到关于 ${query} 的文章","hits_stats":"共找到 ${hits} 篇文章，花了 ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://pl741.github.io/2019/11/08/剑指offer-Python/">





  <title>剑指Offer-Python | 木木的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">木木的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">木木的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          <!--增加的代码 start-->

          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pl741.github.io/2019/11/08/剑指offer-Python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="木木">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="木木的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">剑指Offer-Python</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-08T11:51:07+08:00">
                2019-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python算法/" itemprop="url" rel="index">
                    <span itemprop="name">Python算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>参考：动图来自牛客网（ <a href="https://www.nowcoder.com/discuss/198840?type=1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/198840?type=1</a> ）和 RUNOOB.COM</p>
<h5 id="面试题-3-1：数组中重复的数字"><a href="#面试题-3-1：数组中重复的数字" class="headerlink" title="面试题 3.1：数组中重复的数字"></a>面试题 3.1：数组中重复的数字</h5><p>长度为n的数组，所有数字都在0~n-1的范围内，找出数组中任意重复的数字。</p>
<p>三种方法：</p>
<ol>
<li>首先将所有数字排序，然后从头到尾扫描排序后的数组。时间复杂度为$O(nlogn)$</li>
<li>利用哈希表，从头到尾扫描数组，每一个数字利用$O(1)$的时间检查数字是否在哈希表中，如果没有则加入，如果存在表明此数字重复。时间复杂度$O(n)$，空间复杂度$O(n)$。</li>
<li>利用从0~n-1个共n个数字这一特点，若无重复数字，排序后数字 $i$ 在数组下标 $i$ 的位置上。从头开始扫描数组$arr$，记扫描到下标为 $i$ 的数字$arr[i]$为 $m$，比较 $i==m $，若相等，$i+1$，若不等则比较$arr[m]$和$m$， 若相等，找到重复数字，若不等则交换数组 $i, m$位置上的数。每个数字最多交换两次就能找到属于自己的位置。时间复杂度$O(n)$， 空间复杂度$O(1)$。<img src="/2019/11/08/剑指offer-Python/1.gif"> 
</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> numbers == <span class="literal">None</span> <span class="keyword">or</span> len(numbers) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            <span class="keyword">if</span> numbers[i] &lt; <span class="number">0</span> <span class="keyword">or</span> numbers[i] &gt; len(numbers) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            <span class="keyword">while</span> numbers[i] != i:</span><br><span class="line">                <span class="keyword">if</span> numbers[i] == numbers[numbers[i]]:</span><br><span class="line">                    duplication[<span class="number">0</span>] = numbers[i]</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp = numbers[i]</span><br><span class="line">                    numbers[i] = numbers[temp]</span><br><span class="line">                    numbers[temp] = temp</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-3-2-：不修改数组找出重复的数字"><a href="#面试题-3-2-：不修改数组找出重复的数字" class="headerlink" title="面试题 3.2 ：不修改数组找出重复的数字"></a>面试题 3.2 ：不修改数组找出重复的数字</h5><p>长度为$n+1$的数组，所有数字都在1~n的范围内，不修改数组找出数组中任意重复的数字。</p>
<p>两种解决方法：</p>
<ol>
<li>利用一个辅助数组，从头扫描原数组，将数字 $i$ 放入新数组下标为 $i$ 的位置。时间复杂度$O(n)$，空间复杂度$O(n)$。</li>
<li>二分查找变形：1~n范围内只有n个数字，一定含有重复数字，某范围内数字的个数是解决问题的关键。首先把1~n的数字从中间数字分开前半部分1~m，后半部分m+1~n， 查看1~m范围上数字的个数，若大于m，有重复，再将1~m范围的数字二分，否则检查m+1~n范围的数字个数。时间复杂度$O(nlogn)$, 空间复杂度$O(1)$。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> numbers == <span class="literal">None</span> <span class="keyword">or</span> len(numbers) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        start = <span class="number">1</span></span><br><span class="line">        end = len(numbers)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> end &gt;= start:</span><br><span class="line">            middle = (end-start) // <span class="number">1</span> + start</span><br><span class="line">            count = self.countRange(numbers, start, middle)</span><br><span class="line">            <span class="keyword">if</span> end == start:</span><br><span class="line">                <span class="keyword">if</span> count &gt; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; middle - start + <span class="number">1</span>:</span><br><span class="line">                end = middle</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = middle + <span class="number">1</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countRange</span><span class="params">(numbers, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> numbers == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            <span class="keyword">if</span> start&lt;= numbers[i] <span class="keyword">and</span> numbers[i] &lt;= end:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-4：-二维数组中的查找"><a href="#面试题-4：-二维数组中的查找" class="headerlink" title="面试题 4： 二维数组中的查找"></a>面试题 4： 二维数组中的查找</h5><p>一个二维数组其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在二维数组中。 </p>
<ol>
<li>从右上角开始或者从左下角开始。从右上角开始，若大于要找的数，去掉一列，若小于要找的数，去掉一行。<img src="/2019/11/08/剑指offer-Python/2.gif">
</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> array == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        m = len(array)</span><br><span class="line">        n = len(array[<span class="number">0</span>])</span><br><span class="line">        row = <span class="number">0</span>  <span class="comment"># 注意m和row的取值，row的取值为0-m-1</span></span><br><span class="line">        col = n - <span class="number">1</span> </span><br><span class="line">        <span class="keyword">while</span> row &lt; m <span class="keyword">and</span> col &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> target &gt; array[row][col]:</span><br><span class="line">                row += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> target &lt; array[row][col]:</span><br><span class="line">                col -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-5：-替换空格"><a href="#面试题-5：-替换空格" class="headerlink" title="面试题 5： 替换空格"></a>面试题 5： 替换空格</h5><p>把字符串中的每个空格替换成“%20”</p>
<p>两种解决方法：</p>
<ol>
<li>创建一个新的字符串，在新的字符串上做替换，需要足够的内存</li>
<li>在原字符串上替换，可能会覆盖修改在该字符串后面的内存，准备两个指针<font color="red">从后向前</font>替换，  $P1$ 指向字符串原来的末尾位置，$P2$ 指向字符串替换后的末尾位置 ，将$P1 $和$P2$从后向前遍历，当 $P1$遇到空格时，  $P1$向前移动一格，  $P2$写入%20（注意逆序写入02%）  否则就在$P2$位置填充$P1$内容，当$P1$与$P2$相等，所有空格替换完成。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s == null:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        s = list(s)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">' '</span>: count += <span class="number">1</span></span><br><span class="line">        p1 = len(s) - <span class="number">1</span></span><br><span class="line">        s += [<span class="literal">None</span>] * count * <span class="number">2</span></span><br><span class="line">        p2 = len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &gt;= <span class="number">0</span> :</span><br><span class="line">            <span class="keyword">if</span> s[p1] == <span class="string">' '</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">'0'</span>, <span class="string">'2'</span>, <span class="string">'%'</span>]:</span><br><span class="line">                    s[p2] = i</span><br><span class="line">                    p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s[p2] = s[p1]</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            p1 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-6：-从尾到头打印链表"><a href="#面试题-6：-从尾到头打印链表" class="headerlink" title="面试题 6： 从尾到头打印链表"></a>面试题 6： 从尾到头打印链表</h5><ol>
<li>允许修改链表结构：改变链表的方向，</li>
<li>不允许修改链表结构：后进先出——栈结构</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> listNode:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> listNode:</span><br><span class="line">            result.append(listNode.val)</span><br><span class="line">            listNode = listNode.next</span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-7：-重建二叉树"><a href="#面试题-7：-重建二叉树" class="headerlink" title="面试题 7： 重建二叉树"></a>面试题 7： 重建二叉树</h5><p>输入某二叉树的前序遍历和中序遍历（输入的前序遍历和中序遍历的结果中不含重复数字），重建该二叉树并输出头节点。</p>
<ol>
<li>前序遍历中，第一个数字是二叉树的头节点，此数字在中序遍历中处于中间位置，且位于左边的是左树上的节点。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        val = tin.index(pre[<span class="number">0</span>])</span><br><span class="line">        root.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:val+<span class="number">1</span>], tin[<span class="number">0</span>:val])</span><br><span class="line">        root.right = self.reConstructBinaryTree(pre[val+<span class="number">1</span>:], tin[val+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-8：-二叉树的下一个节点"><a href="#面试题-8：-二叉树的下一个节点" class="headerlink" title="面试题 8：  二叉树的下一个节点"></a>面试题 8：  二叉树的下一个节点</h5><p>给定一棵二叉树和其中一个节点，获取中序遍历的下一个节点。（树节点的结构中含有指向父节点的指针）</p>
<ol>
<li>节点有右子树：节点的下一个节点为右子树的最左节点。</li>
<li>节点无右子树且此节点为其父节点的左子节点：其父节点即为下一个节点；</li>
<li>节点无右子树且此节点为其父节点的右子节点：向上追溯，直到找到一个节点为其父节点的左子节点，父节点即为下一个节点。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeLinkNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pNode:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        rightTree = pNode.right</span><br><span class="line">        <span class="keyword">if</span> rightTree != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> rightTree.left != <span class="literal">None</span>:</span><br><span class="line">                rightTree = rightTree.left</span><br><span class="line">            <span class="keyword">return</span> rightTree</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> pNode.next != <span class="literal">None</span> <span class="keyword">and</span> pNode.next.left != pNode:</span><br><span class="line">                pNode = pNode.next</span><br><span class="line">            <span class="keyword">return</span> pNode.next</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-9-1：-用两个栈实现队列"><a href="#面试题-9-1：-用两个栈实现队列" class="headerlink" title="面试题 9.1： 用两个栈实现队列"></a>面试题 9.1： 用两个栈实现队列</h5><p>实现 appendTail 和 deleteHead 分别完成在队列尾部插入结点和在队列头部删除节点。</p>
<ol>
<li>头部删除一个节点：若stack2为空，将stack1中所有元素依次弹出存入stack2中，并将stack2栈顶弹出；若stack2不为空，直接弹出stack2的栈顶。</li>
<li>尾部插入一个节点：压入stack1即可。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">            <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stack2.pop()</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-9-2：-用两个队列实现一个栈"><a href="#面试题-9-2：-用两个队列实现一个栈" class="headerlink" title="面试题 9.2： 用两个队列实现一个栈"></a>面试题 9.2： 用两个队列实现一个栈</h5><p>实现栈的压入和弹出</p>
<ol>
<li>栈的弹出：找出两个队列中不为空的，保留最后一个元素，前面所有元素放入另一个为空的队列中，并将最后一个元素弹出。</li>
<li>栈的压入：当两个队列都为空时，插入其中一个队列，若有一个队列不为空，插入队尾。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.queue1 = []</span><br><span class="line">        self.queue2 = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.queue1:</span><br><span class="line">            self.queue.append(node)</span><br><span class="line">        <span class="keyword">elif</span> self.queue2:</span><br><span class="line">            self.queue2.append(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.queue1.append(nodde)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.queue1 <span class="keyword">and</span> <span class="keyword">not</span> self.queue2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.queue1:</span><br><span class="line">            <span class="keyword">while</span> len(self.queue1) != <span class="number">1</span>:</span><br><span class="line">                self.queue2.append(self.queue1.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> self.queue1.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> len(self.queue2) != <span class="number">1</span>:</span><br><span class="line">                self.queue1.append(elf.queue2.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> self.queue2.pop()</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-10-1-：斐波那契数列"><a href="#面试题-10-1-：斐波那契数列" class="headerlink" title="面试题 10.1 ：斐波那契数列"></a>面试题 10.1 ：斐波那契数列</h5><p>求斐波那契数列的第n项。</p>
<script type="math/tex; mode=display">
f(n)=\left\{\begin{array}{rl}{0} & {n=0} \\ {1} & {n=1} \\ {f(n-1)+f(n-2)} & {n>1}\end{array}\right.</script><ol>
<li>递归方法：但有严重的效率问题，原因是会重复计算很多节点，造成其时间复杂度以 n 的指数的方式递增。</li>
<li>for循环：避免重复计算，将已经计算过的数列中间项保存起来。从下往上计算，时间复杂度$O(n)$。</li>
<li>利用两个数学公式，时间复杂度为$O(\log n)$，但不实用，且隐含的时间常数较大。<script type="math/tex; mode=display">
\left[\begin{array}{l}{f(n)} & {f(n-1)} \\ {f(n-1)} & {f(n-2)}\end{array}\right]=\left[\begin{array}{ll}{1} & {1} \\ {1} & {0}\end{array}\right]^{n-1}</script><script type="math/tex; mode=display">
a^{n}=\left\{\begin{array}{ll}{a^{n / 2} \cdot a^{n / 2}} & {n为偶数} \\ {a^{(n-1) / 2} \cdot a^{(n-1) / 2} \cdot a} & {n为奇数}\end{array}\right.</script></li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        <span class="keyword">elif</span> n &lt;=<span class="number">39</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">                result = a + b</span><br><span class="line">                a = b</span><br><span class="line">                b = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-10-2-：青蛙跳台阶问题"><a href="#面试题-10-2-：青蛙跳台阶问题" class="headerlink" title="面试题 10.2 ：青蛙跳台阶问题"></a>面试题 10.2 ：青蛙跳台阶问题</h5><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。该青蛙跳上一个 n 级的台阶共有多少种跳法（先后次序不同算不同的结果）。<br>$n=1$时只有一种跳法；$n=2$时，两种跳法（每次跳一个台阶 / 一次跳两个台阶）；$n&gt;2$时，第一跳有两种不同的选择，跳一个台阶（剩下$n-1$个台阶）或跳两个台阶（剩下$n-2$个台阶）。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">while</span> len(res) &lt; number:</span><br><span class="line">                res.append(res[<span class="number">-1</span>] + res[<span class="number">-2</span>])</span><br><span class="line">            <span class="keyword">return</span> res[number<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-10-3-：变态跳台阶"><a href="#面试题-10-3-：变态跳台阶" class="headerlink" title="面试题 10.3 ：变态跳台阶"></a>面试题 10.3 ：变态跳台阶</h5><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级…也可以跳上n级。该青蛙跳上一个 n 级的台阶总共有多少种跳法。<br>$n= 1$, 则剩下跳法是f(n-1)；$n=2$级，则剩下跳法是$f(n-2)$；所以$f(n)=f(n-1)+f(n-2)+…+f(1)$<br>因为$f(n-1)=f(n-2)+f(n-3)+…+f(1)$，所以$f(n)=2*f(n-1)$，则$f(n)=2^{n-1}$种跳法。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> number<span class="number">-1</span> &gt; <span class="number">0</span>:</span><br><span class="line">            res = res * <span class="number">2</span></span><br><span class="line">            number = number <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-10-4-：矩形覆盖"><a href="#面试题-10-4-：矩形覆盖" class="headerlink" title="面试题 10.4 ：矩形覆盖"></a>面试题 10.4 ：矩形覆盖</h5><p>可以用$2 <em> 1$的小矩形横着或者竖着去覆盖更大的矩形。请问用n个$2 </em>1$的小矩形无重叠地覆盖一个$2 * n$的大矩形，总共有多少种方法？ </p>
<ol>
<li>若横着放，则剩下的部分为$n-1$</li>
<li>若竖着放，则剩下的部分为$n-2$</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        res_1 = <span class="number">1</span></span><br><span class="line">        res_2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> number - <span class="number">1</span> &gt; <span class="number">0</span>:</span><br><span class="line">            res = res_1 + res_2</span><br><span class="line">            res_1 = res_2</span><br><span class="line">            res_2 = res</span><br><span class="line">            number = number - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-11：旋转数组的最小数字"><a href="#面试题-11：旋转数组的最小数字" class="headerlink" title="面试题 11：旋转数组的最小数字"></a>面试题 11：旋转数组的最小数字</h5><p>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 ( 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。)</p>
<ol>
<li>遍历数组：时间复杂度$O(N)$</li>
<li><p>二分法：旋转后的数组划分为两个排序的子数组，且前面子数组元素都大于或者等于后面子数组的元素，最小元素为分界线。<br>步骤：</p>
<ol>
<li>使用两个指针分别指向数组的开始$P_{1}$和结尾$P_{2}$，</li>
<li>若第一个数字小于最后一个数字：说明第一个数即为最小元素。</li>
<li><p>若第一个数大于或等于最后一个数：找到$P_{1}$和$P_{2}$中间位置的数，若此数大于$P_{1}$所指的数，则$P_{1}=\frac {P_{1}+P_{2}}{2}$，若此数小于或等于$P_{2}$所指的数，则$P_{2}=\frac {P_{1}+P_{2}}{2}$，如此循环直到$P_{1}$和$P_{2}$相邻时，$P_{2}$所指的数字即为最小元素。</p>
<p>特殊情况：若$P_{1}$位置上的数等于$P_{2}$位置上的数且等于它们中间的数字时：需采用顺序查找的方法进行查找</p>
</li>
</ol>
</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        p1 = <span class="number">0</span></span><br><span class="line">        p2 = len(rotateArray)<span class="number">-1</span></span><br><span class="line">        mid = p1</span><br><span class="line">        <span class="keyword">while</span> rotateArray[p1] &gt;= rotateArray[p2]:</span><br><span class="line">            <span class="keyword">if</span> p2 - p1 == <span class="number">1</span>:</span><br><span class="line">                mid = p2</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            mid = (p1+p2)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[p1] == rotateArray[mid] <span class="keyword">and</span> rotateArray[p2] == rotateArray[mid]:</span><br><span class="line">                <span class="keyword">return</span> self.minValue(rotateArray, p1, p2)</span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid] &gt;= rotateArray[p1]:</span><br><span class="line">                p1 = mid</span><br><span class="line">            <span class="keyword">elif</span> rotateArray[mid] &lt;= rotateArray[p2]:</span><br><span class="line">                p2 = mid</span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minValue</span><span class="params">(self, rotateArray, p1, p2)</span>:</span></span><br><span class="line">        res = rotateArray[p1]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(p1+<span class="number">1</span>, p2+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> rotateArray[i] &lt; res:</span><br><span class="line">                res = rotateArray[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-12：矩阵中的路径"><a href="#面试题-12：矩阵中的路径" class="headerlink" title="面试题 12：矩阵中的路径"></a>面试题 12：矩阵中的路径</h5><p>判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。<br>路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 </p>
<ol>
<li>回溯法：回溯法算法适合使用递归实现<br>路径不能重复进入矩阵的格子，需要定义和字符矩阵大小一样的布尔值矩阵，标识路径是否已经进入了每个格子。<font color="red">通常在二维矩阵上找路径的问题都可以应用回溯法解决。</font>

</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">and</span> rows &lt; <span class="number">1</span> <span class="keyword">and</span> cols &lt; <span class="number">1</span> <span class="keyword">and</span> path==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        visited = [<span class="number">0</span>] * (rows * cols)</span><br><span class="line">        pathLength = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> self.hasPathCore(matrix, rows, cols, row, col, path, pathLength, visited):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathCore</span><span class="params">(self, matrix, rows, cols, row, col, path, pathLength, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == pathLength:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        hasPath = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> row &gt;= <span class="number">0</span> <span class="keyword">and</span> row &lt; rows <span class="keyword">and</span> col &gt;= <span class="number">0</span> <span class="keyword">and</span> col &lt; cols <span class="keyword">and</span> matrix[row*cols+col]== path[pathLength] <span class="keyword">and</span> <span class="keyword">not</span> visited[row*cols+col]:</span><br><span class="line">            pathLength += <span class="number">1</span></span><br><span class="line">            visited[row*cols+col] = <span class="number">1</span></span><br><span class="line">            hasPath = self.hasPathCore(matrix, rows, cols, row<span class="number">-1</span>, col, path, pathLength, visited) \</span><br><span class="line">                    <span class="keyword">or</span> self.hasPathCore(matrix, rows, cols, row+<span class="number">1</span>, col, path, pathLength, visited) \</span><br><span class="line">                    <span class="keyword">or</span> self.hasPathCore(matrix, rows, cols, row, col<span class="number">-1</span>, path, pathLength, visited) \</span><br><span class="line">                    <span class="keyword">or</span> self.hasPathCore(matrix, rows, cols, row, col+<span class="number">1</span>, path, pathLength, visited)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> hasPath:</span><br><span class="line">                pathLength -= <span class="number">1</span></span><br><span class="line">                visited[row*cols+col] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> hasPath</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-13：-机器人的运动范围"><a href="#面试题-13：-机器人的运动范围" class="headerlink" title="面试题 13： 机器人的运动范围"></a>面试题 13： 机器人的运动范围</h5><p>地上有一个 m 行和 n 列的方格。一个机器人从坐标$(0,0)$的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。 请问该机器人能够达到多少个格子？ （回溯法）<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> threshold &lt; <span class="number">0</span> <span class="keyword">and</span> rows &lt; <span class="number">1</span> <span class="keyword">and</span> cols &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        visited = [<span class="number">0</span>] * (rows * cols)</span><br><span class="line">        count = self.movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCountCore</span><span class="params">(self, threshold, rows, cols, row, col, visited)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.check(threshold, rows, cols, row, col, visited):</span><br><span class="line">            visited[row*cols + col] = <span class="number">1</span></span><br><span class="line">            count = <span class="number">1</span> + self.movingCountCore(threshold, rows, cols, row+<span class="number">1</span>, col, visited)\</span><br><span class="line">                    + self.movingCountCore(threshold, rows, cols, row<span class="number">-1</span>, col, visited)\</span><br><span class="line">                    + self.movingCountCore(threshold, rows, cols, row, col<span class="number">-1</span>, visited)\</span><br><span class="line">                    + self.movingCountCore(threshold, rows, cols, row, col+<span class="number">1</span>, visited)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, threshold, rows, cols, row, col, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> row &gt;= <span class="number">0</span> <span class="keyword">and</span> row &lt; rows <span class="keyword">and</span> col &gt;= <span class="number">0</span> <span class="keyword">and</span> col &lt; cols <span class="keyword">and</span> <span class="keyword">not</span> visited[row * cols + col] <span class="keyword">and</span> self.getDigitSum(row) + self.getDigitSum(col) &lt;= threshold:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDigitSum</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> number &gt; <span class="number">0</span>:</span><br><span class="line">            sum += number % <span class="number">10</span></span><br><span class="line">            number /= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题-14：-剪绳子"><a href="#面试题-14：-剪绳子" class="headerlink" title="面试题 14： 剪绳子"></a>面试题 14： 剪绳子</h5><p>给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（m、n都是整数，$n&gt;1$并且$m&gt;1$），每段绳子的长度记为$k[0],k[1],…,k[m]$。请问$k[0]<em>k[1]</em>…*k[m]$可能的最大乘积是多少？ </p>
<ol>
<li><p>动态规划：时间复杂度$O(n^{2})$，空间复杂度$O(n)$，可以应用动态规划求解的问题的三个特点：</p>
<ol>
<li>求一个问题的最优解</li>
<li>整体问题的最优解依赖各个子问题的最优解</li>
<li>大问题可分解为若干小问题，小问题之间还有相互重叠的更小的子问题</li>
</ol>
<p><font color="red">从上往下分析问题，从下往上求解问题。</font><br>定义$f(n)=max(f(i)*f(n-i))其中0&lt;i&lt;n$，当$n=0, 1, 2, 3$时$f(n)&lt;n$为特例，需单独处理。</p>
</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> number == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> number == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        res = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>, number+<span class="number">1</span>):</span><br><span class="line">            res_max = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, int(i/<span class="number">2</span>)+<span class="number">1</span>):</span><br><span class="line">                product = res[j] * res[i-j]</span><br><span class="line">                <span class="keyword">if</span> product &gt; res_max:</span><br><span class="line">                    res_max = product</span><br><span class="line">            res.append(res_max)</span><br><span class="line">        <span class="keyword">return</span> res[number]</span><br></pre></td></tr></table></figure>

</div></div>
<ol>
<li>贪婪算法：时间复杂度$O(1)$，空间复杂度$O(1)$<br>每一步做出一个贪婪选择，基于这个选择，确定能够得到最优解。<br>策略：当$n\ge 5$时，尽可能多地剪长度为3地绳子，当剩下地绳子的长度为4时，将绳子剪成长度为2的绳子。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> number == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> number == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        num_3 = int(number / <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">if</span> number - num_3 * <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">            num_3 -= <span class="number">1</span></span><br><span class="line">        num_2 = (number - num_3 * <span class="number">3</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">3</span> ** num_3) * (<span class="number">2</span> ** num_2)</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-15：二进制中-1-的个数"><a href="#面试题-15：二进制中-1-的个数" class="headerlink" title="面试题 15：二进制中 1 的个数"></a>面试题 15：二进制中 1 的个数</h5><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 </p>
<ol>
<li>右移法：判断整数二进制表示中最右边一位是否为 1（和 1 做“与运算”，输出为 1 表示最右位为 1)，之后整数右移，继续判断。注意：不能利用除 2 代替位运算（效率低）且当整数为负数时会出现死循环。</li>
<li>避免死循环：不右移输入数字，每次左移 1 ，依次循环，循环的次数等于整数二进制的位数。</li>
<li>把一个整数减去1，再和原整数做“与运算”，会把该整数最右边的1变成0。那么一个整数的二进制中表示中有多少个1，就可以进行多少次这样的操作。  <font color="red">把一个整数减去 1 之后再和原来的整数做“位与”运算，得到的结果相当于把整数的二进制表示中最右边的 1 变成 0。</font>

</li>
</ol>
<img src="/2019/11/08/剑指offer-Python/3.png">
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span> :</span><br><span class="line">      n = n &amp; <span class="number">0xffffffff</span>  <span class="comment"># 负数采用补码的形式</span></span><br><span class="line">      <span class="keyword">while</span> n:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        n = (n - <span class="number">1</span>) &amp; n</span><br><span class="line">      <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

</div></div>
<p>相关题目：</p>
<ol>
<li>判别一个整数是不是 2 的整数次方：如果是，则它的二进制表示中有且仅有一位为 1，其他所有位为 0。</li>
<li>修改 m 的二进制表示中的多少位能得到 n：先将两个数异或，统计异或结果中 1 的个数（位数）。</li>
</ol>
<h5 id="面试题-16：数值的整数次方"><a href="#面试题-16：数值的整数次方" class="headerlink" title="面试题 16：数值的整数次方"></a>面试题 16：数值的整数次方</h5><p>考虑代码的完整性：</p>
<ol>
<li>输入的指数小于 1 时（零或负数）：当指数为负数时，可先对指数求绝对值，计算出次方结果后取倒数。当底数为 0 且指数为负数时，出现对 0 求倒数，需处理异常出错情况。</li>
<li>0 的 0 次方没有数学意义，输出为 0 或 1 均可。</li>
<li>利用公式实现时间复杂度为 $O(\log n)$ ：<script type="math/tex; mode=display">
a^{n}=\left\{\begin{array}{ll}{a^{n / 2} \cdot a^{n / 2}} & {n为偶数} \\ {a^{(n-1) / 2} \cdot a^{(n-1) / 2} \cdot a} & {n为奇数}\end{array}\right.</script></li>
<li>其他细节问题：右移运算——&gt; 除2，位与运算——&gt; 求余 <font color="red">判断 num 为奇数还是偶数：【num & 0x1 】为 1 表明为奇数，即二进制的最低位为1。</font>

</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.g_InvalidInput = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> base == <span class="number">0.0</span> <span class="keyword">and</span> exponent &lt; <span class="number">0</span>:</span><br><span class="line">            self.g_InvalidInput = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">if</span> exponent &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.PowerWithUnsignedExponent(base, exponent)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> / self.PowerWithUnsignedExponent(base, -exponent)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> exponent == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> exponent == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> base</span><br><span class="line">        res = self.PowerWithUnsignedExponent(base, exponent&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        res *= res</span><br><span class="line">        <span class="keyword">if</span> exponent &amp; <span class="number">0x1</span>:</span><br><span class="line">            res *= base</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-17：-打印从-1-到最大的-n-位数"><a href="#面试题-17：-打印从-1-到最大的-n-位数" class="headerlink" title="面试题 17： 打印从 1 到最大的 n 位数"></a>面试题 17： 打印从 1 到最大的 n 位数</h5><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。 </p>
<ol>
<li>n 的范围：当 n 很大时，最大 n 位数为整型或长整型是否都会溢出？<br>解决办法：需要表达一个大数，可使用字符串或者数组<ol>
<li>字符串表示大数：字符串中每个字符都是‘0’~‘9’之间的某个字符，表示数字中的一位。数字最大是 n 位的，需要一个长度为 n的字符串，实际数字不够 n 位时，字符串前半部分补0。需完成两件事情：a. 在字符串表达的数字上模拟加法；（只有在达到最大的 n 位十进制数时 +1 操作会在第一个字符上出现进位）b. 打印字符串表达的数字，补位 0 不应该打印出来。</li>
<li>数字全排列：把数字的每一位都从 0 到 9 排序一遍。</li>
</ol>
</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintToMaxOfNDigits</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        number = [<span class="string">'0'</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">            number[<span class="number">0</span>] = str(i) </span><br><span class="line">            self.PrintToMaxOfNDigitsRecursively(number, n, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintToMaxOfNDigitsRecursively</span><span class="params">(self, number, length, index)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == length - <span class="number">1</span>:</span><br><span class="line">            self.PrintNumber(number, length)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">            number[index+<span class="number">1</span>] = str(i)</span><br><span class="line">            self.PrintToMaxOfNDigitsRecursively(number, length, index+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintNumber</span><span class="params">(self, number, length)</span>:</span></span><br><span class="line">        <span class="comment"># print(number)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">if</span> number[i] != <span class="string">'0'</span>:</span><br><span class="line">                print(<span class="string">''</span>.join(number[i:]))</span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

</div></div>
<p>补充：实现在字符串表示的数字上加 1 ，并在越界是返回</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Increment</span><span class="params">(number)</span>:</span></span><br><span class="line">    isOverflow = <span class="literal">False</span></span><br><span class="line">    nTakeOver = <span class="number">0</span></span><br><span class="line">    nLength = len(number)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nLength<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        nSum = int(number[i]) - int(<span class="string">'0'</span>) + nTakeOver</span><br><span class="line">        <span class="keyword">if</span> i == nLength - <span class="number">1</span>:  <span class="comment"># 个位+1</span></span><br><span class="line">            nSum += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nSum &gt;= <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                isOverflow = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nSum -= <span class="number">10</span></span><br><span class="line">                nTakeOver = <span class="number">1</span></span><br><span class="line">                number[i] = str(int(<span class="string">'0'</span>) + nSum)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            number[i] = str(int(<span class="string">'0'</span>) + nSum)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> isOverflow</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-18-1-：删除链表的节点"><a href="#面试题-18-1-：删除链表的节点" class="headerlink" title="面试题 18.1 ：删除链表的节点"></a>面试题 18.1 ：删除链表的节点</h5><p>给定单向链表的头指针和一个节点指针，在$O(1)$时间内删除该节点。</p>
<ol>
<li>从链表的头节点开始，顺序遍历查找要删除的节点，并删除。时间复杂度$O(n)$。</li>
<li>找到要删除节点的下一个节点，并用下一个节点的内容复制到要删除节点上，再删除下一个节点。<br>特殊情况：要删除的节点位与链表的尾部——采用顺序遍历，并删除的方法。链表中只有一个节点，删除链表的头节点（也是尾节点）—— 删除节点后需将链表的头设为None<br>时间复杂度为$O(1)$<br>以上基于一种假设：要删除的节点的确在链表中，判断节点是否在链表中需要$O(n)$时间复杂度。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        三个循环的顺序很重要，若 node.next == None 先判断，那个删除含有多个节点的链表的头节点时将出错，最后记得返回链表的头节点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> node.next != <span class="literal">None</span>:</span><br><span class="line">            next_node = node.next</span><br><span class="line">            node.val = next_node.val</span><br><span class="line">            node.next = next_node.next</span><br><span class="line">        <span class="keyword">elif</span> head == node:</span><br><span class="line">            head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 节点为链表的尾节点</span></span><br><span class="line">            pre_node = head</span><br><span class="line">            <span class="keyword">while</span> pre_node.next != node:</span><br><span class="line">                pre_node = pre_node.next</span><br><span class="line">            pre_node.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-18-2：-删除链表中重复的节点"><a href="#面试题-18-2：-删除链表中重复的节点" class="headerlink" title="面试题 18.2： 删除链表中重复的节点"></a>面试题 18.2： 删除链表中重复的节点</h5><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。</p>
<ol>
<li>从头遍历整个链表，删除重复节点。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        head = ListNode(<span class="number">-1</span>)</span><br><span class="line">        head.next = pHead</span><br><span class="line">        pre_node = head</span><br><span class="line">        <span class="keyword">while</span> pHead <span class="keyword">and</span> pHead.next:</span><br><span class="line">            <span class="keyword">if</span> pHead.val == pHead.next.val:</span><br><span class="line">                val = pHead.val</span><br><span class="line">                <span class="keyword">while</span> pHead <span class="keyword">and</span> pHead.val == val:</span><br><span class="line">                    pHead = pHead.next</span><br><span class="line">                pre_node.next = pHead</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre_node = pHead</span><br><span class="line">                pHead = pHead.next</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure>

</div></div>
<ol>
<li>将链表元素保存在列表中，并删除重复元素后再组成新链表。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication2</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> pHead != <span class="literal">None</span>:</span><br><span class="line">            res.append(pHead.val)</span><br><span class="line">            pHead = pHead.next</span><br><span class="line">        res=list(filter(<span class="keyword">lambda</span> c:res.count(c)==<span class="number">1</span>,res))</span><br><span class="line">        </span><br><span class="line">        newList=ListNode(<span class="number">0</span>)</span><br><span class="line">        pre=newList</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">            node=ListNode(i)</span><br><span class="line">            pre.next=node</span><br><span class="line">            pre=pre.next</span><br><span class="line">        <span class="keyword">return</span> newList.next</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-19：正则表达式匹配"><a href="#面试题-19：正则表达式匹配" class="headerlink" title="面试题 19：正则表达式匹配"></a>面试题 19：正则表达式匹配</h5><p>匹配包括 “.” 和 “ <em> ”的正则表达式，模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 </p>
<p>当模式中的字符为 “ <em> ”时，存在多种匹配方式 a. 模式上向后移动两个字符，字符串不动（” </em> “前的字符与字符串字符不匹配 / ” <em> “前的字符前的个数可为0个）；b. 字符串向后移动一个字符，模式向后移动两个字符（” </em> “前的字符与字符串字符匹配，向后继续）；  c. 字符串向后移动一个字符，模式不动（” * “前的字符可以匹配任意多个字符）。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s, pattern都是字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, s, pattern)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.matchCore(s, pattern)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matchCore</span><span class="params">(self, list_s, list_pat)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list_s  <span class="keyword">and</span> <span class="keyword">not</span> list_pat:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> list_s <span class="keyword">and</span> <span class="keyword">not</span> list_pat:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(list_pat) &gt; <span class="number">1</span> <span class="keyword">and</span> list_pat[<span class="number">1</span>]== <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">if</span> list_s <span class="keyword">and</span> (list_s[<span class="number">0</span>] == list_pat[<span class="number">0</span>] <span class="keyword">or</span> list_pat[<span class="number">0</span>] == <span class="string">'.'</span>):</span><br><span class="line">                <span class="keyword">return</span> self.matchCore(list_s[<span class="number">1</span>:], list_pat[<span class="number">2</span>:]) <span class="keyword">or</span> self.matchCore(list_s[<span class="number">1</span>:], list_pat) <span class="keyword">or</span> self.matchCore(list_s, list_pat[<span class="number">2</span>:])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.matchCore(list_s, list_pat[<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">if</span> list_s <span class="keyword">and</span> (list_s[<span class="number">0</span>] == list_pat[<span class="number">0</span>] <span class="keyword">or</span> list_pat[<span class="number">0</span>] == <span class="string">'.'</span>):</span><br><span class="line">            <span class="keyword">return</span> self.matchCore(list_s[<span class="number">1</span>:], list_pat[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-20：-表示数值的字符串"><a href="#面试题-20：-表示数值的字符串" class="headerlink" title="面试题 20： 表示数值的字符串"></a>面试题 20： 表示数值的字符串</h5><p>判断字符串是否表示数值（包括整数和小数）。</p>
<p>表示数值的字符串遵循模式 $ A[.[B]][e|EC]$ 或者 $.B[e|EC]$  其中 A 为整数部分，B 为小数部分，C 为指数部分。A 部分不是必需的，但如果A部分不存在，即整数部分不存在，那么小数部分不能为空。A 和 C都可以以 ‘+’ 、‘-’ 或 ‘0~9’ 开头，B 只能以 ‘0~9’ 。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        s = s + <span class="string">'\0'</span></span><br><span class="line">        numeric, index = self.scanInteger(s, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> s[index] == <span class="string">'.'</span>:</span><br><span class="line">            index += <span class="number">1</span> </span><br><span class="line">            numeric, index = self.scanUnsignedInteger(s, index) <span class="keyword">or</span> numeric</span><br><span class="line">        <span class="keyword">if</span> s[index] == <span class="string">'e'</span> <span class="keyword">or</span> s[index] == <span class="string">'E'</span>:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            numeric_, index = self.scanInteger(s, index)</span><br><span class="line">            numeric = numeric <span class="keyword">and</span> numeric_</span><br><span class="line">        <span class="keyword">return</span> numeric <span class="keyword">and</span> s[index] == <span class="string">'\0'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scanInteger</span><span class="params">(self, s, index)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s[index] == <span class="string">'+'</span> <span class="keyword">or</span> s[index] == <span class="string">'-'</span>:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.scanUnsignedInteger(s, index)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scanUnsignedInteger</span><span class="params">(self, s, index)</span>:</span></span><br><span class="line">        before = index</span><br><span class="line">        number = [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>]</span><br><span class="line">        <span class="keyword">while</span> s[index]!=<span class="string">'\0'</span> <span class="keyword">and</span> s[index] <span class="keyword">in</span> number:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> index &gt; before, index</span><br></pre></td></tr></table></figure>

</div></div>
<p>其他方法：</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> len(s)&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        alist=[i.lower() <span class="keyword">for</span> i <span class="keyword">in</span> s]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'e'</span> <span class="keyword">in</span> alist:</span><br><span class="line">            index=alist.index(<span class="string">'e'</span>)</span><br><span class="line">            front=alist[:index]</span><br><span class="line">            behind=alist[index+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">in</span> behind <span class="keyword">or</span> len(behind)==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            isfront=self.isDigit(front)</span><br><span class="line">            isbehind=self.isDigit(behind)</span><br><span class="line">            <span class="keyword">return</span> isfront <span class="keyword">and</span> isbehind</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isDigit(alist)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isDigit</span><span class="params">(self,alist)</span>:</span></span><br><span class="line">        dotNum=<span class="number">0</span></span><br><span class="line">        allow_num = [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>,</span><br><span class="line">                     <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'.'</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(alist)):</span><br><span class="line">            <span class="keyword">if</span> alist[i] <span class="keyword">not</span> <span class="keyword">in</span> allow_num:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> alist[i]==<span class="string">'.'</span>:</span><br><span class="line">                dotNum += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> alist[i] <span class="keyword">in</span> <span class="string">'+-'</span> <span class="keyword">and</span> i!=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> dotNum&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-21：调整数组顺序使奇数位于偶数前面"><a href="#面试题-21：调整数组顺序使奇数位于偶数前面" class="headerlink" title="面试题 21：调整数组顺序使奇数位于偶数前面"></a>面试题 21：调整数组顺序使奇数位于偶数前面</h5><p>输入一个整数数组，调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 （保持稳定性）</p>
<ol>
<li>不考虑时间复杂度：从头扫描数组，遇到偶数时，拿出数字，并将位与这个数字之后的所有数字前移一位，在数组末尾放入此数。时间复杂度 $O(n^{2})$。</li>
<li>利用指针，但无法维持稳定性：扫描整个数组，若发现偶数出现在奇数前面，交换顺序。两个指针 $P_{1}$ （指向数组第一个数字）和 $P_{2}$ （指向数组最后一个数字），当 $P_{2}$ 指向奇数，且 $P_{1}$ 指向奇数时，$P_{1}$ 向后移动，直到 $P_{1}$ 指向偶数，交换两个指针所指的数字；之后 $P_{1}$ 一直向后移动直到碰到下一个偶数，$P_{2}$ 一直向前移动，直到碰到下一个奇数，当 $P_{2}$ 所指的位置在$P_{1}$ 前面时，表示已经将所有的奇数放在偶数前面了。时间复杂度 $O(n)$，空间复杂度 $O(1)$ 。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array <span class="keyword">or</span> len(array)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array</span><br><span class="line">        p1 = <span class="number">0</span></span><br><span class="line">        p2 = len(array) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; p2:</span><br><span class="line">            <span class="keyword">while</span> p1 &lt; p2 <span class="keyword">and</span> array[p1] % <span class="number">2</span>:</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> p1 &lt; p2 <span class="keyword">and</span> <span class="keyword">not</span> array[p2] % <span class="number">2</span>:</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p1 &lt; p2:</span><br><span class="line">                temp = array[p1]</span><br><span class="line">                array[p1] = array[p2]</span><br><span class="line">                array[p2] = temp</span><br><span class="line">        <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>

</div></div>
<ol>
<li>不考虑空间复杂度：分配两个数组，一个用来存放奇数，另一个存放偶数，扫描数组，若数字为奇数或偶数放入不同的数组中，最后合并数组。时间复杂度 $O(n)$， 空间复杂度 $O(n)$。 </li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array <span class="keyword">or</span> len(array)==<span class="number">1</span>: </span><br><span class="line">            <span class="keyword">return</span> array</span><br><span class="line">        odd = []</span><br><span class="line">        even = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                odd.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                even.append(i)</span><br><span class="line">        <span class="keyword">return</span> odd + even</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-22：链表中倒数第-k-个节点"><a href="#面试题-22：链表中倒数第-k-个节点" class="headerlink" title="面试题 22：链表中倒数第 $k$ 个节点"></a>面试题 22：链表中倒数第 $k$ 个节点</h5><p>输入一个链表，输出该链表中倒数第 $k$ 个节点。 从 1 开始计数，即链表的尾节点是倒数第 1 个节点。</p>
<ol>
<li>两遍链表遍历法：第一遍遍历链表获取链表的长度 $n$，通过 $n-k+1$ 计算出倒数第 $k$ 个节点的位置，第二次遍历找到倒数第 $k$ 个节点。</li>
<li>一遍链表遍历法（利用两个指针）：两个指针 $P_{1}$ 和 $P_{2}$，开始时 $P_{1}$ 先向前遍历，$P_{1}$ 向前从头节点开始向前走 $k-1$ 步，走到第 $k$ 个节点时， $P_{2}$ 开始向前遍历，两个指针同时向前遍历，等到  $P_{1}$ 走到链表尾部时， $P_{2}$ 所处的位置即为链表中倒数第 $k$ 个节点。<br>特殊情况： （1）输入头节点为空；（2）输入参数 $k$ 为 0【链表的尾节点是倒数第 1 个节点】；（3）输入以 $head$ 为头节点的链表的节点总数小于 $k$。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> head== <span class="literal">None</span> <span class="keyword">or</span> k == <span class="number">0</span>: <span class="comment"># 特殊情况（1）和（2）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        p1 = head</span><br><span class="line">        p2 = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> p1.next != <span class="literal">None</span>:  <span class="comment"># 特殊情况（3）</span></span><br><span class="line">                p1 = p1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        p2 = head</span><br><span class="line">        <span class="keyword">while</span> p1.next != <span class="literal">None</span>:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        <span class="keyword">return</span> p2</span><br></pre></td></tr></table></figure>

</div></div>
<p>相关题目：<br>求链表的中间节点（若链表中节点的总数为奇数，返回中间节点；若链表中的节点总数为偶数，则返回中间节点中的任意一个）：快慢指针（快指针一次走两步，慢指针一次走一步）。</p>
<h5 id="面试题-23：链表中环的入口节点"><a href="#面试题-23：链表中环的入口节点" class="headerlink" title="面试题 23：链表中环的入口节点"></a>面试题 23：链表中环的入口节点</h5><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 </p>
<ol>
<li>哈希表：遍历链表，若节点不在哈希表中，放入哈希表；若节点在哈希表中，则第一个已经存在于哈希表中的节点即为入环节点。若链表走到空，则链表无环。时间复杂度 $O(n)$， 空间复杂度 $O(n)$。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> pHead != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> pHead <span class="keyword">in</span> hashmap:</span><br><span class="line">                <span class="keyword">return</span> pHead</span><br><span class="line">            hashmap[pHead] = <span class="number">1</span></span><br><span class="line">            pHead = pHead.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

</div></div>
<ol>
<li>快慢指针：快指针一次走两步，慢指针一次走一步，若快指针走到空，则表明链表无环，若快慢指针相遇，则链表有环；快慢指针相遇后，慢指针保持原地，快指针返回链表头节点，此时快指针变为一次走一步，当两个指针再次相遇时，相遇节点为入环节点。（两指针相遇后，慢指针所处的位置刚好是从头节点开始的第 $n$ 个节点，其中 $n$ 是链表环中的节点个数，此时两个指针同时向前移动，快指针指向环入口时，慢指针已经绕环一圈了。）时间复杂度 $O(n)$，空间复杂度 $o(1)$。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span> <span class="keyword">or</span> pHead.next == <span class="literal">None</span>: <span class="comment"># 头节点为空，或链表中只有一个节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pFast = pHead</span><br><span class="line">        pSlow = pHead</span><br><span class="line">        <span class="keyword">while</span> pFast != <span class="literal">None</span> <span class="keyword">and</span> pFast.next != <span class="literal">None</span>:</span><br><span class="line">            pFast = pFast.next.next</span><br><span class="line">            pSlow = pSlow.next</span><br><span class="line">            <span class="keyword">if</span> pFast == pSlow:</span><br><span class="line">                pFast = pHead</span><br><span class="line">                <span class="keyword">while</span> pFast != pSlow:</span><br><span class="line">                    pSlow = pSlow.next</span><br><span class="line">                    pFast = pFast.next</span><br><span class="line">                <span class="keyword">return</span> pFast</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-24：反转链表"><a href="#面试题-24：反转链表" class="headerlink" title="面试题 24：反转链表"></a>面试题 24：反转链表</h5><p>输入一个链表，反转链表后，输出新链表的表头。<br>注意：反转后链表出现断裂（需要事前保存当前节点的前一个节点和后一个节点），并注意头节点的反转，即反转后原头节点为新链表的尾节点。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pHead.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        pre_node = <span class="literal">None</span></span><br><span class="line">        beh_node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead != <span class="literal">None</span>:</span><br><span class="line">            beh_node = pHead.next</span><br><span class="line">            pHead.next = pre_node</span><br><span class="line">            pre_node = pHead</span><br><span class="line">            pHead = beh_node</span><br><span class="line">        <span class="keyword">return</span> pre_node</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-25：合并两个排序的链表"><a href="#面试题-25：合并两个排序的链表" class="headerlink" title="面试题 25：合并两个排序的链表"></a>面试题 25：合并两个排序的链表</h5><p>输入两个递增排序的链表，合并两个链表，并使新链表中的节点仍然是递增排序的。注意：考虑输入的指针为空指针的情况。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br><span class="line">        <span class="keyword">if</span> pHead2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        merge = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pHead1.val &lt; pHead2.val:</span><br><span class="line">            merge = pHead1</span><br><span class="line">            merge.next = self.Merge(pHead1.next, pHead2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            merge = pHead2</span><br><span class="line">            merge.next = self.Merge(pHead1, pHead2.next)</span><br><span class="line">        <span class="keyword">return</span> merge</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-26：树的子结构"><a href="#面试题-26：树的子结构" class="headerlink" title="面试题 26：树的子结构"></a>面试题 26：树的子结构</h5><p>输入两棵二叉树A，B，判断B是不是A的子结构。（PS：约定空树不是任意一个树的子结构）<br>步骤：</p>
<ol>
<li>在树 A 中找到和树 B 的根节点的值一样的节点 R。</li>
<li>判断树 A 中以 R 为根节点的子树是不是包含和树 B 一样的结构。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> pRoot1 <span class="keyword">and</span> pRoot2:</span><br><span class="line">            <span class="keyword">if</span> pRoot1.val == pRoot2.val:</span><br><span class="line">                res = self.SubTreeCore(pRoot1, pRoot2)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">                res = self.HasSubtree(pRoot1.left, pRoot2)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">                res = self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SubTreeCore</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pRoot2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> pRoot1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> pRoot1.val != pRoot2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.SubTreeCore(pRoot1.left, pRoot2.left) <span class="keyword">and</span> self.SubTreeCore(pRoot1.right, pRoot2.right)</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-27：-二叉树的镜像"><a href="#面试题-27：-二叉树的镜像" class="headerlink" title="面试题 27： 二叉树的镜像"></a>面试题 27： 二叉树的镜像</h5><p>先前序遍历树的每个节点，若遍历到的节点有子节点，则交换其两个子节点。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        	<span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">        	<span class="keyword">return</span></span><br><span class="line">        temp = root.right</span><br><span class="line">        root.right = root.left</span><br><span class="line">        root.left = temp</span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">        	self.Mirror(root.left)</span><br><span class="line">        <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">        	self.Mirror(root.right)</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-28：对称的二叉树"><a href="#面试题-28：对称的二叉树" class="headerlink" title="面试题 28：对称的二叉树"></a>面试题 28：对称的二叉树</h5><p>判断一棵树是不是对称的。若二叉树和镜像完全一样，则是对称的。<br>针对前序遍历定义一种对称的遍历算法：先遍历父节点，再遍历它的右子节点，最后遍历左子节点。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.isSymmetricalCore(pRoot, pRoot)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetricalCore</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">    	<span class="keyword">if</span> pRoot1 == <span class="literal">None</span> <span class="keyword">and</span> pRoot2 == <span class="literal">None</span>:</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    	<span class="keyword">if</span> pRoot1 == <span class="literal">None</span> <span class="keyword">or</span> pRoot2 == <span class="literal">None</span>:</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    	<span class="keyword">if</span> pRoot1.val != pRoot2.val:</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    	<span class="keyword">return</span> self.isSymmetricalCore(pRoot1.left, pRoot2.right) <span class="keyword">and</span> self.isSymmetricalCore(pRoot1.right, pRoot2.left)</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-29：-顺时针打印矩阵"><a href="#面试题-29：-顺时针打印矩阵" class="headerlink" title="面试题 29： 顺时针打印矩阵"></a>面试题 29： 顺时针打印矩阵</h5><p>按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<ol>
<li>对于一个 rows <em> cols​ 的矩阵：循环继续的条件为 ​clos &gt; startX </em> 2 且 rows &gt; startY * 2​。</li>
<li>打印步骤：<ol>
<li>第一步：必不可少。</li>
<li>第二步：终止行号 &gt; 起始行号</li>
<li>第三步：终止行号 &gt; 起始行号 且 终止列号 &gt; 起始列号</li>
<li>第四步：终止行号 - 1 &gt; 起始行号 且 终止列号 &gt; 起始列号</li>
</ol>
</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> matrix == <span class="literal">None</span> <span class="keyword">or</span> len(matrix) &lt;= <span class="number">0</span> <span class="keyword">or</span> len(matrix[<span class="number">0</span>]) &lt;= <span class="number">0</span>:</span><br><span class="line">        	<span class="keyword">return</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        rows = len(matrix)</span><br><span class="line">        cols = len(matrix[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> (cols &gt; start * <span class="number">2</span> <span class="keyword">and</span> rows &gt; start * <span class="number">2</span>):</span><br><span class="line">        	self.printMatrixCore(matrix, rows, cols, start, res)</span><br><span class="line">        	start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrixCore</span><span class="params">(slef, matrix, rows, cols, start, res)</span>:</span></span><br><span class="line">    	endY = rows - <span class="number">1</span> - start</span><br><span class="line">    	endX = cols - <span class="number">1</span> - start</span><br><span class="line">    	<span class="keyword">for</span> i <span class="keyword">in</span> range(start, endX+<span class="number">1</span>):</span><br><span class="line">    		res.append(matrix[start][i])</span><br><span class="line">    	<span class="keyword">if</span> endY &gt; start:</span><br><span class="line">    		<span class="keyword">for</span> i <span class="keyword">in</span> range(start+<span class="number">1</span>, endY+<span class="number">1</span>):</span><br><span class="line">    			res.append(matrix[i][endX])</span><br><span class="line">    	<span class="keyword">if</span> endY &gt; start <span class="keyword">and</span> endX &gt; start:</span><br><span class="line">    		<span class="keyword">for</span> i <span class="keyword">in</span> range(endX<span class="number">-1</span>, start<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    			res.append(matrix[endY][i])</span><br><span class="line">    	<span class="keyword">if</span> endX &gt; start <span class="keyword">and</span> endY<span class="number">-1</span> &gt; start:</span><br><span class="line">    		<span class="keyword">for</span> i <span class="keyword">in</span> range(endY<span class="number">-1</span>, start, <span class="number">-1</span>):</span><br><span class="line">    			res.append(matrix[i][start])</span><br></pre></td></tr></table></figure>

</div></div>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> matrix == []:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        l, t, r, b = <span class="number">0</span>, <span class="number">0</span>, len(matrix[<span class="number">0</span>])<span class="number">-1</span>, len(matrix)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[t][i])</span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t &gt; b: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(t, b+<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][r])</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> r &lt; l: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(r, l<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[b][i])</span><br><span class="line">            b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> b &lt; t: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, t<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(matrix[i][l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div>
<p>还有另外一种及其简单的做法：旋转矩阵</p>
<h5 id="面试题-30：包含min函数的栈"><a href="#面试题-30：包含min函数的栈" class="headerlink" title="面试题 30：包含min函数的栈"></a>面试题 30：包含min函数的栈</h5><p>定义栈的数据结构，实现一个能够得到栈中所含最小元素的 min 函数（时间复杂度应为$O(1)$）。</p>
<ol>
<li>若每次压入新元素时，将栈里的所有元素排序，调整让最小的元素位于栈顶。不能保证最后压入栈的元素最先出栈，数据结构不是栈了。X</li>
<li>在栈中添加一个成员变量存放最小元素，当最小元素弹出后，就不知道下一个最小元素在哪儿了。因此，必须将次小元素保存。X</li>
<li>利用辅助数组，每次将最小元素放入辅助栈。√</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minstack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">        <span class="keyword">if</span> self.minstack == [] <span class="keyword">or</span> node &lt; self.min():</span><br><span class="line">            self.minstack.append(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.minstack.append(self.min())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.stack == [] <span class="keyword">or</span> self.minstack == []:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.minstack.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.minstack[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-31：栈的压入，弹出序列"><a href="#面试题-31：栈的压入，弹出序列" class="headerlink" title="面试题 31：栈的压入，弹出序列"></a>面试题 31：栈的压入，弹出序列</h5><p>输入两个整数序列，第一个序列表示栈的压入顺序，判断第二个序列是否为该栈的弹出顺序。<br>解决方式1：</p>
<ol>
<li>若下一个需要弹出的元素刚好是栈顶元素，则直接弹出。</li>
<li>若下一个需要弹出的元素不是栈顶元素，则将压栈序列中还没有压入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。</li>
<li>若所有数字都压入辅助栈仍没有找到下一个需弹出的数字，则序列不是一个弹出序列。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pushV == <span class="literal">None</span> <span class="keyword">or</span> popV == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> popV:</span><br><span class="line">            <span class="keyword">if</span> stack != [] <span class="keyword">and</span> stack[<span class="number">-1</span>] == i:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">elif</span> stack == [] <span class="keyword">or</span> stack[<span class="number">-1</span>] != i:</span><br><span class="line">                <span class="keyword">if</span> index &gt; len(pushV) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">while</span> index &lt; len(pushV) - <span class="number">1</span> <span class="keyword">and</span> pushV[index] != i:</span><br><span class="line">                        stack.append(pushV[index])</span><br><span class="line">                        index += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> pushV[index] == i:</span><br><span class="line">                        index += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

</div></div>
<p>解决方法2：</p>
<ol>
<li>将数据从pushV中压入stack的过程中，若压入数据与popV出栈的栈顶元素一样，就从pushv和popv中同时弹出，不压入stack。</li>
<li>等到pushV中元素全弹出来之后，判断stack中出栈元素和popV中出栈元素是否一致，当popV中元素全部弹出，说明是弹出序列。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> popV:</span><br><span class="line">            <span class="keyword">if</span> pushV <span class="keyword">and</span> pushV[<span class="number">0</span>] == popV[<span class="number">0</span>]:</span><br><span class="line">                pushV.pop(<span class="number">0</span>)</span><br><span class="line">                popV.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] == popV[<span class="number">0</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">                popV.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span> pushV:</span><br><span class="line">                stack.append(pushV.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-32-1-：不分行从上到下打印二叉树"><a href="#面试题-32-1-：不分行从上到下打印二叉树" class="headerlink" title="面试题 32.1 ：不分行从上到下打印二叉树"></a>面试题 32.1 ：不分行从上到下打印二叉树</h5><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。【广度优先遍历】<br>每次打印一个节点时，若节点有子节点，则将该节点的子节点放入队列的末尾，下面从队列的头部取出节点，重复前面的操作，直到队列中所有节点都打印完成。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        res_val = []</span><br><span class="line">        res.append(root)</span><br><span class="line">        <span class="keyword">while</span> res:</span><br><span class="line">            root = res.pop(<span class="number">0</span>)</span><br><span class="line">            res_val.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">                res.append(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">                res.append(root.right)</span><br><span class="line">        <span class="keyword">return</span> res_val</span><br></pre></td></tr></table></figure>

</div></div>
<font color="red">注意：广度优先遍历有向图或树均需用到队列。</font>

<h5 id="面试题-32-2-：分行从上到下打印二叉树"><a href="#面试题-32-2-：分行从上到下打印二叉树" class="headerlink" title="面试题 32.2 ：分行从上到下打印二叉树"></a>面试题 32.2 ：分行从上到下打印二叉树</h5><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。另需两个变量保存当前层节点和下一层节点。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pRoot == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        res_val = []</span><br><span class="line">        res.append(pRoot)</span><br><span class="line">        <span class="keyword">while</span> res:</span><br><span class="line">            curstack, nextstack = [], []</span><br><span class="line">            <span class="keyword">for</span> re <span class="keyword">in</span> res:</span><br><span class="line">                curstack.append(re.val)</span><br><span class="line">                <span class="keyword">if</span> re.left  != <span class="literal">None</span>:</span><br><span class="line">                    nextstack.append(re.left)</span><br><span class="line">                <span class="keyword">if</span> re.right != <span class="literal">None</span>:</span><br><span class="line">                    nextstack.append(re.right)</span><br><span class="line">            res_val.append(curstack)</span><br><span class="line">            res = nextstack</span><br><span class="line">        <span class="keyword">return</span> res_val</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题-32-3-：之字形打印二叉树"><a href="#面试题-32-3-：之字形打印二叉树" class="headerlink" title="面试题 32.3 ：之字形打印二叉树"></a>面试题 32.3 ：之字形打印二叉树</h5><p>第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<br>需要两个栈：</p>
<ol>
<li>若当前打印的是奇数层，则先保存左子节点再保存右子节点到第一个栈里。</li>
<li>若当前打印的是偶数层，则先保存右子节点再保存左子节点到第二个栈里。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pRoot == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        res_val = []</span><br><span class="line">        res.append(pRoot)</span><br><span class="line">        <span class="keyword">while</span> res:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            curstack, nextstack = [], []</span><br><span class="line">            <span class="keyword">if</span> index % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">while</span> res:</span><br><span class="line">                    root = res.pop()</span><br><span class="line">                    curstack.append(root.val)</span><br><span class="line">                    <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">                        nextstack.append(root.left)</span><br><span class="line">                    <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">                        nextstack.append(root.right)</span><br><span class="line">            <span class="keyword">elif</span> index % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">while</span> res:</span><br><span class="line">                    root  = res.pop()</span><br><span class="line">                    curstack.append(root.val)</span><br><span class="line">                    <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">                        nextstack.append(root.right)</span><br><span class="line">                    <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">                        nextstack.append(root.left)</span><br><span class="line">            res_val.append(curstack)</span><br><span class="line">            res = nextstack</span><br><span class="line">        <span class="keyword">return</span> res_val</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-33：二叉搜索树的后序遍历序列"><a href="#面试题-33：二叉搜索树的后序遍历序列" class="headerlink" title="面试题 33：二叉搜索树的后序遍历序列"></a>面试题 33：二叉搜索树的后序遍历序列</h5><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。【二叉搜索树：左子树节点的值均小于根节点的值，右子树节点的值均大于根节点的值。】<br>后序遍历，最后一个数字为树的根节点的值，数组中前面数字中小于此值的为左子树节点的值，大于此值的为右子树节点的值。递归。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> sequence == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        root = sequence.pop()</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sequence:</span><br><span class="line">            <span class="keyword">if</span> i &gt; root: <span class="keyword">break</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sequence[index:]:</span><br><span class="line">            <span class="keyword">if</span> i &lt; root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; <span class="number">0</span>:</span><br><span class="line">            left = self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line">        right = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; len(sequence)<span class="number">-1</span>:</span><br><span class="line">            right = self.VerifySquenceOfBST(sequence[index:])</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-34：二叉树中和为某一值的路径"><a href="#面试题-34：二叉树中和为某一值的路径" class="headerlink" title="面试题 34：二叉树中和为某一值的路径"></a>面试题 34：二叉树中和为某一值的路径</h5><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br>过程：</p>
<ol>
<li>用前序遍历方式访问到某节点，把该节点加入路径，并累加该节点的值；</li>
<li>若该节点为叶子节点，且路径中节点的值刚好 == 输入整数，打印；</li>
<li>若该节点不是叶子节点，则继续访问它的子节点；</li>
<li>当前节点访问结束后，递归回到其父节点。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.path = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        self.recur(root, sum)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(self, root, tar)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.path.append(root.val)</span><br><span class="line">        tar -= root.val</span><br><span class="line">        lead_node = (root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> tar == <span class="number">0</span> <span class="keyword">and</span> lead_node:</span><br><span class="line">            self.res.append(list(self.path))</span><br><span class="line">        self.recur(root.left, tar)</span><br><span class="line">        self.recur(root.right, tar)</span><br><span class="line">        self.path.pop()</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-35：复杂链表的复制"><a href="#面试题-35：复杂链表的复制" class="headerlink" title="面试题 35：复杂链表的复制"></a>面试题 35：复杂链表的复制</h5><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点或空），返回结果为复制后复杂链表的 head。<br>以空间换取时间的解法：准备大小为 $O(n)$ 的哈希表，时间复杂度$O(n)$实现</p>
<ol>
<li>复制原始链表上的每一个节点N创建N‘，将创建出来的节点用next指针链接起来，同时将&lt;N,N’&gt;的配对信息保存在哈希表中。</li>
<li>复制链表上的每个节点的random指针，利用哈希表可以在$O(1)$的时间找到random指针指向的节点。<br>不使用哈希表，额外空间复杂度$O(1)$，时间复杂度$O(n)$实现：</li>
<li>复制原始链表上的每一个节点N创建N‘，把N’节点放在N节点之后，将创建出来的节点用next指针链接起来。</li>
<li>复制链表上的每个节点的random指针，N‘节点的random指针指向N节点的random节点的next节点。</li>
<li>将长链表拆分成两个链表：把奇数位置的节点用next指针相连，成为原始链表，偶数位置的节点用next指针相连成为复制的链表。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        self.random = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.CloneNextNode(pHead)</span><br><span class="line">        self.CloneRandomNode(pHead)</span><br><span class="line">        <span class="keyword">return</span> self.ReconnectNode(pHead)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CloneNextNode</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        pNode = pHead</span><br><span class="line">        <span class="keyword">while</span> pNode != <span class="literal">None</span>:</span><br><span class="line">            pClone = RandomListNode(<span class="literal">None</span>)</span><br><span class="line">            pClone.label = pNode.label</span><br><span class="line">            pClone.next = pNode.next</span><br><span class="line">            pNode.next = pClone</span><br><span class="line">            pNode = pClone.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CloneRandomNode</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        pNode = pHead</span><br><span class="line">        <span class="keyword">while</span> pNode != <span class="literal">None</span>:</span><br><span class="line">            pClone = pNode.next</span><br><span class="line">            <span class="keyword">if</span> pNode.random != <span class="literal">None</span>:</span><br><span class="line">                pClone.random = pNode.random.next</span><br><span class="line">            pNode = pClone.next </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReconnectNode</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        pNode = pHead</span><br><span class="line">        pCloneNode = <span class="literal">None</span></span><br><span class="line">        pCloneHead = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pNode != <span class="literal">None</span>:</span><br><span class="line">            pCloneHead = pCloneNode = pNode.next</span><br><span class="line">            pNode.next = pCloneNode.next</span><br><span class="line">            pNode = pNode.next</span><br><span class="line">        <span class="keyword">while</span> pNode != <span class="literal">None</span>:</span><br><span class="line">            pCloneNode.next = pNode.next</span><br><span class="line">            pCloneNode = pCloneNode.next</span><br><span class="line">            pNode.next = pCloneNode.next</span><br><span class="line">            pNode = pNode.next</span><br><span class="line">        <span class="keyword">return</span> pCloneHead</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印复杂链表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Print_ComplicatedList</span><span class="params">(head)</span>:</span></span><br><span class="line">    next_node = head</span><br><span class="line">    <span class="keyword">while</span> next_node != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> next_node.random != <span class="literal">None</span>:</span><br><span class="line">            print(next_node.label,end=<span class="string">''</span>)</span><br><span class="line">            print(<span class="string">'('</span>,end=<span class="string">''</span>)</span><br><span class="line">            print(next_node.random.label, end=<span class="string">''</span>)</span><br><span class="line">            print(<span class="string">')'</span>,end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(next_node.label, end=<span class="string">''</span>)</span><br><span class="line">        next_node = next_node.next</span><br><span class="line">        <span class="keyword">if</span> next_node != <span class="literal">None</span>:</span><br><span class="line">            print( <span class="string">'——&gt;'</span>, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-36：二叉搜素树与双向链表（-）"><a href="#面试题-36：二叉搜素树与双向链表（-）" class="headerlink" title="面试题 36：二叉搜素树与双向链表（**）"></a>面试题 36：二叉搜素树与双向链表（**）</h5><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br>原先指向左子节点的指针调整为链表中指向前一个节点的指针，原先指向右子节点的指针调整为链表中指向后一个节点的指针。中序遍历树中的每一个节点（中序遍历将按照从小到大的顺序遍历二叉搜索树），遍历根节点时，根节点指向的前一个结点是根节点左子树的最大值，指向的后一个节点是根节点右子树的最小值。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pLastNodeInList = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pRootOfTree ==  <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.Core(pRootOfTree, self.pLastNodeInList)</span><br><span class="line">        pHead = self.pLastNodeInList</span><br><span class="line">        <span class="keyword">while</span> pHead != <span class="literal">None</span> <span class="keyword">and</span> pHead.left != <span class="literal">None</span>:</span><br><span class="line">            pHead = pHead.left</span><br><span class="line">        <span class="keyword">return</span> pHead</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Core</span><span class="params">(self, root, pLastNodeInList)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pCurrent = root</span><br><span class="line">        <span class="keyword">if</span> pCurrent.left != <span class="literal">None</span>:</span><br><span class="line">            self.Core(pCurrent.left, self.pLastNodeInList)</span><br><span class="line">        pCurrent.left = self.pLastNodeInList</span><br><span class="line">        <span class="keyword">if</span> self.pLastNodeInList != <span class="literal">None</span>:</span><br><span class="line">            self.pLastNodeInList.right = pCurrent</span><br><span class="line">        self.pLastNodeInList = pCurrent</span><br><span class="line">        <span class="keyword">if</span> pCurrent != <span class="literal">None</span>:</span><br><span class="line">            self.Core(pCurrent.right, self.pLastNodeInList)</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-37：序列化二叉树"><a href="#面试题-37：序列化二叉树" class="headerlink" title="面试题 37：序列化二叉树"></a>面试题 37：序列化二叉树</h5><p>序列化和反序列化二叉树<br>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。<br>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果，重构二叉树。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    flag = <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'#!'</span></span><br><span class="line">        <span class="keyword">return</span> str(root.val) + <span class="string">'!'</span> + self.Serialize(root.left) + self.Serialize(root.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.flag += <span class="number">1</span></span><br><span class="line">        lis = s.split(<span class="string">'!'</span>)</span><br><span class="line">        <span class="keyword">if</span> self.flag &gt;= len(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> lis[self.flag] != <span class="string">'#'</span>:</span><br><span class="line">            root = TreeNode(int(lis[self.flag]))</span><br><span class="line">            root.left = self.Deserialize(s)</span><br><span class="line">            root.right = self.Deserialize(s)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-38：字符串的排序（-）"><a href="#面试题-38：字符串的排序（-）" class="headerlink" title="面试题 38：字符串的排序（*）"></a>面试题 38：字符串的排序（*）</h5><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc，acb，bac，bca，cab和cba。 </p>
<ol>
<li>把字符串分成两部分：一部分是字符串的第一个字符，另一部分是第一个字符以后的所有字符</li>
<li>拿第一个字符和它后面的字符逐个交换</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> ss == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        charList = list(ss)</span><br><span class="line">        charList.sort()</span><br><span class="line">        <span class="keyword">return</span> self.Permuta(charList)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permuta</span><span class="params">(self, charList)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(charList) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> charList</span><br><span class="line">        pStr = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(charList)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> charList[i] == charList[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            temp = self.Permuta(charList[:i]+charList[i+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> temp:</span><br><span class="line">                pStr.append(charList[i]+j)</span><br><span class="line">        <span class="keyword">return</span> pStr</span><br></pre></td></tr></table></figure>

</div></div>
<p>扩展题：<br>字符串的所有组合：交换字符串中的两个字符时，得到两种不同的排序，但却是同一种组合。例如输入三个字符a，b，c它们的组合有a、b、c、ab、ac、bc、abc。<br>输入 n 个字符，这  n 个字符能构成长度为1， 2， 3，…，n的组合。求n个字符组成长度为m的组合时：1. 求n-1个字符中长度为m-1的组合（组合中包含第一个字符），2. 求n-1个字符中长度为m的组合（组合中不包含第一个字符）</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 代码功能不全，无法实现当字符串中含有重复字符的时候</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pStr = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Combination</span><span class="params">(self, ss)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> ss == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        charList = list(ss)</span><br><span class="line">        charList.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(charList)+<span class="number">1</span>):</span><br><span class="line">            self.pStr.append(self.combin(charList, <span class="number">0</span>, i))</span><br><span class="line">        <span class="keyword">return</span> self.pStr</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combin</span><span class="params">(self, charList, begin, length)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span> <span class="keyword">or</span> len(charList) - begin &lt; length:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(charList, begin, length)</span><br><span class="line">        out = []</span><br><span class="line">        out.append(charList[begin])</span><br><span class="line">        print(out)</span><br><span class="line">        temp = self.combin(charList, begin+<span class="number">1</span>, length<span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">if</span> temp != <span class="literal">None</span>:</span><br><span class="line">            out.pop()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> temp:</span><br><span class="line">                out.append(charList[begin] + j)</span><br><span class="line">        temp2 = self.combin(charList, begin+<span class="number">1</span>, length)</span><br><span class="line">        <span class="keyword">if</span> temp2 != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> temp2:</span><br><span class="line">                out.append(j)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>

</div></div>
<p>相关题目：</p>
<ol>
<li>输入一个含有8个数字的数组，判断有没有可能把这8个数字分别放在正方体的8个顶点上，使得正方体上三组相对的面上的4个顶点的和都相等。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补充代码</span></span><br></pre></td></tr></table></figure>

</div></div>
<ol>
<li>在$8<em>8$的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一对角线上。共有多少种符合条件的摆法。<br>扩展提：【N皇后问题】在N</em>N的国际象棋上摆放N个皇后。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补充代码</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-39：数组中出现次数超过一半的数字"><a href="#面试题-39：数组中出现次数超过一半的数字" class="headerlink" title="面试题 39：数组中出现次数超过一半的数字"></a>面试题 39：数组中出现次数超过一半的数字</h5><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组$\{1,2,3,2,2,2,5,4,2\}$。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br>解题方法：</p>
<ol>
<li>基于$Partition$函数的时间复杂度为$O(N)$：<br>数组特性：数组中有一个数字出现的次数超过了数组长度的一半，即将数组排序后，位于数组中间的数字一定就是出现次数超过数组长度一半的数字。此数字为统计学上的中位数，即长度为 $n$ 的数组中第 $n/2$ 大的数字。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补充代码</span></span><br></pre></td></tr></table></figure>

</div></div>
<ol>
<li>基于数组特点的时间复杂度为$O(N)$:<br>数组中一个数字出现的次数超过数组长度的一半，即它出现的次数比其他所有数字出现的次数的和还要多。因此可以在遍历数组的时候保存两个值：一是数组中的一个数字，另一个是次数。1. 若遍历到的下一个数字和之前保存的数字相同，次数 $+1$；2. 若不同，次数 $-1$，如果次数减为0，则保存遍历到的下一个数字，并将次数设为1。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode—LeetCode补充</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        num = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            count += <span class="number">1</span> <span class="keyword">if</span> i == num <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> count &lt;= <span class="number">0</span>:</span><br><span class="line">                num = i</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>

</div></div>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.CheckInvalidArray(numbers):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        result = numbers[<span class="number">0</span>]</span><br><span class="line">        time = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers[<span class="number">0</span>:]:</span><br><span class="line">            <span class="keyword">if</span> time == <span class="number">0</span>:</span><br><span class="line">                result = i</span><br><span class="line">                time = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> result == i:</span><br><span class="line">                time += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                time -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.CheckMoreThanHalf(numbers, result):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CheckInvalidArray</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        isInputInvalid = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> numbers == <span class="literal">None</span> <span class="keyword">or</span> len(numbers) == <span class="number">0</span>:</span><br><span class="line">            isInputInvalid = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> isInputInvalid</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CheckMoreThanHalf</span><span class="params">(self, numbers, result)</span>:</span></span><br><span class="line">        time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> i == result:</span><br><span class="line">                time += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> time * <span class="number">2</span> &lt;= len(numbers):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">print(Solution().MoreThanHalfNum_Solution(numbers))</span><br><span class="line">print(Solution().MoreThanHalfNum_Solution(<span class="literal">None</span>))</span><br><span class="line">print(Solution().MoreThanHalfNum_Solution([]))</span><br><span class="line">print(Solution().MoreThanHalfNum_Solution([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]))</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-40：最小的k个数"><a href="#面试题-40：最小的k个数" class="headerlink" title="面试题 40：最小的k个数"></a>面试题 40：最小的k个数</h5><p>输入 $n$ 个整数，找出其中最小的 $K$ 个数。例如输入 $4,5,1,6,2,7,3,8$ 这 $8$ 个数字，则最小的 $4$ 个数字是 $1,2,3,4$。<br>时间复杂度为 $O(N \log N)$ 的解法：把输入的 $n$ 个整数排序，排序后位与最前面的 $k$ 个数就是最小的 $k$ 个数。<br>时间复杂度为 $O(N)$ 的解法：可以修改输入数组时，【基于 $Partition$ 函数】基于数组的第 $k$ 个数字调整，，使得比第 $k$ 个数字小的所有数字都位于数组的左边。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补充代码</span></span><br></pre></td></tr></table></figure>

</div></div>
<p>&emsp;&emsp;时间复杂度 $O(N log k)$ 的解法：不可以修改输入数组时，特别适合处理海量数据，创建一个大小为 $k$ 的容器存储最小的 $k$ 个数字，读取输入的 $n$ 个数：【容器中不足 $k$ 个数】，直接将读入的数放入容器中；【容器中满 $k$ 个数】，获得容器中 $k$ 个数字的最大值，若读入的数字 &gt; 最大值，直接舍弃；若读入的数字 &lt; 最大值，用读入的数字替换容器中的最大值。<br>&emsp;&emsp;容器满了之后可能会执行的三个操作 【1】在 $k$ 个整数中找到最大数；【2】有可能在这个容器中删除最大值；【3】有可能要插入一个新的数字。可能用最大堆实现这个容器，在 $O(1)$ 时间内得到已有的 $k$ 个数字中的最大值，$O(\log k)$ 时间内完成删除和插入操作。也可以使用红黑树实现容器，$O(\log k)$ 时间内完成查找、删除和插入操作。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.val &gt; other.val</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(tinput) &lt; k <span class="keyword">or</span> k &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        heapq_num = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tinput:</span><br><span class="line">            <span class="keyword">if</span> len(heapq_num) &lt; k:</span><br><span class="line">                heapq.heappush(heapq_num, MyObject(i))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq_num_max = heapq_num[<span class="number">0</span>].val</span><br><span class="line">                <span class="keyword">if</span> i &lt; heapq_num_max:</span><br><span class="line">                    heapq.heapreplace(heapq_num, MyObject(i))</span><br><span class="line">        <span class="keyword">return</span> [i.val <span class="keyword">for</span> i <span class="keyword">in</span> heapq.nlargest(k, heapq_num)]</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-41：数据流中的中位数"><a href="#面试题-41：数据流中的中位数" class="headerlink" title="面试题 41：数据流中的中位数"></a>面试题 41：数据流中的中位数</h5><p>如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。使用 $Insert()$ 方法读取数据流，使用 $GetMedian()$ 方法获取当前读取数据的中位数。 </p>
<p>使用数据容器，保存从流中读取到的数据。数据容器的类型有：数组、排序的链表、二叉搜索树、平衡二叉搜素数、大根堆和小根堆</p>
<p>数组：如果数组没有排序，可以利用 $Partition$ 函数找到数据中的中位数【插入新数据和找到中位数的时间复杂度分别为 $O(1)和O(N)$】；如果在插入新数据时让数组保持排序，则【插入新数据和找到中位数的时间复杂度分别为 $O(N)和O(1)$】。</p>
<p>排序的链表：【插入新数据和找到中位数的时间复杂度分别为 $O(N)和O(1)$】，定义两个指针指向链表中间的节点。</p>
<p>二叉搜索树：在二叉树节点中添加一个表示子树节点数据的字段，【插入新数据和找到中位数的平均时间复杂度为 $O(\log N)$】，当最差情况时，二叉搜索树极度不平衡，时间复杂度仍为 $O(N)$。</p>
<p>$AVL$ 数—平衡二叉搜素树：修改 $AVL$ 的平衡因子为左、右子树节点数目之差，【插入新节点的时间复杂度为 $O(\log N)$，获得所有节点的中位数的时间复杂度为 $O(1)$】，没有现成的函数库，实现难度大。</p>
<p>大根堆和小根堆：用大根堆实现左边的数据容器，小根堆实现右边的数据容器，当数据量为奇数时，中位数是大根堆的最大值，若数据量为偶数时，中位数是大根堆的最大值和小根堆最小值的平均值，【插入新节点的时间复杂度为 $O(\log N)$，获得所有节点的中位数的时间复杂度为 $O(1)$】。要保证数据平均分配到两个堆中，因此两个堆中数据的数目只差不能超过1，可在数据总数目是偶数时把新数据插入小根堆，否则插入大根堆，同时还要保证大根堆中所有数据都小于小根堆的数据，当数据为偶数时，若要插入小根堆中数据比大根堆中的数据小时，先将数据插入大根堆，再将大根堆中的最大值弹出，插入小根堆，反之做法类似。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.val &gt; other.val</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.min_heap = []</span><br><span class="line">        self.max_heap = []</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.count % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> len(self.min_heap) &gt; <span class="number">0</span> <span class="keyword">and</span> self.min_heap[<span class="number">0</span>] &lt; num:</span><br><span class="line">                value = heapq.heapreplace(self.min_heap, num)</span><br><span class="line">                heapq.heappush(self.max_heap, MaxHeap(value))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(self.max_heap, MaxHeap(num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(self.max_heap) &gt; <span class="number">0</span> <span class="keyword">and</span> self.max_heap[<span class="number">0</span>].val &gt; num:</span><br><span class="line">                value = heapq.heapreplace(self.max_heap, MaxHeap(num)).val</span><br><span class="line">                heapq.heappush(self.min_heap, value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(self.min_heap, num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span><span class="params">(self, x = None)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.count % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.max_heap[<span class="number">0</span>].val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            middle = (self.max_heap[<span class="number">0</span>].val + self.min_heap[<span class="number">0</span>]) / <span class="number">2.0</span></span><br><span class="line">            <span class="keyword">return</span> middle</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-42：连续子数组的最大和"><a href="#面试题-42：连续子数组的最大和" class="headerlink" title="面试题 42：连续子数组的最大和"></a>面试题 42：连续子数组的最大和</h5><p>数组中包含正数和负数，求所有子数组的和的最大值。<br>时间复杂度为 $O(N)$ 的解法：</p>
<ol>
<li><p>举例分析数组的规律：<br>如果arr中没有正数，产生的最大累加和一定是数组中的最大值。 如果arr中有正数，从左到右遍历数组，用变量 $cur$ 记录每一步的累加和。当 $cur<0$ 时，此时令 $cur="0$" ，表示重新从下一个数开始累加。当>=0$ 时，每一次累加都可能是最大的累加和，所以用变量 $max$ 全程记录 $cur$ 出现的最大值即可。</0$></p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> array == <span class="literal">None</span> <span class="keyword">or</span> len(array) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cur = array[<span class="number">0</span>]</span><br><span class="line">        max_val = cur</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> cur &lt; <span class="number">0</span>:</span><br><span class="line">                cur = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur += i</span><br><span class="line">            <span class="keyword">if</span> cur &gt; max_val:</span><br><span class="line">                max_val = cur</span><br><span class="line">        <span class="keyword">return</span> max_val</span><br></pre></td></tr></table></figure>

</div></div>
</li>
<li><p>应用动态规划：<br>用函数 $dp[i]$ 表示以第 $i$ 个数字结尾的子数组的最大和，需要求出 $max[dp[i]$。递归公式：</p>
<script type="math/tex; mode=display">
dp[i] = \begin{cases} nums[i], &i=0或者dp[i-1] \le 0\\ dp[i-1]+nums[i] , &i \not=0并且dp[i-1] \gt0\end{cases}</script></li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            nums[i] += max(<span class="number">0</span>, nums[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> max(nums)</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-43：1-n-整数中-1-出现的次数"><a href="#面试题-43：1-n-整数中-1-出现的次数" class="headerlink" title="面试题 43：1 ~ n  整数中 1 出现的次数"></a>面试题 43：1 ~ n  整数中 1 出现的次数</h5><p>求出 $[1,n]$ 整数的十进制表示中1出现的次数。例如1~13中包含1的数字有1、10、11、12、13，因此共出现6次。</p>
<p>从数字规律着手： 若 $n=21345$，先把 $1 \sim 21345$ 的所有数字分成两段 $1 \sim 1345$ 和 $1326  \sim 21345$。</p>
<p>先求 $1326  \sim 21345$ 范围上 1 出现的次数。【1出现在最高位】：1 出现在 $10000 \sim 19999$ 这10000个数字的万位上，共 $10^4$，（如果万位的数字位1，例如求 $n=12345$中 $2346 \sim 12345$ 范围上万位出现 1 的次数，只有 $10000 \sim 12345$ 范围）；【1出现在除最高位之外的其他位中】：最高位（万位）一共有2个选择，其他四位选择其中一位是 1，其他三位可以是 $0 \sim 9$ 这 10 个数字中任意选择。因此 $1326  \sim 21345$ 范围中后 4 位中 1 出现的次数位 $2 <em> 4</em>10^3=80000$。</p>
<p>再利用递归的方式求 $1 \sim 1345$ 范围中 1 出现的次数。一个数字 n 有 $O(\log n)$位，时间复杂度位 $O(\log n)$。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n &lt;=<span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        num_str = str(n)</span><br><span class="line">        oth_length = len(num_str) - <span class="number">1</span></span><br><span class="line">        numFirstDigit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> int(num_str[<span class="number">0</span>]) &gt; <span class="number">1</span>:</span><br><span class="line">            numFirstDigit = math.pow(<span class="number">10</span>, oth_length)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            numFirstDigit = int(num_str[<span class="number">1</span>:]) + <span class="number">1</span></span><br><span class="line">        numOtherDigit = int(num_str[<span class="number">0</span>]) * oth_length * math.pow(<span class="number">10</span>, oth_length <span class="number">-1</span>)</span><br><span class="line">        numRecursive = self.NumberOf1Between1AndN_Solution(int(num_str[<span class="number">1</span>:]))</span><br><span class="line">        <span class="keyword">return</span> numFirstDigit + numOtherDigit + numRecursive</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-44：数字序列中某一位的数字"><a href="#面试题-44：数字序列中某一位的数字" class="headerlink" title="面试题 44：数字序列中某一位的数字"></a>面试题 44：数字序列中某一位的数字</h5><p>数字以 $0123456789101112131415 \ldots $ 的格式序列化到一个字符序列中，在这个序列中第 5 位是 5， 第13位是 1。</p>
<p>从数字规律着手：（跳过若干数字，加速过程）例如序列中的第 1001 位，序列的前10位是 $0 \sim 9$ 这10个只有一位的数字，$1001 \gt 10$ 因此这10个数字可以直接跳过。继续从后面紧跟着的序列中找 $10001-10=991$ 位的数字；从 $10 \sim 99$ 这90个两位数共占位 $90 <em>2=180$，$991 \gt 180$，跳过这90个两位数，继续从后面紧跟着的序列中找 $991-180=881$位的数字；从 $100 \sim 999$ 这900个三位数共占位 $3</em>900=2700$，$881 \lt 2700$，因此第 881 位是一个三位数，由于 $881=270 * 3+1$，所以第881位的数字为从100往后270个数字即370的第二位数字。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DigitAtIndex</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> num &gt;= <span class="number">0</span> <span class="keyword">and</span> num &lt;= <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        digit = <span class="number">1</span></span><br><span class="line">        num -= <span class="number">10</span></span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            digit += <span class="number">1</span></span><br><span class="line">            count = <span class="number">9</span> * math.pow(<span class="number">10</span>, digit<span class="number">-1</span>) * digit</span><br><span class="line">            origin = num</span><br><span class="line">            num = num - count</span><br><span class="line">        number = int(origin / digit)</span><br><span class="line">        index = int(origin % digit)</span><br><span class="line">        val = number + math.pow(<span class="number">10</span>, digit<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> int(str(val)[index])</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-45：把数组排成最小的数（-）"><a href="#面试题-45：把数组排成最小的数（-）" class="headerlink" title="面试题 45：把数组排成最小的数（**）"></a>面试题 45：把数组排成最小的数（**）</h5><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 </p>
<p>重新定义比较规则：两个数字 $m$ 和 $n$ 能拼接成数字 $mn$ 和 $nm$，若 $mn \lt nm$，则定义为 $m$ 小于 $n$；若$mn \gt nm$，则定义为 $m$ 大于 $n$；若 $mn = nm$，则定义为 $m$ 等于 $n$；将给出的所有数字按照如上规则进行从小到大排序，并将排序好的数字依次打印出来即可。</p>
<p>潜在问题【大数问题】： $m$ 和 $n$ 都在 $int$ 型能表达的范围，但拼接出来的数字 $mn$ 和 $nm$ 用 $int$ 型表示可能会溢出。可以把数字转换成字符串来处理，同时可利用字符串大小的比较规则进行比较。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># python2的解法代码：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        string = [str(num) <span class="keyword">for</span> num <span class="keyword">in</span> numbers]</span><br><span class="line">        string.sort(self.theMax,reverse=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(string)</span><br><span class="line">           </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">theMax</span><span class="params">(self,str1,str2)</span>:</span></span><br><span class="line">        str1str2 = str1+str2</span><br><span class="line">        str2str1 = str2+str1</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> str1str2 &gt; str2str1 <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

</div></div>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># # python3的解法代码：</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmp</span><span class="params">(self,a,b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> a+b&gt;b+a:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> a+b&lt;b+a:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self,numbers)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        number = list(map(str,numbers))</span><br><span class="line">        number.sort(key=cmp_to_key(self.cmp))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(number).lstrip(<span class="string">'0'</span>) <span class="keyword">or</span> <span class="string">'0'</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-46：把数字翻译成字符串-amp-amp-LeetCode-91-解码方法"><a href="#面试题-46：把数字翻译成字符串-amp-amp-LeetCode-91-解码方法" class="headerlink" title="面试题 46：把数字翻译成字符串 &amp;&amp; LeetCode  91. 解码方法"></a>面试题 46：把数字翻译成字符串 &amp;&amp; LeetCode  91. 解码方法</h5><p>LeetCode: <a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法</a><br>给定一个数字，按照如下规则翻译成字符串：0翻译成“a”，1翻译成“b”，…，25翻译成“z”。一个数字有多种翻译可能，例如12258一共有5种，分别是 $bccfi，bwfi，bczi，mcfi，mzi$。</p>
<p>递归方法：定义函数 $f(i)$表示从第 $i$ 位数字开始的不同翻译的数目，那么 $f(i) = f(i+1)+g(i, i+1)*f(i+1)$，其中 当第 $i$ 位和 $i+1$ 位两位数字拼接起来的数字在10~25的范围内时，$g(i, i+1)=1$。递归的解法存在重复的子问题（自上而下的解法），不是最佳解。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetTranslationCount</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num_str = str(number)</span><br><span class="line">        <span class="keyword">return</span> self.GetTranslationCountCore(num_str, <span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetTranslationCountCore</span><span class="params">(self, num_str, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(num_str) == i:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i + <span class="number">1</span> &lt; len(num_str) <span class="keyword">and</span> num_str[i] != <span class="string">'0'</span> <span class="keyword">and</span> int(num_str[i:i+<span class="number">2</span>]) &lt;= <span class="number">25</span>:</span><br><span class="line">            <span class="keyword">return</span> self.GetTranslationCountCore(num_str, i+<span class="number">1</span>) + self.GetTranslationCountCore(num_str, i+<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> self.GetTranslationCountCore(num_str, i+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

</div></div>
<p>动态规划：（自下而上）根据递归方式写动态规划表</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetTranslationCount</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num_str = str(number)</span><br><span class="line">        length = len(num_str)</span><br><span class="line">        dp = [<span class="number">0</span>] * (length + <span class="number">1</span>)</span><br><span class="line">        dp[length] = <span class="number">1</span></span><br><span class="line">        dp[length - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[i] = dp[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> num_str[i] != <span class="string">'0'</span> <span class="keyword">and</span> int(num_str[i:i+<span class="number">2</span>]) &lt;= <span class="number">25</span>:</span><br><span class="line">                dp[i] += dp[i+<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

</div></div>
<p>动态规划表的空间压缩写法：</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetTranslationCount</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> number &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num_str = str(number)</span><br><span class="line">        length = len(num_str)</span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        next = <span class="number">1</span></span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            tmp = cur</span><br><span class="line">            <span class="keyword">if</span> num_str[i] != <span class="string">'0'</span> <span class="keyword">and</span> int(num_str[i:i+<span class="number">2</span>]) &lt;= <span class="number">25</span>:</span><br><span class="line">                cur += next</span><br><span class="line">            next = tmp</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-47：礼物的最大价值-amp-amp-LeetCode-64-最小路径和"><a href="#面试题-47：礼物的最大价值-amp-amp-LeetCode-64-最小路径和" class="headerlink" title="面试题 47：礼物的最大价值 &amp;&amp; LeetCode  64. 最小路径和"></a>面试题 47：礼物的最大价值 &amp;&amp; LeetCode  64. 最小路径和</h5><p>LeetCode: <a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a><br>在一个 $m*n$ 的棋盘中的每一个格都放一个礼物，每个礼物都有一定的价值（价值大于0）.你可以从棋盘的左上角开始拿各种里的礼物，并每次向右或者向下移动一格，直到到达棋盘的右下角。给定一个棋盘及上面个的礼物，请计算你最多能拿走多少价值的礼物？ </p>
<p>递归解法：定义函数 $f(i, j)$ 表示到达坐标为 $(i, j)$的格子时能拿到的礼物的最大值，所以$f(i, j)=max(f(i-1, j),f(i, j-1))+gift[i, j]$，其中 $gift[i, j]$ 表示坐标为 $(i, j)$ 的格子里礼物的价值。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxValue</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> array == <span class="literal">None</span> <span class="keyword">or</span> len(array) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        rows = len(array)</span><br><span class="line">        cols = len(array[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> self.getMaxValue_Core(array, rows, cols, rows<span class="number">-1</span>, cols<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxValue_Core</span><span class="params">(self, array, rows, cols, row, col)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> row &lt; <span class="number">0</span> <span class="keyword">or</span> row &gt; rows - <span class="number">1</span> <span class="keyword">or</span> col &lt; <span class="number">0</span> <span class="keyword">or</span> col &gt; cols - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = array[row][col]</span><br><span class="line">        <span class="keyword">if</span> row &lt; rows <span class="keyword">and</span> col &lt; cols:</span><br><span class="line">            res += max(self.getMaxValue_Core(array, rows, cols, row<span class="number">-1</span>, col),</span><br><span class="line">                       self.getMaxValue_Core(array, rows, cols, row, col<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div>
<p>利用递归解法修改的动态规划方法：</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxValue</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> array == <span class="literal">None</span> <span class="keyword">or</span> len(array) == <span class="number">0</span> <span class="keyword">or</span> array[<span class="number">0</span>] == <span class="literal">None</span> <span class="keyword">or</span> len(array[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        rows = len(array)</span><br><span class="line">        cols = len(array[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(cols)] <span class="keyword">for</span> i <span class="keyword">in</span> range(rows)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = array[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, rows):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + array[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, cols):</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-1</span>] + array[<span class="number">0</span>][i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, cols):</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + array[i][j]</span><br><span class="line">        print(dp)</span><br><span class="line">        <span class="keyword">return</span> dp[rows<span class="number">-1</span>][cols<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

</div></div>
<p>对动态规划表进行进一步空间压缩：</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxValue</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> array == <span class="literal">None</span> <span class="keyword">or</span> len(array) == <span class="number">0</span> <span class="keyword">or</span> array[<span class="number">0</span>] == <span class="literal">None</span> <span class="keyword">or</span> len(array[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        rows = len(array)</span><br><span class="line">        cols = len(array[<span class="number">0</span>])</span><br><span class="line">        more = max(rows, cols)  <span class="comment"># 行数和列数较大的是more</span></span><br><span class="line">        less = min(rows, cols)  <span class="comment"># 行数和列数较小的是less</span></span><br><span class="line">        rowmore = (more == rows)  <span class="comment"># 行数是不是大于或者等于列数，始终用最小的空间生成动态规划表</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(less)]</span><br><span class="line">        dp[<span class="number">0</span>] = array[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, less):</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + (array[<span class="number">0</span>][i] <span class="keyword">if</span> rowmore <span class="keyword">else</span> array[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, more):</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">0</span>] + (array[i][<span class="number">0</span>] <span class="keyword">if</span> rowmore <span class="keyword">else</span> array[<span class="number">0</span>][i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, less):</span><br><span class="line">                dp[j] = max(dp[j<span class="number">-1</span>], dp[j]) + (array[i][j] <span class="keyword">if</span> rowmore <span class="keyword">else</span> array[j][i])</span><br><span class="line">        <span class="keyword">return</span> dp[less - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-48：最长不含重复字符的子字符串-amp-amp-LeetCode-3-无重复字符串的最长字串"><a href="#面试题-48：最长不含重复字符的子字符串-amp-amp-LeetCode-3-无重复字符串的最长字串" class="headerlink" title="面试题 48：最长不含重复字符的子字符串 &amp;&amp; LeetCode 3. 无重复字符串的最长字串"></a>面试题 48：最长不含重复字符的子字符串 &amp;&amp; LeetCode 3. 无重复字符串的最长字串</h5><p>LeetCode：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a><br>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含 ’a’~’z’ 的字符。例如，在字符串 $”arabcacfr”$ 中，最长的不含重复字符的子字符串就是 $”acfr”$，长度为4。 </p>
<p>暴力递归的时间复杂度为 $O(N^3)$，长度为 $n$ 的字符串包含 $O(N^2)$ 个子字符串，判断一个子字符串中是否包含重复的字符的时间复杂度为 $O(N)$。</p>
<p>动态规划：定义函数 $f(i)$ 表示以第 $i$ 个字符为结尾的不包含重复字符的子字符串的最长长度。从左到右逐一扫描字符串中的每个字符，并使用哈希表保持每个字符上一次出现在字符串中位置对应的下标。若第 $i$ 个字符之前没有出现过， $f(i) = f(i-1) + 1$；若第 $i$ 个字符之前出现过，记第 $i$ 个字符和它上次出现在字符串中的位置的距离为 $d$，【$d \le f(i-1)$】：表明第 $i$ 个字符上次出现在 $f(i-1)$ 对应的最长子字符串中，此时 $f(i-1) = d$；【$d \gt f(i-1)$】：表明第 $i$ 个字符上次出现在 $f(i-1)$ 对应的最长子字符串之前，此时 $f(i)=f(i-1)+1$。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="literal">None</span> <span class="keyword">or</span> len(s) ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        maxvalue = dp[<span class="number">0</span>]</span><br><span class="line">        hashmap[s[<span class="number">0</span>]] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> hashmap:</span><br><span class="line">                distance = i - hashmap[s[i]]</span><br><span class="line">                hashmap[s[i]] = i</span><br><span class="line">                <span class="keyword">if</span> distance &lt;= dp[i<span class="number">-1</span>]:</span><br><span class="line">                    dp[i] = distance</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                hashmap[s[i]] = i</span><br><span class="line">            <span class="keyword">if</span> dp[i] &gt; maxvalue:</span><br><span class="line">                maxvalue = dp[i]</span><br><span class="line">        <span class="keyword">return</span> maxvalue</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-49：丑数"><a href="#面试题-49：丑数" class="headerlink" title="面试题 49：丑数"></a>面试题 49：丑数</h5><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p>丑数：如果一个数能被 $2$ 整除，就连续除以 $2$；如果能被 $3$ 整除，就连续除以 $3$；如果能被 $5$ 整除，就连续除以 $5$，最后得到的是 $1$。同时丑数应该是另一个丑数乘以 $2$、$3$ 或者 $5$ 的结果。</p>
<p>创建数组，保持排序好的丑数：数组中最大的丑数记为$M$，将数组前面的数分别乘以 $2, 3, 5$，获得大于 $M$的三个数$M_2, M_3, M_5$，下一个丑数是这个三个数中最小的，并使用 $T_2, T_3, T_5$ 保存排在此数之前的丑数乘以 $2, 3, 5$ 的结果都会小于 $M$。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.result = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> index &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.result = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(index)]</span><br><span class="line">        self.result[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        nextUglyIndex = <span class="number">1</span></span><br><span class="line">        T_2 = <span class="number">0</span></span><br><span class="line">        T_3 = <span class="number">0</span></span><br><span class="line">        T_5 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> nextUglyIndex &lt; index:</span><br><span class="line">            three_min = self.three_min(T_2, T_3, T_5)</span><br><span class="line">            self.result[nextUglyIndex] = three_min</span><br><span class="line">            <span class="keyword">while</span> self.result[T_2] * <span class="number">2</span> &lt;= self.result[nextUglyIndex]:</span><br><span class="line">                T_2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> self.result[T_3] * <span class="number">3</span> &lt;= self.result[nextUglyIndex]:</span><br><span class="line">                T_3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> self.result[T_5] * <span class="number">5</span> &lt;= self.result[nextUglyIndex]:</span><br><span class="line">                T_5 += <span class="number">1</span></span><br><span class="line">            nextUglyIndex += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.result[nextUglyIndex - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">three_min</span><span class="params">(self, T_2, T_3, T_5)</span>:</span></span><br><span class="line">        three_min = min(self.result[T_2]*<span class="number">2</span>, self.result[T_3]*<span class="number">3</span>)</span><br><span class="line">        three_min = min(three_min, self.result[T_5]*<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> three_min</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-50-1：字符串中第一个只出现一次的字符"><a href="#面试题-50-1：字符串中第一个只出现一次的字符" class="headerlink" title="面试题 50.1：字符串中第一个只出现一次的字符"></a>面试题 50.1：字符串中第一个只出现一次的字符</h5><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。</p>
<p>利用哈希表，扫描两次数组，第一次扫描时，每扫描到一个字符，就在哈希表的对应项中把次数加 1；第二次扫描时，每扫描到一个字符，就从哈希表中获得该字符出现的次数，第一个只出现一次的字符就是符合要求的输出。时间复杂度为 $O(N)$ ，空间复杂度 $O(1)$（需要一个包含256个字符的辅助数组，大小为 1KB，由于数组大小是个常数，可以认为空间复杂度时常数。）</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">if</span> dic[i] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span></span><br></pre></td></tr></table></figure>

</div></div>
<p>扩展题：考虑字符汉字<br>相关题目：</p>
<ol>
<li>从第一个字符串中删除在第二个字符串中出现过的所有字符。使用数组创建一个哈希表用来存储第二个字符串中出现过的字符，从头到尾遍历第一个字符串的每个字符，用 $O(1)$ 的时间判断是否出现在第二个字符串中。时间复杂度为 $O(N)$。</li>
<li>删除字符串中所有重复出现的字符，例如输入‘google’，输出’gole’。时间复杂度为 $O(N)$。</li>
<li>如果两个单词中出现的字符相同，并且每个字母出现的次数也相同，则这两个单词互为变位词。例如：‘evil’ 和 ’live’。判断输入的两个字符串是不是互为变位词。建立一个哈希表，扫描第一个字符串时哈希表对应的值增加 1，当扫描第二个字符串时，哈希表中对应的项值减去 1。</li>
</ol>
<h5 id="面试题-50-2：字符流中第一个只出现一次的字符"><a href="#面试题-50-2：字符流中第一个只出现一次的字符" class="headerlink" title="面试题 50.2：字符流中第一个只出现一次的字符"></a>面试题 50.2：字符流中第一个只出现一次的字符</h5><p>利用哈希表来保存字符在字符流中的位置。当一个字符第一次从字符流中读出来时，在哈希表中保存字符和字符的位置，若字符再次出现时，更新值为一个特殊值。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s = <span class="string">''</span></span><br><span class="line">        self.dict = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.s:</span><br><span class="line">            <span class="keyword">if</span> self.dict[i]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, char)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.s += char</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> self.dict:</span><br><span class="line">            self.dict[char]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.dict[char] = <span class="number">1</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-51：数组中的逆序对"><a href="#面试题-51：数组中的逆序对" class="headerlink" title="面试题 51：数组中的逆序对"></a>面试题 51：数组中的逆序对</h5><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数P。</p>
<p>先把数组分隔成子数组，统计出子数组内部的逆序对数目，然后再统计出两个相邻子数组之间的逆序对的数目，先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数字，【第一个子数组中的数字 &gt; 第二个子数组中的数字】：构成逆序对，逆序对的数目 == 第二个子数组中剩余数字的个数；【第一个子数组中的数字 &lt;= 第二个子数组中的数字】：不构成逆序对。每次比较时，将较大的数字从后往前复制到一个辅助数组，确保辅助数组中的数字是递增排序的（归并排序）。时间复杂度为 $O(N \log N)$ （归并排序的时间复杂度），空间复杂度为 $O(N)$。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        length = len(data)</span><br><span class="line">        <span class="keyword">if</span> data == <span class="literal">None</span> <span class="keyword">or</span> length &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        copy = [i <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">        count = self.InversePairsCore(data, copy, <span class="number">0</span>, length - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> count % <span class="number">10000000007</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InversePairsCore</span><span class="params">(self, data, copy, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == end:</span><br><span class="line">            copy[start] = data[start]</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = (end - start) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 函数调用时将copy数组和data数组互换</span></span><br><span class="line">        left = self.InversePairsCore(copy, data, start, start + length)</span><br><span class="line">        right = self.InversePairsCore(copy, data, start + length + <span class="number">1</span>, end)</span><br><span class="line">        i = start + length</span><br><span class="line">        j = end</span><br><span class="line">        indexCopy = end</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= start <span class="keyword">and</span> j &gt;= start + length + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> data[i] &gt; data[j]:</span><br><span class="line">                copy[indexCopy] = data[i]</span><br><span class="line">                indexCopy -= <span class="number">1</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                count += j - start - length</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                copy[indexCopy] = data[j]</span><br><span class="line">                indexCopy -= <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= start:</span><br><span class="line">            copy[indexCopy] = data[i]</span><br><span class="line">            indexCopy -= <span class="number">1</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= start + length + <span class="number">1</span>:</span><br><span class="line">            copy[indexCopy] = data[j]</span><br><span class="line">            indexCopy -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left + right + count</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-52：两个链表的第一个公共节点"><a href="#面试题-52：两个链表的第一个公共节点" class="headerlink" title="面试题 52：两个链表的第一个公共节点"></a>面试题 52：两个链表的第一个公共节点</h5><p>输入两个链表，找出它们的第一个公共结点。</p>
<p>时间复杂度 $O(N+M)$，额外空间复杂度 $O(N+M)$：若两个链表有公共节点，则公共节点出现在两个链表的尾部，从尾部往前比较，最后一个相同的节点即为第一个公共节点。“后进先出”的思想，利用两个栈来实现，分别把两个链表的节点放在两个栈中。</p>
<p>时间复杂度 $O(N+M)$，额外空间复杂度 $O(1)$：先遍历两个链表得到它们的长度，得到长链表比短链表多几个节点；再进行第二次遍历，在较长的链表上先走若干步，接着在两个链表上同时遍历，找到的第一个相同的节点即为第一个公共节点。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        p1_length = self.GetListLength(pHead1)</span><br><span class="line">        p2_length = self.GetListLength(pHead2)</span><br><span class="line">        <span class="keyword">if</span> p1_length &gt; p2_length:</span><br><span class="line">            pNodeLong = pHead1</span><br><span class="line">            pNodeShort = pHead2</span><br><span class="line">            dif_length = p1_length - p2_length</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pNodeLong = pHead2</span><br><span class="line">            pNodeShort = pHead1</span><br><span class="line">            dif_length = p2_length - p1_length</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(dif_length):</span><br><span class="line">            pNodeLong = pNodeLong.next</span><br><span class="line">        <span class="keyword">while</span> pNodeLong != <span class="literal">None</span> <span class="keyword">and</span> pNodeShort != <span class="literal">None</span> <span class="keyword">and</span> pNodeLong != pNodeShort:</span><br><span class="line">            pNodeLong = pNodeLong.next</span><br><span class="line">            pNodeShort = pNodeShort.next</span><br><span class="line">        <span class="keyword">return</span> pNodeLong</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetListLength</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        nLength = <span class="number">0</span></span><br><span class="line">        pNode = pHead</span><br><span class="line">        <span class="keyword">while</span> pNode != <span class="literal">None</span>:</span><br><span class="line">            nLength += <span class="number">1</span></span><br><span class="line">            pNode = pNode.next</span><br><span class="line">        <span class="keyword">return</span> nLength</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-53-1：数字在排序数组中出现的次数"><a href="#面试题-53-1：数字在排序数组中出现的次数" class="headerlink" title="面试题 53.1：数字在排序数组中出现的次数"></a>面试题 53.1：数字在排序数组中出现的次数</h5><p>统计一个数字在排序数组中出现的次数。 </p>
<p>利用二分查找的方法，找到数字第一次在数组中出现的位置【用数组中间的数字和要找的数字比较，若大于，往前找，若小于，往后找，若相等，查看中间数字的前一个是不是要找的数字】，找到数字最后一次在数组中出现的位置。时间复杂度为 $O(\log N)$。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="literal">None</span> <span class="keyword">or</span> len(data) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        number = <span class="number">0</span></span><br><span class="line">        first = self.GetFirstK(data, k, <span class="number">0</span>, len(data)<span class="number">-1</span>)</span><br><span class="line">        last = self.GetLastK(data, k, <span class="number">0</span>, len(data)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> first &gt; <span class="number">-1</span> <span class="keyword">and</span> last &gt; <span class="number">-1</span>:</span><br><span class="line">            number = last - first + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> number</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetFirstK</span><span class="params">(self, data, k, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        middle = int((end - start) / <span class="number">2</span>) + start</span><br><span class="line">        <span class="keyword">if</span> data[middle] == k:</span><br><span class="line">            <span class="keyword">if</span> (middle &gt; <span class="number">0</span> <span class="keyword">and</span> data[middle<span class="number">-1</span>] != k) <span class="keyword">or</span> middle == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = middle - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> data[middle] &gt; k:</span><br><span class="line">            end = middle - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.GetFirstK(data, k, start, end)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLastK</span><span class="params">(self, data, k, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        middle = int((end - start) / <span class="number">2</span>) + start</span><br><span class="line">        <span class="keyword">if</span> data[middle] == k:</span><br><span class="line">            <span class="keyword">if</span> (middle &lt; len(data)<span class="number">-2</span> <span class="keyword">and</span> data[middle + <span class="number">1</span>] != k) <span class="keyword">or</span> middle == len(data) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> data[middle] &gt; k:</span><br><span class="line">            end = middle - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.GetLastK(data, k, start, end)</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-53-2：0-n-1-中缺失的数字"><a href="#面试题-53-2：0-n-1-中缺失的数字" class="headerlink" title="面试题 53.2：0~n-1 中缺失的数字"></a>面试题 53.2：0~n-1 中缺失的数字</h5><p> 一个长度为 $n-1$ 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0~n-1 之内。在范围 0~n-1 内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 </p>
<p>数字在数组中是是排序的，因此数组中开始的一些数字和它们的下标相同。记不在数组中的数为 $m$，那么所有比 $m$ 小的数字的下标都与它们的值相同，转换问题为：在排序数组中找出第一个值和下标不相等的元素。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMissingNumber</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="literal">None</span> <span class="keyword">or</span> len(number) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(number) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = int((right - left) / <span class="number">2</span>) + left</span><br><span class="line">            <span class="keyword">if</span> number[middle] != middle:</span><br><span class="line">                <span class="keyword">if</span> middle == <span class="number">0</span> <span class="keyword">or</span> number[middle<span class="number">-1</span>] == middle - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> middle</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left == len(number):</span><br><span class="line">            <span class="keyword">return</span> len(number)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-53-3：数组中数值和下标相等的元素"><a href="#面试题-53-3：数组中数值和下标相等的元素" class="headerlink" title="面试题 53.3：数组中数值和下标相等的元素"></a>面试题 53.3：数组中数值和下标相等的元素</h5><p>假设一个单调递增的数组里的每个元素都是整数且是唯一的，请编程实现一个函数，找出数组中任意一个数值等于其下标的元素，例如，在数组{-3，-1,1,3,5}中数字3和它的下标相同。 </p>
<p>利用二分查找算法：若当前数字的值 $m$ &gt; 数组的下标值 $i$：数组右边的数字都将大于其下标。若当前数字的值 $m$ &lt; 数组的下标值 $i$：数组左边的数字都将小于其下标。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberSameAsIndex</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="literal">None</span> <span class="keyword">or</span> len(number) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(number) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = int((right - left) / <span class="number">2</span>) + left</span><br><span class="line">            <span class="keyword">if</span> number[middle] == middle:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">            <span class="keyword">elif</span> number[middle] &gt; middle:</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-54：-二叉搜索树的第-k-大节点"><a href="#面试题-54：-二叉搜索树的第-k-大节点" class="headerlink" title="面试题 54： 二叉搜索树的第 k 大节点"></a>面试题 54： 二叉搜索树的第 k 大节点</h5><p>给定一棵二叉搜索树，请找出其中的第 $k$ 大的结点。例如（5，3，7，2，4，6，8）中，按结点数值大小顺序第三大结点的值为 4。（中序遍历）</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回对应节点TreeNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pRoot == <span class="literal">None</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.KthNodeCore(pRoot, k)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNodeCore</span><span class="params">(self, pRoot, k)</span>:</span></span><br><span class="line">        node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pRoot.left != <span class="literal">None</span>:</span><br><span class="line">            node = self.KthNodeCore(pRoot.left, k)</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.count == k:</span><br><span class="line">                <span class="keyword">return</span> pRoot</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span> <span class="keyword">and</span> pRoot.right != <span class="literal">None</span>:</span><br><span class="line">            node = self.KthNodeCore(pRoot.right, k)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-55-1：-二叉树的深度"><a href="#面试题-55-1：-二叉树的深度" class="headerlink" title="面试题 55.1： 二叉树的深度"></a>面试题 55.1： 二叉树的深度</h5><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。<br>根节点的左子树，右子树较大值 + 1为二叉树的高度。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pRoot == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.TreeDepth(pRoot.left)</span><br><span class="line">        right = self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span> <span class="keyword">if</span> left &gt; right <span class="keyword">else</span> right + <span class="number">1</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-55-2：-平衡二叉树"><a href="#面试题-55-2：-平衡二叉树" class="headerlink" title="面试题 55.2： 平衡二叉树"></a>面试题 55.2： 平衡二叉树</h5><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。<br>简单解：遍历树的每一个节点，获得节点的左右子数的深度，如果每个节点的左右子数的深度差都不超过1。此方法会重复遍历一个节点多次。<br>每个节点只遍历一次：利用后序遍历的方式（在遍历到一个节点之前已经遍历完它的左右子数），在遍历每个节点的时候纪录节点的深度。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.flag = <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pRoot == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.IsBalanced_Solution(pRoot.left) <span class="keyword">and</span> self.IsBalanced_Solution(pRoot.right):</span><br><span class="line">            left = self.TreeDepth(pRoot.left)</span><br><span class="line">            right = self.TreeDepth(pRoot.right)</span><br><span class="line">            <span class="keyword">if</span> abs(left - right) &gt; <span class="number">1</span>:</span><br><span class="line">                self.flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">return</span> self.flag</span><br><span class="line">        <span class="keyword">return</span> self.flag</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pRoot == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.TreeDepth(pRoot.left)</span><br><span class="line">        right = self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span> <span class="keyword">if</span> left &gt; right <span class="keyword">else</span> right + <span class="number">1</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-56-1：-数组中只出现一次的两个数字-amp-amp-LeetCode-260-只出现一次的数字-III"><a href="#面试题-56-1：-数组中只出现一次的两个数字-amp-amp-LeetCode-260-只出现一次的数字-III" class="headerlink" title="面试题 56.1： 数组中只出现一次的两个数字 &amp;&amp; LeetCode 260.只出现一次的数字 III"></a>面试题 56.1： 数组中只出现一次的两个数字 &amp;&amp; LeetCode 260.只出现一次的数字 III</h5><p>LeetCode：<a href="https://leetcode-cn.com/problems/single-number-iii/" target="_blank" rel="noopener">260. 只出现一次的数字 III</a><br>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<br>异或：任何一个数字异或自己等于0，【无进位相加】。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> array == <span class="literal">None</span> <span class="keyword">or</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        resultExclusiveOR = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            resultExclusiveOR ^= i</span><br><span class="line">        indexOf1 = (~resultExclusiveOR + <span class="number">1</span>) &amp; resultExclusiveOR</span><br><span class="line">        num1 = <span class="number">0</span></span><br><span class="line">        num2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> i &amp; indexOf1 == <span class="number">0</span>:</span><br><span class="line">                num1 ^= i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num2 ^= i</span><br><span class="line">        <span class="keyword">return</span> [num1, num2]</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-56-2：-数组中唯一只出现一次的数字-amp-amp-LeetCode-137-只出现一次的数字II"><a href="#面试题-56-2：-数组中唯一只出现一次的数字-amp-amp-LeetCode-137-只出现一次的数字II" class="headerlink" title="面试题 56.2： 数组中唯一只出现一次的数字  &amp;&amp;  LeetCode 137.只出现一次的数字II"></a>面试题 56.2： 数组中唯一只出现一次的数字  &amp;&amp;  LeetCode 137.只出现一次的数字II</h5><p>LeetCode：<a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137. 只出现一次的数字 II</a><br>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 </p>
<p>位运算：如果一个数字出现三次，那么它的二进制表示的每一位（0或者1）也出现三次，把所有出现三次的数字的二进制表示的每一位都分别加起来，那么每一位的和都能被3整除。数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除，那么那个只出现一次的数字二进制表示对应的那一位是0，否则为1。【注意：python的整型方便是方便了，但是由于其没有最大值，所以，当输入是一堆负数的时候，会导致认为结果是个整数！因为32位有符号的被认为成了无符号的，所以以后出现位运算的时候，需要对结果进行判断一下最好。如果不在这个范围内，说明了结果被认为是无符号的数了，需要减去 $2 ^ {32}$。【16位整数中 -32768到32767】【32位整数中 -2147483648到2147483647】最高位为符号位 【16位整数$-2^{15}$~$2^{15}-1$】【 32位整数$-2^{31}$~$2^{31}-1$】。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SingleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        bitSum = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            bitMask = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">31</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                bit = nums[i] &amp; bitMask</span><br><span class="line">                <span class="keyword">if</span> bit != <span class="number">0</span>:</span><br><span class="line">                    bitSum[j] += <span class="number">1</span></span><br><span class="line">                bitMask = bitMask&lt;&lt; <span class="number">1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            result = result &lt;&lt; <span class="number">1</span></span><br><span class="line">            result += bitSum[i] % <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> result &gt;= <span class="number">2</span> ** <span class="number">31</span>:</span><br><span class="line">            result -= <span class="number">2</span> ** <span class="number">32</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

</div></div>
<p>其他解法： $k$ 进制的两个数 $c$ 和 $d$ 在 $i$ 位上无进位相加的结果就是 $(c(i)+d(i))\%k$ 。 如果k个相同的k进制数进行无进位相加，相加的结果一定是每一位上都是0的 $k$ 进制数。首先设置一个变量eO，它是一个32位的 $k$ 进制数，且每个位置上都是0。然后遍历arr，把遍历到的每一个整数都转换为k进制数，然后与eO进行无进位相加。遍历结束时，把32位的 $k$ 进制数eORes转换为十进制整数，就是我们想要的结果。因为 $k$ 个相同的k进制数无进位相加，结果一定是每一位上都是0的 $k$ 进制数，所以只出现一次的那个数最终就会剩下来。（左程云.《程序员代码面试指南：IT名企算法与数据结构题目最优解（第2版）》.[Z].北京.电子工业出版社.2019. 摘要：）</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 补充代码</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-57-1：-和为-s-的两个数字"><a href="#面试题-57-1：-和为-s-的两个数字" class="headerlink" title="面试题 57.1： 和为 s 的两个数字"></a>面试题 57.1： 和为 s 的两个数字</h5><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br>定义两个指针，P1指向数组的开头，P2 指向数组的结尾，如果两个指针指向的数字之和 &gt; 数字S，P2指针向前移动；如果两个指针指向的数字之和 &lt; 数字S，P1指针向后移动。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        p1 = <span class="number">0</span></span><br><span class="line">        p2 = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; p2:</span><br><span class="line">            <span class="keyword">if</span> nums[p1] + nums[p2] == target:</span><br><span class="line">                <span class="keyword">return</span> [nums[p1], nums[p2]]</span><br><span class="line">            <span class="keyword">elif</span> nums[p1] + nums[p2] &gt; target:</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-57-2：-和为-s-的连续正数序列"><a href="#面试题-57-2：-和为-s-的连续正数序列" class="headerlink" title="面试题 57.2： 和为 s 的连续正数序列"></a>面试题 57.2： 和为 s 的连续正数序列</h5><p>输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以结果打印出3个连续序列1-5,，4-6和7-8。</p>
<p>用两个树 small 和 big 表示连续序列的最小值和最大值，初始化时 $small = 1，big = 2$, 如果 $small + big &lt; s$，增大 $big$，如果$small + big &gt; s$，从序列中去掉最小值，即增大 $small$；因为这个序列至少要有两个数字，因此一直增加 small 到 (1+s)/2。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span><span class="params">(self, target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        small = <span class="number">1</span></span><br><span class="line">        big = <span class="number">2</span></span><br><span class="line">        cursum = small + big</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> small &lt; (target+<span class="number">1</span>)//<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> cursum == target:</span><br><span class="line">                res.append([i <span class="keyword">for</span> i <span class="keyword">in</span> range(small, big+<span class="number">1</span>)])</span><br><span class="line">                big += <span class="number">1</span></span><br><span class="line">                cursum += big</span><br><span class="line">            <span class="keyword">elif</span> cursum &gt; target:</span><br><span class="line">                cursum -= small</span><br><span class="line">                small += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                big += <span class="number">1</span></span><br><span class="line">                cursum += big</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-58-1：翻转单词顺序"><a href="#面试题-58-1：翻转单词顺序" class="headerlink" title="面试题 58.1：翻转单词顺序"></a>面试题 58.1：翻转单词顺序</h5><p>输入一个英文句子，翻转句子中单词的顺序。例如，“I am a student.” 翻转成 “student. a am I”。<br>两次翻转字符串：第一次翻转句子中所有的字符：【“I am a student.”——“.tneduts a ma I”】；第二次再翻转每个单词中字符的顺序【“.tneduts a ma I”——“student. a am I”】</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">1</span> <span class="keyword">or</span> s == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> s </span><br><span class="line">        s_list = list(s)</span><br><span class="line">        self.Reverse(s_list, <span class="number">0</span>, len(s_list)<span class="number">-1</span>)</span><br><span class="line">        pBegin = <span class="number">0</span></span><br><span class="line">        pEnd = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pEnd &lt; len(s_list):</span><br><span class="line">            <span class="keyword">while</span> pEnd &lt; len(s_list) <span class="keyword">and</span> s_list[pEnd] != <span class="string">' '</span>:</span><br><span class="line">                pEnd += <span class="number">1</span></span><br><span class="line">            self.Reverse(s_list, pBegin, pEnd<span class="number">-1</span>)</span><br><span class="line">            pBegin = pEnd + <span class="number">1</span></span><br><span class="line">            pEnd = pBegin</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s_list)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Reverse</span><span class="params">(self, s_list, pBegin, pEnd)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> pBegin &lt; pEnd:</span><br><span class="line">            tmp = s_list[pBegin]</span><br><span class="line">            s_list[pBegin] = s_list[pEnd]</span><br><span class="line">            s_list[pEnd] = tmp</span><br><span class="line">            pBegin += <span class="number">1</span></span><br><span class="line">            pEnd -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-58-2：左旋转字符串"><a href="#面试题-58-2：左旋转字符串" class="headerlink" title="面试题 58.2：左旋转字符串"></a>面试题 58.2：左旋转字符串</h5><p>对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。<br>翻转字符串：先将字符串分成两部分，分别进行翻转，最后再将整体进行翻转。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span><span class="params">(self, s, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> s != <span class="literal">None</span>:</span><br><span class="line">            nLength = len(s)</span><br><span class="line">            s_list = list(s)</span><br><span class="line">            <span class="keyword">if</span> nLength &gt; <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n &lt; nLength:</span><br><span class="line">                pFirstStart = <span class="number">0</span></span><br><span class="line">                pFirstEnd = n - <span class="number">1</span></span><br><span class="line">                pSecondStrat = n</span><br><span class="line">                pSecondEnd = nLength - <span class="number">1</span></span><br><span class="line">                self.Reverse(s_list, pFirstStart, pFirstEnd)</span><br><span class="line">                self.Reverse(s_list, pSecondStrat, pSecondEnd)</span><br><span class="line">                self.Reverse(s_list, <span class="number">0</span>, nLength - <span class="number">1</span>)</span><br><span class="line">                s = <span class="string">''</span>.join(s_list)</span><br><span class="line">        <span class="keyword">return</span> s </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Reverse</span><span class="params">(self, s_list, pBegin, pEnd)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> pBegin &lt; pEnd:</span><br><span class="line">            tmp = s_list[pBegin]</span><br><span class="line">            s_list[pBegin] = s_list[pEnd]</span><br><span class="line">            s_list[pEnd] = tmp</span><br><span class="line">            pBegin += <span class="number">1</span></span><br><span class="line">            pEnd -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-59：滑动窗口的最大值"><a href="#面试题-59：滑动窗口的最大值" class="headerlink" title="面试题 59：滑动窗口的最大值"></a>面试题 59：滑动窗口的最大值</h5><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 </p>
<p>双端队列：将有可能成为滑动窗口最大值的数值存入双端队列中。使用两个指针L，R 确定窗口，队列严格维持由大到小的顺序，R 右移时，当前数字从队列尾部进入，若此时队列中有 &lt; 当前数字的数时，则小于当前数的数先弹出（弹出的数字再不进入队列）；L 右移时，查看L 右移出的数字是否在队列中，若在则从队列头部移除。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> len(num) &gt;= size <span class="keyword">and</span> size &gt; <span class="number">0</span>:</span><br><span class="line">            index = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">                print(index)</span><br><span class="line">                <span class="keyword">while</span> len(index) != <span class="number">0</span> <span class="keyword">and</span> num[i] &gt;= num[index[<span class="number">-1</span>]]:</span><br><span class="line">                    index.pop()</span><br><span class="line">                index.append(i)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(size, len(num)):</span><br><span class="line">                result.append(num[index[<span class="number">0</span>]])</span><br><span class="line">                <span class="keyword">while</span> len(index) != <span class="number">0</span> <span class="keyword">and</span> num[i] &gt;= num[index[<span class="number">-1</span>]]:</span><br><span class="line">                    index.pop()</span><br><span class="line">                <span class="keyword">if</span> len(index) != <span class="number">0</span> <span class="keyword">and</span> index[<span class="number">0</span>] &lt;= i - size:</span><br><span class="line">                    index.pop(<span class="number">0</span>)</span><br><span class="line">                index.append(i)</span><br><span class="line">            result.append(num[index[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-60：n-个骰子的点数-amp-amp-LeetCode-60-n-个骰子的点数"><a href="#面试题-60：n-个骰子的点数-amp-amp-LeetCode-60-n-个骰子的点数" class="headerlink" title="面试题 60：n 个骰子的点数  &amp;&amp; LeetCode 60. n 个骰子的点数"></a>面试题 60：n 个骰子的点数  &amp;&amp; LeetCode 60. n 个骰子的点数</h5><p>LeetCode：<a href>面试题60. n个骰子的点数</a><br>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值的概率。 </p>
<p>基于递归：先把 $n$ 个骰子分成两部分，第一堆只有一个，另一堆有 $n-1$ 个，单独的一个骰子有可能出现1~6 的点数，需要计算 1~6的每一种点数和剩下的 $n-1$ 个骰子来计算点数和；接下来将剩下的 $n-1$ 个骰子再次按照上述方法分成两部分。多次重复计算，时间效率不高。</p>
<p>基于循环：用两个数字来存储骰子点数的每个总数出现的次数，在一轮循环中，第一个数组中的第 $n$ 个数字表示骰子和为 n 出现的次数，在下一轮循环中，加一个新的骰子，此时和为 n 的骰子出现的次数应该等于上一轮循环中骰子点数和为 $n-1, n-2, n-3, n-4, n-5, n-6$ 的次数的总和。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = <span class="number">6</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Probability</span><span class="params">(self, n: int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        maxsum = self.count * n</span><br><span class="line">        Probability = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(maxsum + <span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, self.count + <span class="number">1</span>):</span><br><span class="line">            Probability[flag][i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">                Probability[<span class="number">1</span> - flag][i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k, self.count * k + <span class="number">1</span>):</span><br><span class="line">                Probability[<span class="number">1</span> - flag][i] = <span class="number">0</span></span><br><span class="line">                j = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j &lt;= i <span class="keyword">and</span> j &lt;= self.count:</span><br><span class="line">                    Probability[<span class="number">1</span> - flag][i] += Probability[flag][i - j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            flag = <span class="number">1</span> - flag</span><br><span class="line">        total = pow(self.count, n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n, self.count * n + <span class="number">1</span>):</span><br><span class="line">            Probability[flag][i] = Probability[flag][i] / total</span><br><span class="line">        <span class="keyword">return</span> Probability[flag][n:self.count*n + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-61：扑克牌中的顺子"><a href="#面试题-61：扑克牌中的顺子" class="headerlink" title="面试题 61：扑克牌中的顺子"></a>面试题 61：扑克牌中的顺子</h5><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。其中A为1，J为11，Q为12，K为13，而大小王为0，且大小王能够当做任意一张牌。<br>三步：首先把数组排序，其次统计数组中 0 的个数，最后统计排序之后的数组中相邻数字之间的空缺总数。如果空缺的总数小于或者等于 0 的个数，则数组是连续的，反之不连续。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsContinuous</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        numbers.sort()</span><br><span class="line">        numOfKing = numbers.count(<span class="number">0</span>)</span><br><span class="line">        numOflack = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numOfKing, len(numbers) <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> numbers[i] == numbers[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                numOflack += (numbers[i + <span class="number">1</span>] - numbers[i] - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> numOfKing &gt;= numOflack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

</div></div>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isStraight</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        respeat = []</span><br><span class="line">        maxvalue = <span class="number">0</span></span><br><span class="line">        minvalue = <span class="number">14</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            print(respeat)</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">            maxvalue = max(maxvalue, num)</span><br><span class="line">            minvalue = min(minvalue, num)</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> respeat:<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            respeat.append(num)</span><br><span class="line">        <span class="keyword">return</span> maxvalue - minvalue &lt; <span class="number">5</span></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-62：圆圈中最后剩下的数字"><a href="#面试题-62：圆圈中最后剩下的数字" class="headerlink" title="面试题 62：圆圈中最后剩下的数字"></a>面试题 62：圆圈中最后剩下的数字</h5><p>$0, 1, … , n-1$ 这n个数字排成一个圈圈，从数字0开始每次从圆圏里删除第m个数字。求出这个圈圈里剩下的最后一个数字。 </p>
<p>经典解法：利用环形链表模拟圆圈，创建一个共有 n 个节点的环形链表，然后每次在这个链表中删除第 m 个节点。每删除一个数字需要 m 步运算，共有 n 个数字，总的时间复杂度为 $O(mn)$，同时还需要一个辅助链表来模拟圆圈，额外空间复杂度为 $O(n)$。</p>
<p>找规律法：设 $f(n, m)$，表示每次在 n 个数字0，1，…，n-1中删除第 m 个数字最后剩下的数字，删除的第一个数字$(m-1)\%n$，记为 k，$f^{‘}(n-1, m)$ 表示在第一个数字被删除后，序列重新调整后删除第 m 个节点最后剩下的数字，因此 $f^{‘}(n-1, m)=f(n, m)$；设 $p(x)=(x-k-1)\%n$，表示如果映射前的数字是 $x$，映射后的数字是 $(x-k-1)\%n$，逆映射为 $p^{-1}(x) = (x+k+1)\%n$。因此 $f^{’}(n-1, m)=p^{-1}[f(n-1,m)]=[f(n-1, m)+k+1] \%n$。</p>
<script type="math/tex; mode=display">
f(n, m)=\begin{cases}
0, & \text{n=1} \\[3ex]
[f(n-1, m)+m]\%n, & \text{n>1}
\end{cases}</script><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span> <span class="keyword">or</span> m &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        last = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            last = (last + m) % i</span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-63：股票的最大利润-amp-amp-LeetCode-121-买卖股票的最佳时机"><a href="#面试题-63：股票的最大利润-amp-amp-LeetCode-121-买卖股票的最佳时机" class="headerlink" title="面试题 63：股票的最大利润 &amp;&amp; LeetCode 121.买卖股票的最佳时机"></a>面试题 63：股票的最大利润 &amp;&amp; LeetCode 121.买卖股票的最佳时机</h5><p>LeetCode：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a><br>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖交易该股票可能获得的利润是多少？例如一只股票在某些时间节点的价格为$\{9, 11, 8, 5, 7, 12, 16, 14\}$。如果我们能在价格为5的时候买入并在价格为16时卖出，则能收获最大的利润11。 </p>
<p>定义函数 $diff(i)$ 为当卖出价为数组中第 $i$ 个数字时可能获得的最大利润，遍历数组时，需要前 $i-1$个数字中的最小值。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> prices == <span class="literal">None</span> <span class="keyword">or</span> len(prices) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        minbuy = prices[<span class="number">0</span>]</span><br><span class="line">        maxdiff = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i<span class="number">-1</span>] &lt; minbuy:</span><br><span class="line">                minbuy = prices[i<span class="number">-1</span>]</span><br><span class="line">            curdiff = prices[i] - minbuy</span><br><span class="line">            <span class="keyword">if</span> curdiff &gt; maxdiff:</span><br><span class="line">                maxdiff = curdiff</span><br><span class="line">        <span class="keyword">return</span> maxdiff</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-64：-求-1-2-…-n"><a href="#面试题-64：-求-1-2-…-n" class="headerlink" title="面试题 64： 求 1+2+…+n"></a>面试题 64： 求 1+2+…+n</h5><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 </p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用python特征</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> sum(list(range(<span class="number">1</span>,n+<span class="number">1</span>)))</span><br><span class="line"><span class="comment"># 终止递归采用逻辑与的短路特性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here     </span></span><br><span class="line">        <span class="keyword">return</span> n <span class="keyword">and</span> n + self.Sum_Solution(n<span class="number">-1</span>)</span><br><span class="line"><span class="comment"># 利用两个函数，一个函数充当递归函数的角色，另一个函数处理终止递归的情况，如果对n连续进行两次反运算，那么非零的n转换为True，0转换为False。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here     </span></span><br><span class="line">        <span class="keyword">return</span> self.sum(n)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum0</span><span class="params">(self,n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(self,n)</span>:</span></span><br><span class="line">        func=&#123;<span class="literal">False</span>:self.sum0,<span class="literal">True</span>:self.sum&#125;</span><br><span class="line">        <span class="keyword">return</span> n+func[<span class="keyword">not</span> <span class="keyword">not</span> n](n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-65：不用加减乘除做加法"><a href="#面试题-65：不用加减乘除做加法" class="headerlink" title="面试题 65：不用加减乘除做加法"></a>面试题 65：不用加减乘除做加法</h5><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 </p>
<p>第一步不考虑进位对每个数的二进制每一位相加（两个数的异或）；第二步考虑进位，对 0 加 0、0 加 1、1 加 0 都不会产生进位，只有 1 加 1时，才会产生进位，即两个数先做位与运算，然后左移一位；第三步将前两步的结果按照上述两步方式进行相加，直到不产生进位。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">while</span> num2 != <span class="number">0</span>:</span><br><span class="line">            xor = num1 ^ num2</span><br><span class="line">            carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span></span><br><span class="line">            num1 = xor</span><br><span class="line">            num2 = carry</span><br><span class="line">        <span class="keyword">return</span> num1</span><br></pre></td></tr></table></figure>

</div></div>
<p>在使用Python实现的过程中，对于正整数是没有问题的，但是对于负数，会出现死循环情况。因为在Python中，对于超出32位的大整数，会自动进行大整数的转变，这就导致了在右移位过程中，不会出现移到了0的情况，也就会造成了死循环。已经知道了右移过程中大整数的自动转化，导致变不成0，那么只需要在移动的过程中加一下判断就行了，把carry的值和 $0xFFFFFFFF$ 做一下比较就可以。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 牛客网</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        carry = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> carry:</span><br><span class="line">            xor = num1 ^ num2</span><br><span class="line">            carry = <span class="number">0xFFFFFFFF</span> &amp; ((num1 &amp; num2) &lt;&lt; <span class="number">1</span>)</span><br><span class="line">            carry = -(~(carry - <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFF</span>) <span class="keyword">if</span> carry &gt; <span class="number">0x7FFFFFFF</span> <span class="keyword">else</span> carry</span><br><span class="line">            num1 = xor</span><br><span class="line">            num2 = carry</span><br><span class="line">        <span class="keyword">return</span> num1</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-66：构建乘积数组"><a href="#面试题-66：构建乘积数组" class="headerlink" title="面试题 66：构建乘积数组"></a>面试题 66：构建乘积数组</h5><p>给定一个数组A[0,1,…,n-1]，请构建一个数组B[0,1,…,n-1]，其中B中的元素 $B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]$。不能使用除法。（注意：规定B[0] = A[1] <em> A[2] </em> … <em> A[n-1]，B[n-1] = A[0] </em> A[1] <em> … </em> A[n-2];） </p>
<p>把 $B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]$ 看成 $A[0] <em>A[1]</em>…<em>A[i-1]$ 和 $A[i+1]</em>…<em>A[n-2]</em>A[n-1]$ 两部分的乘积。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> A == <span class="literal">None</span> <span class="keyword">or</span> len(A) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        length = len(A) </span><br><span class="line">        B = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(length)]</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            B[i] = B[i<span class="number">-1</span>] * A[i<span class="number">-1</span>]</span><br><span class="line">        temp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            temp *= A[i + <span class="number">1</span>]</span><br><span class="line">            B[i] *= temp</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题-67：把字符串转换成整数"><a href="#面试题-67：把字符串转换成整数" class="headerlink" title="面试题 67：把字符串转换成整数"></a>面试题 67：把字符串转换成整数</h5><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 。</p>
<p>主要是需要对异常值要做出处理：指针是否为空指针以及字符串是否为空字符串；字符串对于正负号的处理；输入值是否为合法值，即小于等于’9’，大于等于’0’；int为32位，需要判断是否溢出；使用错误标志，区分合法值0和非法值0。代码中用两个函数来实现该功能，其中标志位g_nStatus用来表示是否为异常输出，minus标志位用来表示是否为负数。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.g_nStatus = <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StrToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="literal">None</span> <span class="keyword">or</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            self.g_nStatus = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        minus = <span class="literal">False</span></span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'+'</span>:</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'-'</span>:</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            minus = <span class="literal">True</span></span><br><span class="line">        begin = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            begin = <span class="number">1</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        minus = <span class="number">-1</span> <span class="keyword">if</span> minus <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s[begin:]:</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="string">'0'</span> <span class="keyword">and</span> i &lt;= <span class="string">'9'</span>:</span><br><span class="line">                num = num * <span class="number">10</span> + minus * (ord(i) - ord(<span class="string">'0'</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.g_nStatus = <span class="literal">False</span></span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">-2</span> ** <span class="number">31</span> <span class="keyword">or</span> num &gt; <span class="number">2</span> ** <span class="number">31</span> <span class="number">-1</span>:</span><br><span class="line">            self.g_nStatus = <span class="literal">False</span></span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">print(Solution().StrToInt(<span class="string">''</span>))  <span class="comment"># 输入的字符串为空字符串</span></span><br><span class="line">print(Solution().StrToInt(<span class="literal">None</span>))  <span class="comment"># 输入的字符串为空指针</span></span><br><span class="line">print(Solution().StrToInt(<span class="string">'12%34'</span>))  <span class="comment"># 输入的字符串中有非数字字符</span></span><br><span class="line">print(Solution().StrToInt(<span class="string">'-123'</span>))</span><br><span class="line">print(Solution().StrToInt(<span class="string">'+123'</span>))</span><br><span class="line">print(Solution().StrToInt(<span class="string">'-0'</span>))</span><br><span class="line">print(Solution().StrToInt(<span class="string">'-2147483649'</span>))</span><br><span class="line">print(<span class="number">2</span> ** <span class="number">31</span>)  <span class="comment"># 2147483648</span></span><br><span class="line">print(<span class="number">2</span> ** <span class="number">32</span>)  <span class="comment"># 4294967296</span></span><br><span class="line">print(<span class="number">0xFFFFFFFF</span>)  <span class="comment"># 4294967295</span></span><br><span class="line">print(<span class="number">0x80000000</span>)  <span class="comment"># 2147483648</span></span><br></pre></td></tr></table></figure>

</div></div>
<p>【16位整数中 -32768到32767】【32位整数中 -2147483648到2147483647】最高位为符号位 【16位整数$-2^{15}$~$2^{15}-1$】【 32位整数$-2^{31}$~$2^{31}-1$】</p>
<h5 id="面试题-68：树中两个节点的最低公共祖先-amp-amp-LeetCode-235-二叉搜索树的最近公共祖先-amp-amp-LeetCode-236-二叉树的最近公共祖先"><a href="#面试题-68：树中两个节点的最低公共祖先-amp-amp-LeetCode-235-二叉搜索树的最近公共祖先-amp-amp-LeetCode-236-二叉树的最近公共祖先" class="headerlink" title="面试题 68：树中两个节点的最低公共祖先 &amp;&amp; LeetCode 235.二叉搜索树的最近公共祖先  &amp;&amp; LeetCode 236. 二叉树的最近公共祖先"></a>面试题 68：树中两个节点的最低公共祖先 &amp;&amp; LeetCode 235.二叉搜索树的最近公共祖先  &amp;&amp; LeetCode 236. 二叉树的最近公共祖先</h5><p>题目：输入两个树的节点，求它们的最低公共祖先。<br>树是二叉搜索树：【LeetCode：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">面试题68 - I. 二叉搜索树的最近公共祖先</a>】；在二叉搜索树中，位与左子树的节点都比父节点小，而位与右子树的节点都比父节点大，从树的根节点开始和两个输入的节点进行比较，若当前节点的值比两个节点的值都大，则最低公共祖先一定在当前节点的左子树中；若当前节点的值比两个节点的值都小，则最低公共祖先一定在当前节点的右子树中，在树中从上到下找到第一个在两个输入节点的值之间的节点即为最低公共祖先。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span> <span class="keyword">or</span> p == <span class="literal">None</span> <span class="keyword">or</span> q == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pNode = root</span><br><span class="line">        <span class="keyword">while</span> pNode != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> pNode.val &gt; p.val <span class="keyword">and</span> pNode.val &gt; q.val:</span><br><span class="line">                pNode = pNode.left</span><br><span class="line">            <span class="keyword">elif</span> pNode.val &lt; p.val <span class="keyword">and</span> pNode.val &lt; q.val:</span><br><span class="line">                pNode = pNode.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> pNode</span><br><span class="line">        <span class="keyword">return</span> pNode</span><br></pre></td></tr></table></figure>

</div></div>
<p>树是二叉树，且树的节点中有指向父节点的指针：可以将问题转换成求两个链表的第一个公共节点，从两个输入节点开始，创建两个链表，链表的尾指针都是树的根节点。</p>
<p>树是二叉树，但树的节点中没有指向父节点的指针：【LeetCode：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a>】用两个链表分别保存从根节点到输入的两个节点的路径，之后将问题转换成两个链表的最后公共节点。时间复杂度为 $O(N)$，额外空间复杂度为 $O(\log n)$。</p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span> <span class="keyword">or</span> p == <span class="literal">None</span> <span class="keyword">or</span> q == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        path1 = []</span><br><span class="line">        path2 = []</span><br><span class="line">        self.CreateLink(root, p, path1)</span><br><span class="line">        self.CreateLink(root, q, path2)</span><br><span class="line">        <span class="keyword">return</span> self.LastCommonNode(path1, path2)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CreateLink</span><span class="params">(self, root, p, path)</span>:</span></span><br><span class="line">        pNode = root</span><br><span class="line">        path.append(pNode)</span><br><span class="line">        <span class="keyword">if</span> root == p:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> found == <span class="literal">False</span> <span class="keyword">and</span> pNode.left != <span class="literal">None</span>:</span><br><span class="line">            found = self.CreateLink(pNode.left, p, path)</span><br><span class="line">        <span class="keyword">if</span> found == <span class="literal">False</span> <span class="keyword">and</span> pNode.right != <span class="literal">None</span>:</span><br><span class="line">            found = self.CreateLink(pNode.right, p, path)</span><br><span class="line">        <span class="keyword">if</span> found == <span class="literal">False</span>:</span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastCommonNode</span><span class="params">(self, path1, path2)</span>:</span></span><br><span class="line">        pLast = <span class="literal">None</span></span><br><span class="line">        index1 = <span class="number">0</span></span><br><span class="line">        index2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index1 &lt; len(path1) <span class="keyword">and</span> index2 &lt; len(path2):</span><br><span class="line">            <span class="keyword">if</span> path1[index1] == path2[index2]:</span><br><span class="line">                pLast = path1[index1]</span><br><span class="line">            index1 += <span class="number">1</span></span><br><span class="line">            index2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> pLast</span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h4><h5 id="第一次面试："><a href="#第一次面试：" class="headerlink" title="第一次面试："></a>第一次面试：</h5><p>面试2020年1月17号， 字节跳动——大数据开发：</p>
<p>算法题：完全二叉树最后一个节点【完全二叉树高度】</p>
<p>kaggle比赛：</p>
<ol>
<li>直接使用哪些特征的平均值进行预测效果如何，为什么一定使用算法模型？</li>
<li>为什么用LGBM？</li>
<li>道路ID作用？比如利用西直门道路的数据来预测朝阳区道路的特征是否具有意义？</li>
<li>特征中含有的是20分位，40分位，60分位，80分位的值，预测要求的是20分位，50分位，80分位的值，如何评估模型好坏。</li>
<li>预测要求的是20分位，50分位，80分位的值，在这6个要预测的值中，哪个效果最差？</li>
<li>特征的重要程度如何评估，决策树中特征选择的标准？</li>
<li>如何处理数据不均衡问题的？</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法与数据结构-剑指offer/" rel="tag"># 算法与数据结构-剑指offer</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/08/Python面试题/" rel="next" title="Python面试题">
                <i class="fa fa-chevron-left"></i> Python面试题
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/29/算法面试题/" rel="prev" title="算法面试题">
                算法面试题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="木木">
            
              <p class="site-author-name" itemprop="name">木木</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-3-1：数组中重复的数字"><span class="nav-number">1.</span> <span class="nav-text">面试题 3.1：数组中重复的数字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-3-2-：不修改数组找出重复的数字"><span class="nav-number">2.</span> <span class="nav-text">面试题 3.2 ：不修改数组找出重复的数字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-4：-二维数组中的查找"><span class="nav-number">3.</span> <span class="nav-text">面试题 4： 二维数组中的查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-5：-替换空格"><span class="nav-number">4.</span> <span class="nav-text">面试题 5： 替换空格</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-6：-从尾到头打印链表"><span class="nav-number">5.</span> <span class="nav-text">面试题 6： 从尾到头打印链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-7：-重建二叉树"><span class="nav-number">6.</span> <span class="nav-text">面试题 7： 重建二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-8：-二叉树的下一个节点"><span class="nav-number">7.</span> <span class="nav-text">面试题 8：  二叉树的下一个节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-9-1：-用两个栈实现队列"><span class="nav-number">8.</span> <span class="nav-text">面试题 9.1： 用两个栈实现队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-9-2：-用两个队列实现一个栈"><span class="nav-number">9.</span> <span class="nav-text">面试题 9.2： 用两个队列实现一个栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-10-1-：斐波那契数列"><span class="nav-number">10.</span> <span class="nav-text">面试题 10.1 ：斐波那契数列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-10-2-：青蛙跳台阶问题"><span class="nav-number">11.</span> <span class="nav-text">面试题 10.2 ：青蛙跳台阶问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-10-3-：变态跳台阶"><span class="nav-number">12.</span> <span class="nav-text">面试题 10.3 ：变态跳台阶</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-10-4-：矩形覆盖"><span class="nav-number">13.</span> <span class="nav-text">面试题 10.4 ：矩形覆盖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-11：旋转数组的最小数字"><span class="nav-number">14.</span> <span class="nav-text">面试题 11：旋转数组的最小数字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-12：矩阵中的路径"><span class="nav-number">15.</span> <span class="nav-text">面试题 12：矩阵中的路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-13：-机器人的运动范围"><span class="nav-number">16.</span> <span class="nav-text">面试题 13： 机器人的运动范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-14：-剪绳子"><span class="nav-number">17.</span> <span class="nav-text">面试题 14： 剪绳子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-15：二进制中-1-的个数"><span class="nav-number">18.</span> <span class="nav-text">面试题 15：二进制中 1 的个数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-16：数值的整数次方"><span class="nav-number">19.</span> <span class="nav-text">面试题 16：数值的整数次方</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-17：-打印从-1-到最大的-n-位数"><span class="nav-number">20.</span> <span class="nav-text">面试题 17： 打印从 1 到最大的 n 位数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-18-1-：删除链表的节点"><span class="nav-number">21.</span> <span class="nav-text">面试题 18.1 ：删除链表的节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-18-2：-删除链表中重复的节点"><span class="nav-number">22.</span> <span class="nav-text">面试题 18.2： 删除链表中重复的节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-19：正则表达式匹配"><span class="nav-number">23.</span> <span class="nav-text">面试题 19：正则表达式匹配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-20：-表示数值的字符串"><span class="nav-number">24.</span> <span class="nav-text">面试题 20： 表示数值的字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-21：调整数组顺序使奇数位于偶数前面"><span class="nav-number">25.</span> <span class="nav-text">面试题 21：调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-22：链表中倒数第-k-个节点"><span class="nav-number">26.</span> <span class="nav-text">面试题 22：链表中倒数第 $k$ 个节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-23：链表中环的入口节点"><span class="nav-number">27.</span> <span class="nav-text">面试题 23：链表中环的入口节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-24：反转链表"><span class="nav-number">28.</span> <span class="nav-text">面试题 24：反转链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-25：合并两个排序的链表"><span class="nav-number">29.</span> <span class="nav-text">面试题 25：合并两个排序的链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-26：树的子结构"><span class="nav-number">30.</span> <span class="nav-text">面试题 26：树的子结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-27：-二叉树的镜像"><span class="nav-number">31.</span> <span class="nav-text">面试题 27： 二叉树的镜像</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-28：对称的二叉树"><span class="nav-number">32.</span> <span class="nav-text">面试题 28：对称的二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-29：-顺时针打印矩阵"><span class="nav-number">33.</span> <span class="nav-text">面试题 29： 顺时针打印矩阵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-30：包含min函数的栈"><span class="nav-number">34.</span> <span class="nav-text">面试题 30：包含min函数的栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-31：栈的压入，弹出序列"><span class="nav-number">35.</span> <span class="nav-text">面试题 31：栈的压入，弹出序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-32-1-：不分行从上到下打印二叉树"><span class="nav-number">36.</span> <span class="nav-text">面试题 32.1 ：不分行从上到下打印二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-32-2-：分行从上到下打印二叉树"><span class="nav-number">37.</span> <span class="nav-text">面试题 32.2 ：分行从上到下打印二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-32-3-：之字形打印二叉树"><span class="nav-number">38.</span> <span class="nav-text">面试题 32.3 ：之字形打印二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-33：二叉搜索树的后序遍历序列"><span class="nav-number">39.</span> <span class="nav-text">面试题 33：二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-34：二叉树中和为某一值的路径"><span class="nav-number">40.</span> <span class="nav-text">面试题 34：二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-35：复杂链表的复制"><span class="nav-number">41.</span> <span class="nav-text">面试题 35：复杂链表的复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-36：二叉搜素树与双向链表（-）"><span class="nav-number">42.</span> <span class="nav-text">面试题 36：二叉搜素树与双向链表（**）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-37：序列化二叉树"><span class="nav-number">43.</span> <span class="nav-text">面试题 37：序列化二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-38：字符串的排序（-）"><span class="nav-number">44.</span> <span class="nav-text">面试题 38：字符串的排序（*）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-39：数组中出现次数超过一半的数字"><span class="nav-number">45.</span> <span class="nav-text">面试题 39：数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-40：最小的k个数"><span class="nav-number">46.</span> <span class="nav-text">面试题 40：最小的k个数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-41：数据流中的中位数"><span class="nav-number">47.</span> <span class="nav-text">面试题 41：数据流中的中位数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-42：连续子数组的最大和"><span class="nav-number">48.</span> <span class="nav-text">面试题 42：连续子数组的最大和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-43：1-n-整数中-1-出现的次数"><span class="nav-number">49.</span> <span class="nav-text">面试题 43：1 ~ n  整数中 1 出现的次数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-44：数字序列中某一位的数字"><span class="nav-number">50.</span> <span class="nav-text">面试题 44：数字序列中某一位的数字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-45：把数组排成最小的数（-）"><span class="nav-number">51.</span> <span class="nav-text">面试题 45：把数组排成最小的数（**）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-46：把数字翻译成字符串-amp-amp-LeetCode-91-解码方法"><span class="nav-number">52.</span> <span class="nav-text">面试题 46：把数字翻译成字符串 &amp;&amp; LeetCode  91. 解码方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-47：礼物的最大价值-amp-amp-LeetCode-64-最小路径和"><span class="nav-number">53.</span> <span class="nav-text">面试题 47：礼物的最大价值 &amp;&amp; LeetCode  64. 最小路径和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-48：最长不含重复字符的子字符串-amp-amp-LeetCode-3-无重复字符串的最长字串"><span class="nav-number">54.</span> <span class="nav-text">面试题 48：最长不含重复字符的子字符串 &amp;&amp; LeetCode 3. 无重复字符串的最长字串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-49：丑数"><span class="nav-number">55.</span> <span class="nav-text">面试题 49：丑数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-50-1：字符串中第一个只出现一次的字符"><span class="nav-number">56.</span> <span class="nav-text">面试题 50.1：字符串中第一个只出现一次的字符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-50-2：字符流中第一个只出现一次的字符"><span class="nav-number">57.</span> <span class="nav-text">面试题 50.2：字符流中第一个只出现一次的字符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-51：数组中的逆序对"><span class="nav-number">58.</span> <span class="nav-text">面试题 51：数组中的逆序对</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-52：两个链表的第一个公共节点"><span class="nav-number">59.</span> <span class="nav-text">面试题 52：两个链表的第一个公共节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-53-1：数字在排序数组中出现的次数"><span class="nav-number">60.</span> <span class="nav-text">面试题 53.1：数字在排序数组中出现的次数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-53-2：0-n-1-中缺失的数字"><span class="nav-number">61.</span> <span class="nav-text">面试题 53.2：0~n-1 中缺失的数字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-53-3：数组中数值和下标相等的元素"><span class="nav-number">62.</span> <span class="nav-text">面试题 53.3：数组中数值和下标相等的元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-54：-二叉搜索树的第-k-大节点"><span class="nav-number">63.</span> <span class="nav-text">面试题 54： 二叉搜索树的第 k 大节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-55-1：-二叉树的深度"><span class="nav-number">64.</span> <span class="nav-text">面试题 55.1： 二叉树的深度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-55-2：-平衡二叉树"><span class="nav-number">65.</span> <span class="nav-text">面试题 55.2： 平衡二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-56-1：-数组中只出现一次的两个数字-amp-amp-LeetCode-260-只出现一次的数字-III"><span class="nav-number">66.</span> <span class="nav-text">面试题 56.1： 数组中只出现一次的两个数字 &amp;&amp; LeetCode 260.只出现一次的数字 III</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-56-2：-数组中唯一只出现一次的数字-amp-amp-LeetCode-137-只出现一次的数字II"><span class="nav-number">67.</span> <span class="nav-text">面试题 56.2： 数组中唯一只出现一次的数字  &amp;&amp;  LeetCode 137.只出现一次的数字II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-57-1：-和为-s-的两个数字"><span class="nav-number">68.</span> <span class="nav-text">面试题 57.1： 和为 s 的两个数字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-57-2：-和为-s-的连续正数序列"><span class="nav-number">69.</span> <span class="nav-text">面试题 57.2： 和为 s 的连续正数序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-58-1：翻转单词顺序"><span class="nav-number">70.</span> <span class="nav-text">面试题 58.1：翻转单词顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-58-2：左旋转字符串"><span class="nav-number">71.</span> <span class="nav-text">面试题 58.2：左旋转字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-59：滑动窗口的最大值"><span class="nav-number">72.</span> <span class="nav-text">面试题 59：滑动窗口的最大值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-60：n-个骰子的点数-amp-amp-LeetCode-60-n-个骰子的点数"><span class="nav-number">73.</span> <span class="nav-text">面试题 60：n 个骰子的点数  &amp;&amp; LeetCode 60. n 个骰子的点数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-61：扑克牌中的顺子"><span class="nav-number">74.</span> <span class="nav-text">面试题 61：扑克牌中的顺子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-62：圆圈中最后剩下的数字"><span class="nav-number">75.</span> <span class="nav-text">面试题 62：圆圈中最后剩下的数字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-63：股票的最大利润-amp-amp-LeetCode-121-买卖股票的最佳时机"><span class="nav-number">76.</span> <span class="nav-text">面试题 63：股票的最大利润 &amp;&amp; LeetCode 121.买卖股票的最佳时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-64：-求-1-2-…-n"><span class="nav-number">77.</span> <span class="nav-text">面试题 64： 求 1+2+…+n</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-65：不用加减乘除做加法"><span class="nav-number">78.</span> <span class="nav-text">面试题 65：不用加减乘除做加法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-66：构建乘积数组"><span class="nav-number">79.</span> <span class="nav-text">面试题 66：构建乘积数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-67：把字符串转换成整数"><span class="nav-number">80.</span> <span class="nav-text">面试题 67：把字符串转换成整数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题-68：树中两个节点的最低公共祖先-amp-amp-LeetCode-235-二叉搜索树的最近公共祖先-amp-amp-LeetCode-236-二叉树的最近公共祖先"><span class="nav-number">81.</span> <span class="nav-text">面试题 68：树中两个节点的最低公共祖先 &amp;&amp; LeetCode 235.二叉搜索树的最近公共祖先  &amp;&amp; LeetCode 236. 二叉树的最近公共祖先</span></a></li></ol><li class="nav-item nav-level-4"><a class="nav-link" href="#面试"><span class="nav-number"></span> <span class="nav-text">面试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#第一次面试："><span class="nav-number">1.</span> <span class="nav-text">第一次面试：</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">木木</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
