<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法与数据结构——程序员代码面试指南,">





  <link rel="alternate" href="/atom.xml" title="木木的博客" type="application/atom+xml">






<meta name="description" content="小知识点异或运算异或运算（无进位相加，相同为0， 不同为1）比正常加减速度快，异或运算的性质  a ⊕ b = b  ⊕ a；a  ⊕  (b  ⊕  c) = (a  ⊕  b)  ⊕  c；0  ⊕ N = N；N ⊕ N = 0交换两个数的值，不申请额外的变量：a = a ^ b, b = a ^ b, a = a ^ b ，在 a, b指向的内存地址不同时（值可以相同），可以这样做。Pyt">
<meta name="keywords" content="算法与数据结构——程序员代码面试指南">
<meta property="og:type" content="article">
<meta property="og:title" content="程序员代码面试指南">
<meta property="og:url" content="http://pl741.github.io/2020/03/01/程序员代码面试指南/index.html">
<meta property="og:site_name" content="木木的博客">
<meta property="og:description" content="小知识点异或运算异或运算（无进位相加，相同为0， 不同为1）比正常加减速度快，异或运算的性质  a ⊕ b = b  ⊕ a；a  ⊕  (b  ⊕  c) = (a  ⊕  b)  ⊕  c；0  ⊕ N = N；N ⊕ N = 0交换两个数的值，不申请额外的变量：a = a ^ b, b = a ^ b, a = a ^ b ，在 a, b指向的内存地址不同时（值可以相同），可以这样做。Pyt">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://pl741.github.io/2020/03/01/程序员代码面试指南/2.jpg">
<meta property="og:updated_time" content="2020-06-05T04:51:25.705Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员代码面试指南">
<meta name="twitter:description" content="小知识点异或运算异或运算（无进位相加，相同为0， 不同为1）比正常加减速度快，异或运算的性质  a ⊕ b = b  ⊕ a；a  ⊕  (b  ⊕  c) = (a  ⊕  b)  ⊕  c；0  ⊕ N = N；N ⊕ N = 0交换两个数的值，不申请额外的变量：a = a ^ b, b = a ^ b, a = a ^ b ，在 a, b指向的内存地址不同时（值可以相同），可以这样做。Pyt">
<meta name="twitter:image" content="http://pl741.github.io/2020/03/01/程序员代码面试指南/2.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'D7ALJV5SO6',
      apiKey: '6e20ed4f9126e4bd7125665a8b2f2a43',
      indexName: 'MUMU',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"找不到关于 ${query} 的文章","hits_stats":"共找到 ${hits} 篇文章，花了 ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://pl741.github.io/2020/03/01/程序员代码面试指南/">





  <title>程序员代码面试指南 | 木木的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">木木的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">木木的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          <!--增加的代码 start-->

          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pl741.github.io/2020/03/01/程序员代码面试指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="木木">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="木木的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">程序员代码面试指南</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-01T14:18:48+08:00">
                2020-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python算法题/" itemprop="url" rel="index">
                    <span itemprop="name">Python算法题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h4><h5 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h5><p>异或运算（<font color="red">无进位相加，相同为0， 不同为1</font>）比正常加减速度快，异或运算的性质  <code>a ⊕ b = b  ⊕ a；a  ⊕  (b  ⊕  c) = (a  ⊕  b)  ⊕  c；0  ⊕ N = N；N ⊕ N = 0</code><br>交换两个数的值，不申请额外的变量：<code>a = a ^ b, b = a ^ b, a = a ^ b</code> ，在 a, b指向的内存地址不同时（值可以相同），可以这样做。Python 中交换两个变量的值 <code>a, b = b, a</code>，加减法交换两个变量的值：<code>a = a + b，b = a - b，a = a - b</code>  </p>
<ol>
<li>数组中只有一种数出现奇数次，其他均出现偶数次，利用时间复杂度 $O(1)$，额外空间复杂度 $O(1)$ 找到出现奇数次的数。<br>练习：<a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a>  <a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137. 只出现一次的数字 II</a>（137题中一个数字出现1次，其他数字出现3次，没看懂使用异或运算的算法）</li>
<li>数组中有两种数出现奇数次，找出这两个数。<br>eor = 0 与数组中所有数都异或一次 ==&gt; eor = 两个出现奇数次的数的异或结果，且eor != 0  ——&gt; eor 的二进制表达中有一位为 1，设k位上为 1，找出数组中所有 k 位为 1 的数，异或这些数的结果为 eor’，则eor’ 一定是其中一个出现奇数次的数。<font color="red">提取一个不等于0的数最右侧的1</font>：位移 for 循环（不快）；（~eor)+1 &amp; eor 即取反加1，再和自己与<br>练习：<a href="https://leetcode-cn.com/problems/single-number-iii/" target="_blank" rel="noopener">260. 只出现一次的数字 III</a><div><div class="fold_hider"><div class="close hider_title">数组中有两种出现奇数次的数</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printOddTimesNum2</span><span class="params">(arr)</span>:</span></span><br><span class="line">	eor = <span class="number">0</span></span><br><span class="line">	eorhasOne = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">		eor ^= i</span><br><span class="line">	rightOne = eor &amp; (~eor + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">		<span class="keyword">if</span> i &amp; rightOne != <span class="number">0</span>:</span><br><span class="line">			eorhasOne ^= i</span><br><span class="line">	<span class="keyword">return</span> eorhasOne, (eor ^ eorhasOne)</span><br></pre></td></tr></table></figure>

</div></div>
</li>
</ol>
<h5 id="求中点"><a href="#求中点" class="headerlink" title="求中点"></a>求中点</h5><p>正常 (L + R)/2 有可能会溢出，可使用 L + ((L-R）&gt;&gt;1)</p>
<h5 id="递归行为时间复杂度"><a href="#递归行为时间复杂度" class="headerlink" title="递归行为时间复杂度"></a>递归行为时间复杂度</h5><p>master公式：$T(N) = a*T(N/b) + O(N^d)$</p>
<script type="math/tex; mode=display">log(b, a) > d 复杂度为 O(N*log(b, a))</script><script type="math/tex; mode=display">log(b, a) = d 复杂度为 O(N^d*log N)</script><script type="math/tex; mode=display">log(b, a) < d 复杂度为 O(N^d)</script><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>排序测试用例：</p>
<ol>
<li>已经排序好的数组</li>
<li>元素的值全部相等或者元素的值近似相等</li>
<li>随机生成的数据</li>
</ol>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>  每次从待排序的数据中选择最小的数，交换待排数组的起始位置与最小元素；再从剩余的未排序数组中选择最小元素，以此类推。<strong><font color="red">每次找最小的值放在i位置</font></strong>。<br>  时间复杂度 $O(N^{2})$，额外空间复杂度 $O(1)$。<strong>特点：在一般情况下或者在平均来看，选择排序在排序过程中交换元素的次数最少。</strong>选择排序的运行时间和数据本身所具有的特点无关，优点：排序过程中，元素交换的总次数是最少的，如果移动元素的成本很大，可以考虑选择排序。缺点：排序过程中元素两两间比较的次数较多。<br><div><div class="fold_hider"><div class="close hider_title">选择排序</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">		minIndex = i</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(arr)):</span><br><span class="line">			<span class="keyword">if</span> arr[j] &lt; arr[minIndex]:</span><br><span class="line">				minIndex = j</span><br><span class="line">		self.swap(arr, i, minIndex)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">	tmp = arr[i]</span><br><span class="line">	arr[i] = arr[j]</span><br><span class="line">	arr[j] = tmp</span><br><span class="line">	print(arr)</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>依次比较两个元素，按照谁打谁放后的规则，每一次循环可以确定最大值。<font color="red">谁大谁往后，每次循环可以确定最大值。</font>时间复杂度 $O(N^{2})$，额外空间复杂度 $O(1)$。<br><div><div class="fold_hider"><div class="close hider_title">冒泡排序</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">			<span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">				<span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">					self.swap(arr, j, j+<span class="number">1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">		tmp = arr[i]</span><br><span class="line">		arr[i] = arr[j]</span><br><span class="line">		arr[j] = tmp</span><br><span class="line">		print(i, j, arr)</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置插入。（有两种将未排数据插入的方式：逐个交换——往前看，若未排序数据小则交换两个数字的位置；逐个后退——从已排序序列末尾开始，若比待排序数据大则往后退）<font color="red">往前看，小交换，0~1范围有序——&gt;0~2范围有序….</font> 时间复杂度 $O(N^{2})$，额外空间复杂度 $O(1)$。<strong>是时间复杂度为</strong>$O(N^2)$<strong>中最好的排序方法</strong>。在数组近乎有序的情况下，插入排序会很快完成排序任务，即若带排序数组有序，则插入排序的时间复杂度为 $O(N)$。算法复杂度与实际的数据状况有关。<br><div><div class="fold_hider"><div class="close hider_title">插入排序</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">			<span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># 往前看</span></span><br><span class="line">				<span class="keyword">if</span> arr[j+<span class="number">1</span>] &lt; arr[j]: <span class="comment"># 小交换</span></span><br><span class="line">					self.swap(arr, j, j+<span class="number">1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">		tmp = arr[i]</span><br><span class="line">		arr[i] = arr[j]</span><br><span class="line">		arr[j] = tmp</span><br><span class="line">		print(i, j, arr)</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h5><ol>
<li>在一个有序数组中，找某个数是否存在，遍历的方法时间复杂度为$O(N)$， 二分法的时间复杂度为$O(\log N)$。<br> 练习：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a>  <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a> <div><div class="fold_hider"><div class="close hider_title">二分法</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSExist</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, arr, num)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">		L = <span class="number">0</span></span><br><span class="line">		R = len(arr) - <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> L &lt; R:</span><br><span class="line">			mid = L + ((R - L) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span> arr[mid] == num:</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">			<span class="keyword">elif</span> arr[mid] &gt; num:</span><br><span class="line">				R = mid - <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				L = mid + <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> arr[L] == num:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

</div></div></li>
<li>在一个有序数组中，找&gt;=某个数最左侧的位置，例如：找到 [1, 1, 1, 1,  2,  2, 2, 2, 3, 3, 3, 4, 4] 数组中大于等于 2 的最左侧的位置。<br>练习： <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a><div><div class="fold_hider"><div class="close hider_title">二分法</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSNearLeft</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">nearestIndex</span><span class="params">(self, arr, value)</span>:</span></span><br><span class="line">	    L = <span class="number">0</span></span><br><span class="line">        R = len(nums) - <span class="number">1</span></span><br><span class="line">        indexL = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">            mid = L + ((R - L) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                R = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                L = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                indexL = mid</span><br><span class="line">                R = mid - <span class="number">1</span></span><br><span class="line">        L = <span class="number">0</span></span><br><span class="line">        R = len(nums) - <span class="number">1</span></span><br><span class="line">        indexR = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">            mid = L + ((R - L &gt;&gt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                L = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                R = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                indexR = mid</span><br><span class="line">                L = mid + <span class="number">1</span></span><br><span class="line">         <span class="keyword">return</span> [indexL, indexR]</span><br></pre></td></tr></table></figure>

</div></div></li>
<li>局部最小值问题，一个无需数组中，任何两个相邻数在数组中不等，找到一个局部最小。<br>练习：<a href="https://www.nowcoder.com/practice/d1c8838fc9e54b89bc10b5b6d2b52157?tpId=101&amp;tqId=33096&amp;tPage=1&amp;rp=1&amp;ru=/ta/programmer-code-interview-guide&amp;qru=/ta/programmer-code-interview-guide/question-ranking" target="_blank" rel="noopener">在数组中找到一个局部最小的位置</a><br>情况一：$ arr[0] &lt; arr[1]$，返回位置 0；情况二：$arr[N-1] &lt; arr[N-2]$，返回位置 $N-1$；情况三：$arr[i-1] &gt; arr[i] &lt; arr[i+1]$，返回位置 $i$。<br>做法：比较 0, 1位置上的数，若$ arr[0] &lt; arr[1]$找到，否则 ==&gt; 比较$N-1， N-2$，若$arr[N-1] &lt; arr[N-2]$找到，否则  ==&gt; 0~N-1 上比存在局部最小  ==&gt; 找到中间位置 mid，比较，若$arr[mid-1] &gt; arr[mid] &lt; arr[mid+1]$找到，否则 ==&gt; 若$arr[mid-1] &lt; arr[mid]$，缩小范围到 0~mid，若$arr[mid+1] &lt; arr[mid]$，缩小范围到 mid~N-1<div><div class="fold_hider"><div class="close hider_title">二分法</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">LocalMin</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">		<span class="keyword">if</span> len(arr) == <span class="number">1</span> <span class="keyword">or</span> arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		N = len(arr)</span><br><span class="line">		<span class="keyword">if</span> arr[N<span class="number">-1</span>] &lt; arr[N<span class="number">-2</span>]:</span><br><span class="line">			<span class="keyword">return</span> N<span class="number">-1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			 L = <span class="number">1</span></span><br><span class="line">			 R = N<span class="number">-2</span></span><br><span class="line">			 <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">			 	mid = L + ((R - L) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">			 	<span class="keyword">if</span> arr[mid] &gt; arr[mid+<span class="number">1</span>]:</span><br><span class="line">			 		L = mid + <span class="number">1</span></span><br><span class="line">			 	<span class="keyword">elif</span> arr[mid] &gt; arr[mid<span class="number">-1</span>]:</span><br><span class="line">			 		R = mid - <span class="number">1</span></span><br><span class="line">			 	<span class="keyword">else</span>:</span><br><span class="line">			 		<span class="keyword">return</span> mid</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

</div></div>
</li>
</ol>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>将两个有序数组归并成一个更大的有序数组，【左边排好序、右边排好序，整体有序】，<font color="red">需要一个新的辅助空间和两个指针，用于比较</font>。时间复杂度 $O(N \log N)$，额外空间复杂度 $O(N)$。<br><div><div class="fold_hider"><div class="close hider_title">归并排序</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span> </span><br><span class="line">		self.mergeSortCore(arr, <span class="number">0</span>, len(arr)<span class="number">-1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">mergeSortCore</span><span class="params">(self, arr, l, r)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> l == r:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">		self.mergeSortCore(arr, l, mid)</span><br><span class="line">		self.mergeSortCore(arr, mid+<span class="number">1</span>, r)</span><br><span class="line">		self.merge(arr, l ,mid, r)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, arr, l, m, r)</span>:</span></span><br><span class="line">		help = []</span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line">		p1 = l</span><br><span class="line">		p2 = m + <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> p1 &lt;= m <span class="keyword">and</span> p2 &lt;= r:</span><br><span class="line">			<span class="keyword">if</span> arr[p1] &lt; arr[p2]:</span><br><span class="line">				help.append(arr[p1])</span><br><span class="line">				p1 += <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				help.append(arr[p2])</span><br><span class="line">				p2 += <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> p1 &lt;= m:</span><br><span class="line">			help.append(arr[p1])</span><br><span class="line">			p1 += <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> p2 &lt;= r:</span><br><span class="line">			help.append(arr[p2])</span><br><span class="line">			p2 += <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(help)):</span><br><span class="line">			arr[l+i] = help[i]</span><br><span class="line">		print(l, m, r, arr)</span><br></pre></td></tr></table></figure>

</div></div><br>归并排序的扩展：小和问题和逆序对问题。<br>例题：<a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a>，<a href="https://www.acwing.com/problem/content/61/" target="_blank" rel="noopener">《剑指 Offer》（第 2 版）第 51 题：计算数组的逆序对</a>，<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a>， <a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a>，<a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a><br>小和问题：在一个数组中，每个数左边比当前数小的数累加起来，求一个数组的小和。换一个思路想：看每个数右边有多少个数比它大，可以将整体进行归并排序，左侧部分小则开始产生小和。<br><div><div class="fold_hider"><div class="close hider_title">小和问题</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallSum</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">smallSum</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		<span class="keyword">return</span> self.mergeSort(arr, <span class="number">0</span>, len(arr)<span class="number">-1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(self, arr, l, r)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> l == r:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">		res = self.mergeSort(arr, l, mid) \</span><br><span class="line">			  + self.mergeSort(arr, mid + <span class="number">1</span>, r) \</span><br><span class="line">			  + self.merge(arr, l, mid, r)</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, arr, l, m, r)</span>:</span></span><br><span class="line">		help = []</span><br><span class="line">		p1 = l</span><br><span class="line">		p2 = m + <span class="number">1</span></span><br><span class="line">		res = <span class="number">0</span></span><br><span class="line">		<span class="keyword">while</span> p1 &lt;= m <span class="keyword">and</span> p2 &lt;= r:</span><br><span class="line">			<span class="keyword">if</span> arr[p1] &lt; arr[p2]:</span><br><span class="line">				help.append(arr[p1])</span><br><span class="line">				res += arr[p1] * (r - p2 + <span class="number">1</span>)</span><br><span class="line">				p1 += <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				help.append(arr[p2])</span><br><span class="line">				p2 += <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> p1 &lt;= m:</span><br><span class="line">			help.append(arr[p1])</span><br><span class="line">			p1 += <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> p2 &lt;= r:</span><br><span class="line">			help.append(arr[p2])</span><br><span class="line">			p2 += <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(help)):</span><br><span class="line">			arr[l+i] = help[i]</span><br><span class="line">		print(l, m, r, arr, res)</span><br><span class="line">		<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div><br>逆序对问题，在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对。<br>练习：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a>  <a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a>   <a href="https://leetcode-cn.com/problems/k-inverse-pairs-array/" target="_blank" rel="noopener">629. K个逆序对数组</a><br><div><div class="fold_hider"><div class="close hider_title">逆序对问题</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> nums == <span class="literal">None</span> <span class="keyword">or</span> len(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.mergeSort(nums, <span class="number">0</span>, len(nums)<span class="number">-1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(self, nums, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = l + ((r-l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        res = self.mergeSort(nums, l, mid) + self.mergeSort(nums, mid+<span class="number">1</span>, r) + self.merge(nums, l, mid, r)</span><br><span class="line">        <span class="keyword">return</span> res </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, arr, l, m, r)</span>:</span></span><br><span class="line">        help = []</span><br><span class="line">        p1 = l</span><br><span class="line">        p2 = m + <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt;= m <span class="keyword">and</span> p2 &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> arr[p1] &gt; arr[p2]:</span><br><span class="line">                res += (m - p1 + <span class="number">1</span>)</span><br><span class="line">                help.append(arr[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                help.append(arr[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt;= m:</span><br><span class="line">            help.append(arr[p1])</span><br><span class="line">            p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p2 &lt;= r:</span><br><span class="line">            help.append(arr[p2])</span><br><span class="line">            p2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(help)):</span><br><span class="line">            arr[l+i] = help[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><p>堆结构是用数组实现的完全二叉树结构(满二叉树，在从左往右依次变满，用连续数组实现，位置关系：节点 i 的左孩子是 $2<em>i+1$，节点 i 的右孩子$2</em>i+2$，节点 i 的父节点$(i-1)/2$ 向下取整），完全二叉树中如果每棵子数的最大值都在顶部就是大根堆 (例如：数组 [6, 3, 5, 1, 2, 4] 是大根堆)，完全二叉树中如果每棵子数的最小值都在顶部就是小根堆，优先级队列结构即堆结构。<br>堆排序过程：</p>
<ol>
<li>先让整个数组都变成大根堆结构，建堆过程：heapsize 纪录堆的大小<br>1）从上到下的方法：heapInsert 方法，时间复杂度为 $O(N \log N)$，用户一个数一个数的依次给你；若用户一次性将数据给你，通过从下往上每个数都 heapify，则建立大根堆的时间复杂度可以优化为 $O(N)$。<br>2）从下到上的方法：heapify 方法，时间复杂度为 $O(N \log N)$</li>
<li>把堆的最大值和堆末尾的值交换，然后减少堆到的大小后，再去调整为大根堆，周而复始，时间复杂度为 $O(N \log N)$</li>
<li>堆大小减小为 0 后，排序完成。<img src="/2020/03/01/程序员代码面试指南/2.jpg">  
<div><div class="fold_hider"><div class="close hider_title">堆排序</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">heapsort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">			self.heapInsert(arr, i) <span class="comment"># arr数组上0~i是大根堆</span></span><br><span class="line">		heapsize = len(arr) - <span class="number">1</span></span><br><span class="line">		self.swap(arr, <span class="number">0</span>, heapsize)</span><br><span class="line">		<span class="keyword">while</span> heapsize &gt; <span class="number">0</span>:</span><br><span class="line">			self.heapify(arr, <span class="number">0</span>, heapsize)</span><br><span class="line">			heapsize -= <span class="number">1</span></span><br><span class="line">			self.swap(arr, <span class="number">0</span>, heapsize)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">heapInsert</span><span class="params">(self, arr, index)</span>:</span></span><br><span class="line">		print(<span class="string">'开始heapInsert'</span>, index, (index - <span class="number">1</span>)//<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">while</span> (index<span class="number">-1</span>)//<span class="number">2</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[index] &gt; arr[(index - <span class="number">1</span>)//<span class="number">2</span>]:</span><br><span class="line">			self.swap(arr, index, (index<span class="number">-1</span>)//<span class="number">2</span>)</span><br><span class="line">			index = (index<span class="number">-1</span>)//<span class="number">2</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(self, arr, index, heapsize)</span>:</span></span><br><span class="line">		print(<span class="string">'开始heapify'</span>, index, heapsize)</span><br><span class="line">		left = <span class="number">2</span> * index + <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> left &lt; heapsize:</span><br><span class="line">			<span class="keyword">if</span> left + <span class="number">1</span> &lt; heapsize <span class="keyword">and</span> arr[left+<span class="number">1</span>] &gt; arr[left]:</span><br><span class="line">				largest = left + <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				largest = left</span><br><span class="line">			<span class="keyword">if</span> arr[largest] &lt; arr[index]:</span><br><span class="line">				largest = index</span><br><span class="line">			<span class="keyword">if</span> largest == index:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			self.swap(arr, largest, index)</span><br><span class="line">			index = largest</span><br><span class="line">			left = <span class="number">2</span> * index + <span class="number">1</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">		tmp = arr[i]</span><br><span class="line">		arr[i] = arr[j]</span><br><span class="line">		arr[j] = tmp</span><br><span class="line">		print(i, j, arr)</span><br><span class="line">HeapSort().heapsort([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

</div></div>
</li>
</ol>
<p>$Python$ 中 $heapq$ 模块基本实现最小堆：<br><div><div class="fold_hider"><div class="close hider_title">heapq模块基本实现最小堆</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">heap = [] <span class="comment">#创建了一个空堆</span></span><br><span class="line">heappush(heap,item) <span class="comment">#往堆中插入一条新的值</span></span><br><span class="line">item = heappop(heap) <span class="comment">#从堆中弹出最小值</span></span><br><span class="line">item = heap[<span class="number">0</span>] <span class="comment">#查看堆中最小值，不弹出</span></span><br><span class="line">heapify(x) <span class="comment">#以线性时间讲一个列表转化为堆</span></span><br><span class="line">item = heapreplace(heap,item) <span class="comment">#弹出并返回最小值，然后将heapqreplace方法中item的值插入到堆中</span></span><br><span class="line">heappushpop() <span class="comment">#顾名思义，将值插入到堆中同时弹出堆中的最小值。</span></span><br><span class="line">merge(*iterables) <span class="comment">#合并多个堆然后输出</span></span><br><span class="line">nlargest(n , iterbale, key=<span class="literal">None</span>) <span class="comment">#从堆中找出做大的N个数，key的作用和sorted( )方法里面的key类似，用列表元素的某个属性和函数作为关键字。</span></span><br><span class="line">nsmallest(n, iterable, key=<span class="literal">None</span>) <span class="comment">#找到堆中最小的N个数用法同上。</span></span><br></pre></td></tr></table></figure>

</div></div><br>修改为最大堆：<br><div><div class="fold_hider"><div class="close hider_title">大根堆</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.val &gt; other.val</span><br><span class="line">q = []</span><br><span class="line">heapq.heappush(q, MyObject(<span class="number">50</span>))</span><br><span class="line">heapq.heappush(q, MyObject(<span class="number">40</span>))</span><br><span class="line">heapq.heappush(q, MyObject(<span class="number">30</span>))</span><br><span class="line">heapq.heappush(q, MyObject(<span class="number">20</span>))</span><br><span class="line">heapq.heappush(q, MyObject(<span class="number">200</span>))</span><br><span class="line">obj = heapq.heappop(q)</span><br><span class="line">print(obj.val)  <span class="comment"># 200</span></span><br><span class="line">heapq.heapreplace(q, MyObject(<span class="number">47</span>))  <span class="comment"># 将最大值替换为47</span></span><br><span class="line">print(heapq.heappop(q).val)  <span class="comment"># 47</span></span><br><span class="line">print(q[<span class="number">0</span>].val) <span class="comment"># 40</span></span><br></pre></td></tr></table></figure>

</div></div><br>堆排序扩展题目：已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过 k，并且 k 相对于数组来说比较小。<br><div><div class="fold_hider"><div class="close hider_title">扩展</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>不改进的快速排序：</p>
<ol>
<li><p>把数组范围中的最后一个数作为划分值，然后把数组通过荷兰国旗问题分成三个部分：左侧 &lt; 划分值、中间 == 划分值、右侧 &gt; 划分值。</p>
<ol>
<li><p><font color="red">Partition​ 问题</font>：给定一个数组 $arr$ 和一个数 $num$，请把小于等于 $num$ 的数放在数组的左边，大于 $num$ 的数放在数组的右边，要求额外空间复杂度 $O(1)$， 时间复杂度 $O(N)$<br>用一个变量表示 $\le$ 区域，$i$ ：表示从左往右遍历的变量 （当前数）<br>①  $arr[i] \le num$：当前数和 $\le 区域$ 下一个数交换， $\le 区域$ 扩一个位置，当前数跳下一个<br>②  $arr[i] \gt num$：当前数直接跳下一个<br>剑指offer：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题39. 数组中出现次数超过一半的数字</a></p>
<div><div class="fold_hider"><div class="close hider_title">partition问题</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

</div></div>
</li>
<li><p><font color="red">荷兰国旗问题</font>：给定一个数组 $arr$ 和一个数 $num$，请把小于 $num$ 的数放在数组的左边，等于 $num$ 的数放在数组的中间，大于 $num$ 的数放在数组的右边，要求额外空间复杂度 $O(1)$， 时间复杂度 $O(N)$。<br>用一个变量表示左边界 $\lt 区域$， 一个变量表示右边界 $\gt 区域$，$i$ ：表示从左往右遍历的变量 （当前数）<br>①  $arr[i] \lt num$：当前数和 $\lt 区域$ 下一个数交换， $\lt 区域$ 扩一个位置，当前数跳下一个<br>②  $arr[i] = num$：当前数直接跳下一个<br>③  $arr[i] \gt num$：当前数和 $\gt 区域$ 前一个数交换， $\gt 区域$ 左扩一个位置，当前数定在原地<br>④  当前数 == $\gt 区域$左边界时停止</p>
<div><div class="fold_hider"><div class="close hider_title">荷兰国旗问题</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">NetherlandsFlag</span>:</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, arr, l, r, p)</span>:</span></span><br><span class="line"> 		less = l - <span class="number">1</span></span><br><span class="line"> 		more = r + <span class="number">1</span></span><br><span class="line"> 		<span class="keyword">while</span> l &lt; more:</span><br><span class="line"> 			<span class="keyword">if</span> arr[l] &lt; p:</span><br><span class="line"> 				self.swap(arr, l, less+<span class="number">1</span>)</span><br><span class="line"> 				less += <span class="number">1</span></span><br><span class="line"> 				l += <span class="number">1</span></span><br><span class="line"> 			<span class="keyword">elif</span> arr[l] &gt; p:</span><br><span class="line"> 				self.swap(arr, more<span class="number">-1</span>, l)</span><br><span class="line"> 				more -= <span class="number">1</span></span><br><span class="line"> 			<span class="keyword">else</span>:</span><br><span class="line"> 				l += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> [less, more]</span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line"> 		tmp = arr[i]</span><br><span class="line"> 		arr[i] = arr[j]</span><br><span class="line"> 		arr[j] = tmp</span><br><span class="line"> 		print(arr, i, j)</span><br></pre></td></tr></table></figure>

</div></div>
</li>
</ol>
</li>
<li><p>对左侧范围和右侧范围，递归执行<br> 不改进的快速排序：划分值越靠近两侧，复杂度越高；划分值越靠近中间，复杂度越低。数据越有序，不改进的快速排序复杂度越高，最差情况：当数据有序时，时间复杂度为 $O(N^{2})$；好情况：每次划分值处于相当中间的位置，时间复杂度 $O(N \log N)$<br> 改进的快速排序（随机快速排序）：</p>
<ol>
<li>在数组范围中，等概率随机选一个数作为划分值，然后把数组通过荷兰国旗问题分成三个部分：左侧 &lt; 划分值、中间 == 划分值、右侧 &gt; 划分值。</li>
<li>对左侧范围和右侧范围，递归执行</li>
<li>时间复杂度为 $O(N \log N)$【所有情况下期望】，额外空间复杂度 $O(\log N)$【期望上的长期收敛】（好情况：每次以几乎二分递归的方式，中间数是树的高度 $\log N$，坏情况：中点特别偏，树多大，栈压多少层 $N$）<div><div class="fold_hider"><div class="close hider_title">快速排序</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		self.quickSortCore(arr, <span class="number">0</span>, len(arr)<span class="number">-1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">quickSortCore</span><span class="params">(self, arr, l, r)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> l &lt; r:</span><br><span class="line">			p = self.partition(arr, l, r)</span><br><span class="line">			print(l, r, p)</span><br><span class="line">			self.quickSortCore(arr, l, p[<span class="number">0</span>])</span><br><span class="line">			self.quickSortCore(arr, p[<span class="number">1</span>]+<span class="number">1</span>, r)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, arr, l, r)</span>:</span></span><br><span class="line">		print(l, r)</span><br><span class="line">		less = l - <span class="number">1</span></span><br><span class="line">		more = r</span><br><span class="line">		<span class="keyword">while</span> l &lt; more:</span><br><span class="line">			<span class="keyword">if</span> arr[l] &lt; arr[r]:</span><br><span class="line">				self.swap(arr, less+<span class="number">1</span>, l)</span><br><span class="line">				l += <span class="number">1</span></span><br><span class="line">				less += <span class="number">1</span></span><br><span class="line">			<span class="keyword">elif</span> arr[l] &gt; arr[r]:</span><br><span class="line">				self.swap(arr, more<span class="number">-1</span>, l)</span><br><span class="line">				more -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				l += <span class="number">1</span></span><br><span class="line">		self.swap(arr, more, r)</span><br><span class="line">		<span class="keyword">return</span> [less, more]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">		temp = arr[i]</span><br><span class="line">		arr[i] = arr[j]</span><br><span class="line">		arr[j] = temp</span><br><span class="line">		print(arr)</span><br></pre></td></tr></table></figure>

</div></div>
</li>
</ol>
</li>
</ol>
<h5 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h5><p>桶排序思想下的排序都是不基于比较的排序，时间复杂度 $O(N)$，额外空间复杂度 $O(M)$</p>
<ol>
<li>计数排序</li>
<li>基数排序</li>
</ol>
<h4 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h4><h5 id="面试题1：设计一个有-getMin-功能的栈"><a href="#面试题1：设计一个有-getMin-功能的栈" class="headerlink" title="面试题1：设计一个有 getMin 功能的栈"></a>面试题1：设计一个有 getMin 功能的栈</h5><p>题目：设计一个特殊栈：在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。pop、push、getMin操作的时间复杂度都是O(1)。<br>练习：<a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a>，<a href="https://leetcode-cn.com/problems/min-stack-lcci/" target="_blank" rel="noopener">面试题 03.02. 栈的最小值</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.stackData = []</span><br><span class="line">		self.stackMin = []</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">		self.stackData.append(x)</span><br><span class="line">		<span class="keyword">if</span> self.stackMin == [] <span class="keyword">or</span> self.stackMin[<span class="number">-1</span>] &gt;= x:</span><br><span class="line">			self.stackMin.append(x)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> self.stackData.pop() == self.stackMin[<span class="number">-1</span>]:</span><br><span class="line">			self.stackMin.pop()</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.stackMin[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题2：由两个栈组成的队列"><a href="#面试题2：由两个栈组成的队列" class="headerlink" title="面试题2：由两个栈组成的队列"></a>面试题2：由两个栈组成的队列</h5><p>题目：用两个栈实现一个队列，支持队列的基本操作（add,poll,peek）<br>练习：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">面试题09. 用两个栈实现队列</a>，<a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.stackPush = []</span><br><span class="line">		self.stackPop = []</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value)</span>:</span></span><br><span class="line">		self.stackPush.append(value)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> self.stackPop != []:</span><br><span class="line">			<span class="keyword">return</span> self.stackPop.pop()</span><br><span class="line">		<span class="keyword">elif</span> self.stackPush == []:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">while</span> self.stackPush != []:</span><br><span class="line">				self.stackPop.append(self.stackPush.pop())</span><br><span class="line">			<span class="keyword">return</span> self.stackPop.pop()</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题3：如何仅用递归函数和栈操作逆序一个栈-★"><a href="#面试题3：如何仅用递归函数和栈操作逆序一个栈-★" class="headerlink" title="面试题3：如何仅用递归函数和栈操作逆序一个栈  ★"></a>面试题3：如何仅用递归函数和栈操作逆序一个栈  ★</h5><p>递归函数一：将栈stack的栈底元素返回并移除<br>递归函数二：逆序一个栈<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, n, stack)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> stack == []:</span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">    i = self.getAndRemoveLastElement(stack)</span><br><span class="line">    self.reverse(n<span class="number">-1</span>, stack)</span><br><span class="line">    stack.append(str(i))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(stack)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getAndRemoveLastElement</span><span class="params">(self, stack)</span>:</span></span><br><span class="line">    value = stack.pop()</span><br><span class="line">    <span class="keyword">if</span> stack == []:</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      last = self.getAndRemoveLastElement(stack)</span><br><span class="line">      stack.append(value)</span><br><span class="line">      <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题4：猫狗队列"><a href="#面试题4：猫狗队列" class="headerlink" title="面试题4：猫狗队列"></a>面试题4：猫狗队列</h5><h5 id="面试题5：用一个栈实现另一个栈的排序-★"><a href="#面试题5：用一个栈实现另一个栈的排序-★" class="headerlink" title="面试题5：用一个栈实现另一个栈的排序   ★"></a>面试题5：用一个栈实现另一个栈的排序   ★</h5><p>题目：只准许申请一个栈，从顶到底按照从大到小的顺序排序<br>练习：<a href="https://leetcode-cn.com/problems/sort-of-stacks-lcci/" target="_blank" rel="noopener">面试题 03.05. 栈排序</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sortStack</span><span class="params">(self, n, stack)</span>:</span></span><br><span class="line">    help = []</span><br><span class="line">    <span class="keyword">while</span> stack != []:</span><br><span class="line">      value = stack.pop()</span><br><span class="line">      <span class="keyword">while</span> help != [] <span class="keyword">and</span> help[<span class="number">-1</span>] &lt; value:</span><br><span class="line">        stack.append(help.pop())</span><br><span class="line">      help.append(value)</span><br><span class="line">    <span class="keyword">while</span> help != []:</span><br><span class="line">      stack.append(str(help.pop()))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(stack[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题6：用栈来解决汉诺塔问题"><a href="#面试题6：用栈来解决汉诺塔问题" class="headerlink" title="面试题6：用栈来解决汉诺塔问题"></a>面试题6：用栈来解决汉诺塔问题</h5><h5 id="面试题7：生成窗口最大值数组-★"><a href="#面试题7：生成窗口最大值数组-★" class="headerlink" title="面试题7：生成窗口最大值数组   ★"></a>面试题7：生成窗口最大值数组   ★</h5><p>题目：有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。如果数组长度为n，窗口大小为w，则一共产生n-w+1个窗口的最大值。<br>练习：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a><br>解题：利用双端队列实现窗口最大值的更新。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">1</span> <span class="keyword">or</span> k &lt; <span class="number">1</span> <span class="keyword">or</span> len(nums) &lt; k:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        qmax = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">while</span> qmax <span class="keyword">and</span> nums[qmax[<span class="number">-1</span>]] &lt;= nums[i]:</span><br><span class="line">                qmax.pop()</span><br><span class="line">            qmax.append(i)</span><br><span class="line">            <span class="keyword">if</span> qmax[<span class="number">0</span>] == i- k:</span><br><span class="line">                qmax.popleft()</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k<span class="number">-1</span>:</span><br><span class="line">                res.append(nums[qmax[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题8：单调栈结构-★"><a href="#面试题8：单调栈结构-★" class="headerlink" title="面试题8：单调栈结构   ★"></a>面试题8：单调栈结构   ★</h5><p>题目：给定一个不含有重复值的数组arr，找到每一个i位置左边和右边离i位置最近且值比arr[i]小的位置。返回所有位置相应的信息 。<br>练习：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a><br>解题：准备一个栈，存放元素在数组中的位置。 如果找到每一个i位置左边和右边离i位置最近且值比arr[i]小的位置，那么需要让stack从栈顶到栈底的位置所代表的值是严格递减的；如果找到每一个i位置左边和右边离i位置最近且值比arr[i]大的位置，那么需要让stack从栈顶到栈底的位置所代表的值是严格递增的。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getnearestsmaller</span><span class="params">(self, n, nums)</span>:</span></span><br><span class="line">    res = [[<span class="number">-1</span>, <span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">      <span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>]] &gt; nums[i]:</span><br><span class="line">        value = stack.pop()</span><br><span class="line">        left = stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        res[value] = [left, i]</span><br><span class="line">      stack.append(i)</span><br><span class="line">    <span class="keyword">while</span> stack != []:</span><br><span class="line">      value = stack.pop()</span><br><span class="line">      left = stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">      res[value] = [left, <span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div></p>
<p>进阶问题：给定一个可能含有重复值的数组arr，找到每一个i位置左边和右边离i位置最近且值比arr[i]小的位置。返回所有位置相应的信息。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getNearsLess</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">		res = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">		stack = []</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">			<span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>][<span class="number">0</span>]] &gt; nums[i]:</span><br><span class="line">				value = stack.pop()</span><br><span class="line">				left = stack[<span class="number">-1</span>][<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">				<span class="keyword">for</span> j <span class="keyword">in</span> value:</span><br><span class="line">					res[j] = [left, i]</span><br><span class="line">			<span class="keyword">if</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>][<span class="number">0</span>]] == nums[i]:</span><br><span class="line">				stack[<span class="number">-1</span>].append(i)</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				stack.append([i])</span><br><span class="line">		<span class="keyword">while</span> stack != []:</span><br><span class="line">			value = stack.pop()</span><br><span class="line">			left = stack[<span class="number">-1</span>][<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">			<span class="keyword">for</span> j <span class="keyword">in</span> value:</span><br><span class="line">				res[j] = [left, <span class="number">-1</span>]</span><br><span class="line">		<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题9：求最大子矩阵的大小-★"><a href="#面试题9：求最大子矩阵的大小-★" class="headerlink" title="面试题9：求最大子矩阵的大小   ★"></a>面试题9：求最大子矩阵的大小   ★</h5><p>题目：给定一个整型矩阵map，其中的值只有0和1两种，求其中全是1的所有矩形区域中，最大的矩形区域为1的数量。<br>练习：<a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85. 最大矩形</a><br>解题：以矩形的每一行为底，统计以当前行作为底的情况下，每个位置往上1的数量，使用高度数组height表示，并利用每次更新后的height数组求出以当前行为底的情况下，最大矩形。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        rows = len(matrix)</span><br><span class="line">        cols = len(matrix[<span class="number">0</span>])</span><br><span class="line">        heights = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(cols)]</span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    heights[j] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    heights[j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[<span class="number">-1</span>]] &gt;= heights[j]:</span><br><span class="line">                    index = stack.pop()</span><br><span class="line">                    k = stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">                    res = max(res, heights[index]*(j-k<span class="number">-1</span>))</span><br><span class="line">                stack.append(j)</span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                index = stack.pop()</span><br><span class="line">                k = stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">                res = max(res, heights[index]*(cols-k<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题10：最大值减去最小值小于或等于-num-的子数组数量"><a href="#面试题10：最大值减去最小值小于或等于-num-的子数组数量" class="headerlink" title="面试题10：最大值减去最小值小于或等于 num 的子数组数量"></a>面试题10：最大值减去最小值小于或等于 num 的子数组数量</h5><p>题目： 给定数组arr和整数num，共返回有多少个子数组满足如下情况：max(arr[i..j]) - min(arr[i..j]) &lt;= num；max(arr[i..j])表示子数组arr[i..j]中的最大值，min(arr[i..j])表示子数组arr[i..j]中的最小值。<br>解法：使用两个双端队列，qmax维护子窗口数组的最大值，qmin维护子窗口数组的最小值。 如果子数组arr[i..j]满足条件，即max(arr[i..j])-min(arr[i..j])&lt;=num，那么arr[i..j]中的每一个子数组，即arr[k..l]（i≤k≤l≤j）都满足条件； 如果子数组arr[i..j]不满足条件，那么所有包含arr[i..j]的子数组，即arr[k..l]（k≤i≤j≤l）都不满足条件。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getNum</span><span class="params">(self, nums, n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span> <span class="keyword">or</span> n &lt; <span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    qmax = []</span><br><span class="line">    qmin = []</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">      <span class="keyword">while</span> j &lt; len(nums):</span><br><span class="line">        <span class="keyword">while</span> qmax <span class="keyword">and</span> nums[qmax[<span class="number">-1</span>]] &lt;= nums[j]:</span><br><span class="line">          qmax.pop()</span><br><span class="line">        qmax.append(j)</span><br><span class="line">        <span class="keyword">while</span> qmin <span class="keyword">and</span> nums[qmin[<span class="number">-1</span>]] &gt;= nums[j]:</span><br><span class="line">          qmin.pop()</span><br><span class="line">        qmin.append(j)</span><br><span class="line">        <span class="keyword">if</span> nums[qmax[<span class="number">0</span>]] - nums[qmin[<span class="number">0</span>]] &gt; n:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">      res += j -i</span><br><span class="line">      <span class="keyword">if</span> qmax[<span class="number">0</span>] == i:qmax.pop(<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">if</span> qmin[<span class="number">0</span>] == i:qmin.pop(<span class="number">0</span>)</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题11：可见的山峰对数量"><a href="#面试题11：可见的山峰对数量" class="headerlink" title="面试题11：可见的山峰对数量"></a>面试题11：可见的山峰对数量</h5><p>题目： 一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度。3-&gt;1-&gt;2-&gt;4-&gt;5-&gt;3方向叫  作next方向（逆时针），3-&gt;5-&gt;4-&gt;2-&gt;1-&gt;3方向叫作last方向（  顺时针。<br>要求：arr长度为N，没有重复值的情况下时间复杂度达到O(1)，可能有重复值的情况下时间复杂度请达到O(N)。<br>原问题：数组中没有重复值。可见山峰对的数量可以由公式得到。小找大原则找到的山峰对的数量就是总的可见山峰对数量。公式：2*i-3对。<br>进阶问题： 给定一个不含有负数但可能含有重复值的数组arr，返回有多少对山峰能够相互看见。 单调栈。<br>练习：<a href="https://www.nowcoder.com/practice/16d1047e9fa54cea8b5170b156d89e38?tpId=101&amp;tqId=33173&amp;tPage=6&amp;rp=1&amp;ru=%2Fta%2Fprogrammer-code-interview-guide&amp;qru=%2Fta%2Fprogrammer-code-interview-guide%2Fquestion-ranking" target="_blank" rel="noopener">可见的山峰对数量</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    self.val = x</span><br><span class="line">    self.times = <span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getVisibleNum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    size = len(nums)</span><br><span class="line">    maxIndex = nums.index(max(nums))</span><br><span class="line">    stack = []</span><br><span class="line">    stack.append(Record(nums[maxIndex]))</span><br><span class="line">    index = maxIndex + <span class="number">1</span> <span class="keyword">if</span> maxIndex &lt; size - <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index != maxIndex:</span><br><span class="line">      <span class="keyword">while</span> stack[<span class="number">-1</span>].val &lt; nums[index]:</span><br><span class="line">        k = stack.pop().times</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>: res += <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>: res += <span class="number">2</span> * k + (k*(k<span class="number">-1</span>)//<span class="number">2</span>)</span><br><span class="line">      <span class="keyword">if</span> stack[<span class="number">-1</span>].val == nums[index]:</span><br><span class="line">        stack[<span class="number">-1</span>].times += <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        stack.append(Record(nums[index]))</span><br><span class="line">      index = index + <span class="number">1</span> <span class="keyword">if</span> index &lt; size <span class="number">-1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> len(stack) &gt; <span class="number">2</span>:</span><br><span class="line">      k = stack.pop().times</span><br><span class="line">      <span class="keyword">if</span> k == <span class="number">1</span>: res += <span class="number">2</span></span><br><span class="line">      <span class="keyword">else</span>: res += <span class="number">2</span> * k + (k*(k<span class="number">-1</span>)//<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> len(stack) == <span class="number">2</span>:</span><br><span class="line">      k = stack.pop().times</span><br><span class="line">      <span class="keyword">if</span> stack[<span class="number">-1</span>].times == <span class="number">1</span>:res += k</span><br><span class="line">      <span class="keyword">else</span>: res += <span class="number">2</span>*k</span><br><span class="line">      <span class="keyword">if</span> k != <span class="number">1</span>:res += (k*(k<span class="number">-1</span>)//<span class="number">2</span>)</span><br><span class="line">    k = stack.pop().times</span><br><span class="line">    res += (k*(k<span class="number">-1</span>)//<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="指标A最大"><a href="#指标A最大" class="headerlink" title="指标A最大"></a>指标A最大</h5><p>题目：数组中累积和与最小值的乘积，叫做指标A，请返回子数组中指标A最大的值。<br>技巧：快速得到[a, …, b]范围上的累加和——数据预处理生成一个前缀和数组——sum[a, .., b] = sum[b] - sum[a-1]<br>解题：单调栈<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">IndexA</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">		pre_sum = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">		pre_sum[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">			pre_sum[i] = pre_sum[i<span class="number">-1</span>] + nums[i]</span><br><span class="line">		maxA = float(<span class="string">'-inf'</span>)</span><br><span class="line">		stack = []</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">			<span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>]] &gt;= nums[i]:</span><br><span class="line">				index = stack.pop()</span><br><span class="line">				left = stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">				tmp = <span class="number">0</span> <span class="keyword">if</span> left &lt; <span class="number">0</span> <span class="keyword">else</span> pre_sum[left]</span><br><span class="line">				maxA = max(maxA, nums[index]*(pre_sum[i<span class="number">-1</span>]-tmp))</span><br><span class="line">			stack.append(i)</span><br><span class="line">		<span class="keyword">while</span> stack:</span><br><span class="line">			index = stack.pop()</span><br><span class="line">			left = stack[<span class="number">-1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">			tmp = <span class="number">0</span> <span class="keyword">if</span> left &lt; <span class="number">0</span> <span class="keyword">else</span> pre_sum[left]</span><br><span class="line">			maxA = max(maxA, nums[index]*(pre_sum[len(nums)<span class="number">-1</span>]-tmp))</span><br><span class="line">		<span class="keyword">return</span> maxA</span><br></pre></td></tr></table></figure>

</div></div></p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h5 id="面试题1：打印两个有序链表的公共部分"><a href="#面试题1：打印两个有序链表的公共部分" class="headerlink" title="面试题1：打印两个有序链表的公共部分"></a>面试题1：打印两个有序链表的公共部分</h5><p>题目：给定两个有序链表的头指针head1和head2，打印两个链表的公共部分。<br>解题：有序链表，从两个链表的头开始进行，若head1的值小于head2，则head1往下移动，若大于，head2往下移动，若相等打印，一起移动。<br>练习：<a href="https://www.nowcoder.com/practice/8943eea40dbb4185b187d80fd050fee9?tpId=101&amp;tqId=33116&amp;tPage=1&amp;rp=1&amp;ru=/ta/programmer-code-interview-guide&amp;qru=/ta/programmer-code-interview-guide/question-ranking" target="_blank" rel="noopener">打印两个有序链表的公共部分</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printCommonPart</span><span class="params">(self, head1, head2)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> head1 != <span class="literal">None</span> <span class="keyword">and</span> head2 != <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">if</span> head1.val &gt; head2.val:</span><br><span class="line">        head2 = head2.next</span><br><span class="line">      <span class="keyword">elif</span> head1.val &lt; head2.val:</span><br><span class="line">        head1 = head1.next</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        res.append(str(head1.val))</span><br><span class="line">        head1 = head1.next</span><br><span class="line">        head2 = head2.next</span><br><span class="line">    print(<span class="string">' '</span>.join(res)) <span class="keyword">if</span> res <span class="keyword">else</span> print(<span class="string">'None'</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题2：在单链表和双链表中删除倒数第-k-个节点"><a href="#面试题2：在单链表和双链表中删除倒数第-k-个节点" class="headerlink" title="面试题2：在单链表和双链表中删除倒数第 k 个节点"></a>面试题2：在单链表和双链表中删除倒数第 k 个节点</h5><p>题目： 一个可以删除单链表中倒数第K个节点，另一个可以删除双链表中倒数第K个节点。<br>练习：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a><br>解题： 如果链表长度为N，要删除倒数第K个节点，倒数第K个节点的前一个节点就是第N-K个节点。在第一次遍历后，K的值变为K-N。第二次遍历时，K的值不断加1，加到0就停止遍历，第二次遍历当然会停到第N-K个节点的位置 (0-(K-N)=N-K)。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> k &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node != <span class="literal">None</span>:</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head.next</span><br><span class="line">        <span class="keyword">elif</span> k &lt; <span class="number">0</span>:</span><br><span class="line">            node = head</span><br><span class="line">            <span class="keyword">while</span> k+<span class="number">1</span> != <span class="number">0</span>:</span><br><span class="line">                node = node.next</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            node.next = node.next.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

</div></div></p>
<p>双链表：与单链表基本相同<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> k &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node != <span class="literal">None</span>:</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            head = head.next</span><br><span class="line">            head.last = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">            node = head</span><br><span class="line">            <span class="keyword">while</span> k+<span class="number">1</span> != <span class="number">0</span>:</span><br><span class="line">                node = node.next</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            newNext = node.next.next</span><br><span class="line">            node.next = newNext</span><br><span class="line">            <span class="keyword">if</span> newNext != <span class="literal">None</span>:</span><br><span class="line">                newNext.last = node</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题3：删除链表的中间节点和-a-b-处的节点"><a href="#面试题3：删除链表的中间节点和-a-b-处的节点" class="headerlink" title="面试题3：删除链表的中间节点和 a/b 处的节点"></a>面试题3：删除链表的中间节点和 a/b 处的节点</h5><p>题目：删除链表的中间节点。如果链表为空或长度为1，不需要调整，如果链表长度为2，删除头节点，如果链表长度为3，删除第2个节点，链表长度为4，删除第2个节点，链表长度为5，删除第3个节……链表长度每增加2，要删除的节点就向后移动一个。<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">removeMidNode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.next == <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">if</span> head.next.next == <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span> head.next</span><br><span class="line">    pre = head</span><br><span class="line">    cur = head.next.next</span><br><span class="line">    <span class="keyword">while</span> cur.next != <span class="literal">None</span> <span class="keyword">and</span> cur.next.next != <span class="literal">None</span>:</span><br><span class="line">      pre = pre.next</span><br><span class="line">      cur = cur.next.next</span><br><span class="line">    pre.next = pre.next.next</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题4：反转单向和双向链表"><a href="#面试题4：反转单向和双向链表" class="headerlink" title="面试题4：反转单向和双向链表"></a>面试题4：反转单向和双向链表</h5><p>题目：反转单向链表<br>练习：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">面试题24. 反转链表</a>，<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head != <span class="literal">None</span>:</span><br><span class="line">            tmp = head.next</span><br><span class="line">            head.next = pre</span><br><span class="line">            pre = head</span><br><span class="line">            head = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

</div></div></p>
<p>题目：反转双向链表<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">		pre = <span class="literal">None</span></span><br><span class="line">		<span class="keyword">while</span> head != <span class="literal">None</span>:</span><br><span class="line">			tmp = head.next</span><br><span class="line">			head.next = pre</span><br><span class="line">			head.last = tmp</span><br><span class="line">			pre = head</span><br><span class="line">			head = tmp</span><br><span class="line">		<span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题5：反转部分单向链表"><a href="#面试题5：反转部分单向链表" class="headerlink" title="面试题5：反转部分单向链表"></a>面试题5：反转部分单向链表</h5><p>题目： 给定一个单向链表的头节点head，以及两个整数from和to，在单向链表上把第from个节点到第to个节点这一部分进行反转。<br>练习：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        res = ListNode(<span class="literal">None</span>)</span><br><span class="line">        res.next = head</span><br><span class="line">        pre = res</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(m<span class="number">-1</span>):</span><br><span class="line">            pre = pre.next</span><br><span class="line">        cur = pre.next</span><br><span class="line">        node = cur</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n-m):</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = tmp.next</span><br><span class="line">            tmp.next = node</span><br><span class="line">            node = tmp</span><br><span class="line">        pre.next = node</span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题6：环形单链表的约瑟夫问题"><a href="#面试题6：环形单链表的约瑟夫问题" class="headerlink" title="面试题6：环形单链表的约瑟夫问题"></a>面试题6：环形单链表的约瑟夫问题</h5><p>题目： 41个人排成一个圆圈，由第1个人开始报数，报数到3的人就自杀，然后再由下一个人重新报1，报数到3的人再自杀，这样依次下去，直到剩下最后一个人时，那个人可以自由选择自己的命运。这就是著名的约瑟夫问题。 节点数为N，时间复杂度O(N)完成。</p>
<p>练习：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题62. 圆圈中最后剩下的数字</a>  </p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n: int, m: int)</span> -&gt; int:</span></span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            f = (m + f) % i</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题7：判断一个链表是否为回文结构"><a href="#面试题7：判断一个链表是否为回文结构" class="headerlink" title="面试题7：判断一个链表是否为回文结构"></a>面试题7：判断一个链表是否为回文结构</h5><p>要求：链表长度为N，时间复杂度为O(N)，额外空间复杂度O(1)</p>
<p>练习：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a>   <a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank" rel="noopener">面试题 02.06. 回文链表</a></p>
<div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        node1 = node2 = head</span><br><span class="line">        <span class="keyword">while</span> node2.next != <span class="literal">None</span> <span class="keyword">and</span> node2.next.next != <span class="literal">None</span>:</span><br><span class="line">            node1 = node1.next</span><br><span class="line">            node2 = node2.next.next</span><br><span class="line">        node2 = node1.next</span><br><span class="line">        node1.next = <span class="literal">None</span></span><br><span class="line">        node3 = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> node2 != <span class="literal">None</span>:</span><br><span class="line">            node3 = node2.next</span><br><span class="line">            node2.next = node1</span><br><span class="line">            node1 = node2</span><br><span class="line">            node2 = node3</span><br><span class="line">        node3 = node1</span><br><span class="line">        node2 = head</span><br><span class="line">        res = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> node1 != <span class="literal">None</span> <span class="keyword">and</span> node2 != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node1.val != node2.val:</span><br><span class="line">                res = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            node1 = node1.next</span><br><span class="line">            node2 = node2.next</span><br><span class="line">        node1 = node3.next</span><br><span class="line">        node3.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> node1 != <span class="literal">None</span>:</span><br><span class="line">            node2 = node1.next</span><br><span class="line">            node1.next = node3</span><br><span class="line">            node3 = node1</span><br><span class="line">            node1 = node2</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式"><a href="#面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式" class="headerlink" title="面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式"></a>面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式</h5><p>题目： 将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。 每个部分里的节点从左到右的顺序于原链表中节点的先后次序一致，且若链表长度为N，则时间复杂度为O(N)，额外空间复杂度为O(1)<br>练习：<a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表</a>  <a href="https://leetcode-cn.com/problems/partition-list-lcci/" target="_blank" rel="noopener">面试题 02.04. 分割链表</a><br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">        small = small_head = ListNode(<span class="literal">None</span>)</span><br><span class="line">        equal = equal_head = ListNode(<span class="literal">None</span>)</span><br><span class="line">        big = big_head = ListNode(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> head != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">                small.next = head</span><br><span class="line">                small = small.next</span><br><span class="line">            <span class="keyword">elif</span> head.val == x:</span><br><span class="line">                equal.next = head</span><br><span class="line">                equal = equal.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                big.next = head</span><br><span class="line">                big = big.next</span><br><span class="line">            head = head.next</span><br><span class="line">        big.next = <span class="literal">None</span></span><br><span class="line">        equal.next = big_head.next</span><br><span class="line">        small.next = equal_head.next</span><br><span class="line">        <span class="keyword">return</span> small_head.next</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题9：复制含有随机指针节点的链表"><a href="#面试题9：复制含有随机指针节点的链表" class="headerlink" title="面试题9：复制含有随机指针节点的链表"></a>面试题9：复制含有随机指针节点的链表</h5><p>练习：<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. 复制带随机指针的链表</a>  <a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">面试题35. 复杂链表的复制</a><br>要求：时间复杂度O(N)，额外空间复杂度O(1)<br><div><div class="fold_hider"><div class="close hider_title">ViewCode</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        org = head</span><br><span class="line">        <span class="keyword">while</span> org != <span class="literal">None</span>:</span><br><span class="line">            node = Node(org.val)</span><br><span class="line">            next = org.next</span><br><span class="line">            org.next = node</span><br><span class="line">            node.next = next</span><br><span class="line">            org = next</span><br><span class="line">        org = head</span><br><span class="line">        <span class="keyword">while</span> org != <span class="literal">None</span>:</span><br><span class="line">            org.next.random = org.random.next <span class="keyword">if</span> org.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            org = org.next.next</span><br><span class="line">        org = head</span><br><span class="line">        res = pre = head.next</span><br><span class="line">        <span class="keyword">while</span> org != <span class="literal">None</span>:</span><br><span class="line">            org.next = pre.next</span><br><span class="line">            org = org.next</span><br><span class="line">            pre.next = org.next <span class="keyword">if</span> org <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题10：两个单链表生成相加链表"><a href="#面试题10：两个单链表生成相加链表" class="headerlink" title="面试题10：两个单链表生成相加链表"></a>面试题10：两个单链表生成相加链表</h5><p>练习：<a href="https://leetcode-cn.com/problems/sum-lists-lcci/" target="_blank" rel="noopener">面试题 02.05. 链表求和</a>  <a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">445. 两数相加 II</a>  <a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a><br><div><div class="fold_hider"><div class="close hider_title">不修改链表</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">	   s1, s2 = [], []</span><br><span class="line">        <span class="keyword">while</span> l1 != <span class="literal">None</span>:</span><br><span class="line">            s1.append(l1.val)</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        <span class="keyword">while</span> l2 != <span class="literal">None</span>:</span><br><span class="line">            s2.append(l2.val)</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        head = <span class="literal">None</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> s1 != [] <span class="keyword">and</span> s2 != []:</span><br><span class="line">            digit = s1.pop() + s2.pop() + cur</span><br><span class="line">            node = ListNode(digit%<span class="number">10</span>)</span><br><span class="line">            node.next = head</span><br><span class="line">            head = node</span><br><span class="line">            cur = digit // <span class="number">10</span></span><br><span class="line">        s = s1 <span class="keyword">if</span> s1 != [] <span class="keyword">else</span> s2</span><br><span class="line">        <span class="keyword">while</span> s != []:</span><br><span class="line">            digit = s.pop() + cur</span><br><span class="line">            node = ListNode(digit%<span class="number">10</span>)</span><br><span class="line">            node.next = head</span><br><span class="line">            head = node</span><br><span class="line">            cur = digit // <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> cur == <span class="number">1</span>:</span><br><span class="line">            node = ListNode(<span class="number">1</span>)</span><br><span class="line">            node.next = head</span><br><span class="line">            head = node</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

</div></div><br><div><div class="fold_hider"><div class="close hider_title">修改链表</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        l1 = self.reverse(l1)</span><br><span class="line">        l2 = self.reverse(l2)</span><br><span class="line">        ca = <span class="number">0</span></span><br><span class="line">        head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            n1 = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n2 = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n = n1 + n2 + ca</span><br><span class="line">            node = ListNode(n%<span class="number">10</span>)</span><br><span class="line">            node.next = head</span><br><span class="line">            head = node</span><br><span class="line">            ca = n // <span class="number">10</span></span><br><span class="line">            l1 = l1.next <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            l2 = l2.next <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> ca == <span class="number">1</span>:</span><br><span class="line">            node = ListNode(<span class="number">1</span>)</span><br><span class="line">            node.next = head</span><br><span class="line">            head = node</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head != <span class="literal">None</span>:</span><br><span class="line">            tmp = head.next</span><br><span class="line">            head.next = pre</span><br><span class="line">            pre = head</span><br><span class="line">            head = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

</div></div></p>
<h5 id="面试题11：两个单链表相交的一系列问题"><a href="#面试题11：两个单链表相交的一系列问题" class="headerlink" title="面试题11：两个单链表相交的一系列问题"></a>面试题11：两个单链表相交的一系列问题</h5><p>题目： 单链表可能有环，也可能无环。给定两个单链表的头节点head1和head2，这两个链表可能相交，也可能不相交。请实现一个函数，如果两个链表相交，请返回相交的第一个节点；如果不相交，返回null即可。 </p>
<p>要求： 如果链表1的长度为N，链表2的长度为M，时间复杂度请达到O(N+M)，额外空间复杂度请达到O(1)。 </p>
<p>拆分问题：</p>
<p>问题一：链表是否有环，如果有，则返回第一个进入环的节点。<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a>  <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></p>
<p>解题： 1．设置一个慢指针slow和一个快指针fast。在开始时，slow和fast都指向链表的头节点head。然后slow每次移动一步，fast每次移动两步，在链表中遍历起来。2．如果链表无环，那么fast指针在移动过程中一定先遇到终点，一旦fast到达终点，说明链表是没有环的，直接返回null，表示该链表无环，当然也没有第一个入环的节点。 3．如果链表有环，那么fast指针和slow指针一定会在环中的某个位置相遇，当fast和slow相遇时，fast指针重新回到head的位置，slow指针不动。接下来，fast指针从每次移动两步改为每次移动一步，slow指针依然每次移动一步，然后继续遍历。4．fast指针和slow指针一定会再次相遇，并且在第一个入环的节点处相遇。</p>
<div><div class="fold_hider"><div class="close hider_title">链表是否有环</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.next == <span class="literal">None</span> <span class="keyword">or</span> head.next.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        slow = head.next</span><br><span class="line">        fast = head.next.next</span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="keyword">if</span> fast.next == <span class="literal">None</span> <span class="keyword">or</span> fast.next.next == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            fast = fast.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>

</div></div>
<p>问题二：两个无环链表是否相交，相交返回第一个相交节点。<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a>  <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/" target="_blank" rel="noopener">面试题 02.07. 链表相交</a></p>
<div><div class="fold_hider"><div class="close hider_title">两个无环链表相交</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        node1 = headA</span><br><span class="line">        node2 = headB</span><br><span class="line">        <span class="keyword">while</span> node1 != node2:</span><br><span class="line">            node1 = node1.next <span class="keyword">if</span> node1 <span class="keyword">else</span> headB</span><br><span class="line">            node2 = node2.next <span class="keyword">if</span> node2 <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> node1</span><br></pre></td></tr></table></figure>

</div></div>
<p>问题三：两个有环链表是否相交，相交返回第一个相交节点。</p>
<p>解题：假设已经得到了两个链表各自的第一个入环节点，loop1和loop2。如果loop1==loop2， 只要考虑链表1从头开始到loop1这一段与链表2从头开始到loop2这一段，在那里第一次相交即可，而不用考虑进环该怎么处理，与问题二类似，只不过问题二是把null作为一个链表的终点，而这里是把loop1(loop2)作为链表的终点。但是判断的主要过程是相同的；如果loop1 != loop2， 让链表1从loop1出发，因为loop1和之后的所有节点都在环上，所以将来一定能回到loop1。如果回到loop1之前并没有遇到loop2，说明两个链表不相交， 如果回到loop1之前遇到了loop2，说明两个链表相交。因为loop1和loop2都在两条链表上，只不过loop1是离链表1较近的节点，loop2是离链表2较近的节点。所以，此时返回loop1或loop2都可以。</p>
<h5 id="面试题12：将单链表的每-K-个节点之间逆序"><a href="#面试题12：将单链表的每-K-个节点之间逆序" class="headerlink" title="面试题12：将单链表的每 K 个节点之间逆序"></a>面试题12：将单链表的每 K 个节点之间逆序</h5><p>题目：给定一个单链表的头节点head，实现一个调整单链表的函数，使得每K个节点之间逆序，如果最后不够K个节点一组，则不调整最后几个节点。 </p>
<p>练习：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a></p>
<p>解题：若K&lt;2，则不用做任何调整；使用栈结构得解法：时间复杂度O(N)，额外空间复杂度O(k)，从左到右遍历链表，如果栈的大小不等于K，就将节点不断压入栈中，当栈的大小第一次达到K时，从栈中依次弹出这些节点，并根据弹出顺序重新连接，完成逆序后纪录新的头部和尾部。不使用栈结构的解法：时间复杂度O(N)，额外空间复杂度O(k)，用变量纪录每一组开始的第一个节点和最后一个节点，直接逆序调整。</p>
<div><div class="fold_hider"><div class="close hider_title">不使用栈方法的逆序</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题13：删除无序单链表中值重复出现的节点"><a href="#面试题13：删除无序单链表中值重复出现的节点" class="headerlink" title="面试题13：删除无序单链表中值重复出现的节点"></a>面试题13：删除无序单链表中值重复出现的节点</h5><p>题目： 给定一个无序单链表的头节点head，删除其中值重复出现的节点。 </p>
<p>练习：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a>  <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a></p>
<p>解题：使用哈希表：时间复杂度O(N)，额外空间复杂度O(N)，生成一个哈希表，头节点是不用删除的节点，首先将头节点的值放入哈希表中，从头节点的下一个节点开始往后遍历节点， 假设当前遍历到cur节点，先检查cur的值是否在哈希表中，如果在，则说明cur节点的值是之前出现过的，就将cur节点删除，删除的方式是将最近一个没有被删除的节点pre连接到cur的下一个节点，即pre.next=cur.next。如果不在，将cur节点的值加入哈希表，同时令pre=cur，即更新最近一个没有被删除的节点。</p>
<div><div class="fold_hider"><div class="close hider_title">使用哈希表</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>
<p>不使用哈希表：类似选择排序，时间复杂度O(N^2)，额外空间复杂度O(1)</p>
<div><div class="fold_hider"><div class="close hider_title">不使用哈希表</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题14：在单链表中删除指定值的节点"><a href="#面试题14：在单链表中删除指定值的节点" class="headerlink" title="面试题14：在单链表中删除指定值的节点"></a>面试题14：在单链表中删除指定值的节点</h5><p>题目： 给定一个链表的头节点head和一个整数num，请实现函数将值为num的节点全部删除。 </p>
<p>练习：<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. 移除链表元素</a>  <a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">237. 删除链表中的节点</a>  <a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">面试题18. 删除链表的节点</a></p>
<div><div class="fold_hider"><div class="close hider_title">删除指定节点</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题15：将搜索二叉树转换成双向链表"><a href="#面试题15：将搜索二叉树转换成双向链表" class="headerlink" title="面试题15：将搜索二叉树转换成双向链表"></a>面试题15：将搜索二叉树转换成双向链表</h5><p>题目：一棵搜索二叉树，请将其转换为一个有序的双向链表 </p>
<p>练习：<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a>  <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener">面试题36. 二叉搜索树与双向链表</a>  <a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a>  leetcode 426</p>
<p>解题：利用递归函数，中序遍历，时间复杂度O(N)，额外空间复杂度O(h)，具体过程是先把 以X为头的搜索二叉树的左子树转换为有序双向链表，并且返回左子树有序双向链表的头和尾，然后把以X为头的搜索二叉树的右子树转换为有序双向链表，并且返回右子树有序双向链表的头和尾，接着通过X把两部分接起来即可。</p>
<div><div class="fold_hider"><div class="close hider_title">搜索二叉树——双向链表</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题16：单链表的选择排序"><a href="#面试题16：单链表的选择排序" class="headerlink" title="面试题16：单链表的选择排序"></a>面试题16：单链表的选择排序</h5><p>题目： 给定一个无序单链表的头节点head，实现单链表的选择排序。额外空间复杂度O(1) </p>
<p>练习：<a href="https://leetcode-cn.com/problems/insertion-sort-list/" target="_blank" rel="noopener">147. 对链表进行插入排序</a>    <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a></p>
<p>解题：选择排序是从未排序的部分中找到最小值，然后放在排好序部分的尾部，逐渐将未排序的部分缩小。时间复杂度为O(N^2)</p>
<div><div class="fold_hider"><div class="close hider_title">链表排序</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题17：一种怪异的节点删除方式"><a href="#面试题17：一种怪异的节点删除方式" class="headerlink" title="面试题17：一种怪异的节点删除方式"></a>面试题17：一种怪异的节点删除方式</h5><p>题目：链表节点值类型为int型，给定一个链表中的节点node，但不给定整个链表的头节点。在链表中删除node？请实现这个函数，并分析这样做会出现哪些问题。要求：时间复杂度为O(1)。 </p>
<p>解题：将要删除的节点的值变成其下一个节点的值，删除下一个节点。</p>
<p>存在问题：第一无法删除最后一个节点；第二这种删除方法在工程上存在很大的问题。</p>
<h5 id="面试题18：向有序的环形单链表中插入新节点"><a href="#面试题18：向有序的环形单链表中插入新节点" class="headerlink" title="面试题18：向有序的环形单链表中插入新节点"></a>面试题18：向有序的环形单链表中插入新节点</h5><p>题目：一个环形单链表从头节点head开始不降序，同时由最后的节点指回头节点。给定这样一个环形单链表的头节点head和一个整数num，请生成节点值为num的新节点，并插入到这个环形链表中，保证调整后的链表依然有序。</p>
<p> 具体过程：</p>
<ol>
<li><h5 id="面试题19：合并两个有序的单链表"><a href="#面试题19：合并两个有序的单链表" class="headerlink" title="面试题19：合并两个有序的单链表"></a>面试题19：合并两个有序的单链表</h5></li>
</ol>
<p>题目：给定两个有序单链表的头节点head1和head2，请合并两个有序链表，合并后的链表依然有序，并返回合并后链表的头节点。</p>
<p>练习：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a>  <a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">面试题25. 合并两个排序的链表</a>  <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a></p>
<div><div class="fold_hider"><div class="close hider_title">链表合并</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>
<h5 id="面试题20：按照左右半区的方式重新组合单链表"><a href="#面试题20：按照左右半区的方式重新组合单链表" class="headerlink" title="面试题20：按照左右半区的方式重新组合单链表"></a>面试题20：按照左右半区的方式重新组合单链表</h5><p>题目： 给定一个单链表的头部节点head，链表长度为N，如果N为偶数，那么前N/2个节点算作左半区，后N/2个节点算作右半区；如果N为奇数，那么前N/2个节点算作左半区，后N/2 + 1个节点算作右半区。左半区从左到右依次记为L1-&gt;L2-&gt;…，右半区从左到右依次记为R1-&gt;R2-&gt;…，请将单链表调整成L1-&gt;R1-&gt;L2-&gt;R2-&gt;…的 形式 </p>
<p>练习：<a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. 重排链表</a></p>
<p>解题：时间复杂度为O(N)，额外空间复杂度为O(1)的解法：将链表分成左半区和右半区，将右半区逆序，最后合并两个链表。</p>
<div><div class="fold_hider"><div class="close hider_title">链表重排</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历"><a href="#面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历" class="headerlink" title="面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历"></a>面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历</h5><p>题目： 用递归和非递归方式，分别按照二叉树先序、中序和后序打印所有的节点。我们约定：先序遍历顺序为根、左、右；中序遍历顺序为左、根、右；后序遍历顺序为左、右、 根 </p>
<ol>
<li><p>二叉树的先序遍历，练习：<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></p>
<div><div class="fold_hider"><div class="close hider_title">递归先序遍历</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

</div></div>
<div><div class="fold_hider"><div class="close hider_title">非递归先序遍历</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

</div></div>
</li>
<li><p>二叉树的中序遍历，练习：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></p>
<div><div class="fold_hider"><div class="close hider_title">递归中序遍历</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

</div></div>
<div><div class="fold_hider"><div class="close hider_title">非递归中序遍历</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

</div></div>
</li>
<li><p>二叉树的后序遍历，练习：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></p>
<div><div class="fold_hider"><div class="close hider_title">递归后序遍历</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

</div></div>
<div><div class="fold_hider"><div class="close hider_title">非递归后序遍历</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

</div></div>
</li>
<li><p>二叉树的层序遍历，练习：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a> <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. 二叉树的层次遍历 II</a></p>
<div><div class="fold_hider"><div class="close hider_title">层序遍历</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

</div></div>
</li>
<li><p>二叉树的垂序遍历，练习：<a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="noopener">987. 二叉树的垂序遍历</a></p>
<div><div class="fold_hider"><div class="close hider_title">垂序遍历</div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

</div></div>
</li>
</ol>
<h5 id="面试题2：打印二叉树的边界节点"><a href="#面试题2：打印二叉树的边界节点" class="headerlink" title="面试题2：打印二叉树的边界节点"></a>面试题2：打印二叉树的边界节点</h5><p>题目：给定一棵二叉树的头节点head，按照如下两种标准分别实现二叉树边界节点的逆时针打印。</p>
<p>标准一：1．头节点为边界节点。2．叶节点为边界节点。3．如果节点在其所在的层中是最左的或最右的，那么该节点也是边界节点。</p>
<p>标准二：1．头节点为边界节点。2．叶节点为边界节点。3．树左边界延伸下去的路径为边界节点。4．树右边界延伸下去的路径为边界节点。 </p>
<p>练习：Leetcode 545</p>
<p>要求：1. 如果节点数为N，两种标准实现的时间复杂度要求都为O(N)，额外空间复杂度要求都为O(h)，h为二叉树的高度。2．两种标准都要求逆时针顺序且不重复打印所有的边界节点。 </p>
<h5 id="面试题3：如何较为直观地打印二叉树"><a href="#面试题3：如何较为直观地打印二叉树" class="headerlink" title="面试题3：如何较为直观地打印二叉树"></a>面试题3：如何较为直观地打印二叉树</h5><p>练习：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题32 - I. 从上到下打印二叉树</a>  <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">面试题32 - II. 从上到下打印二叉树 II</a>  <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">面试题32 - III. 从上到下打印二叉树 III</a></p>
<h5 id="面试题4：二叉树地序列化和反序列化"><a href="#面试题4：二叉树地序列化和反序列化" class="headerlink" title="面试题4：二叉树地序列化和反序列化"></a>面试题4：二叉树地序列化和反序列化</h5><p>题目： 二叉树被记录成文件的过程叫作二叉树的序列化，通过文件内容重建原来二叉树的过程叫作二叉树的反序列化。 </p>
<p>练习：<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">面试题37. 序列化二叉树</a>  <a href="https://leetcode-cn.com/problems/bst-sequences-lcci/" target="_blank" rel="noopener">面试题 04.09. 二叉搜索树序列</a>  <a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/" target="_blank" rel="noopener">449. 序列化和反序列化二叉搜索树</a>  <a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. 二叉树的序列化与反序列化</a></p>
<h5 id="面试题5：遍历二叉树地神级方法"><a href="#面试题5：遍历二叉树地神级方法" class="headerlink" title="面试题5：遍历二叉树地神级方法"></a>面试题5：遍历二叉树地神级方法</h5><h5 id="面试题6：在二叉树中找到累加和为指定值地最长路径长度"><a href="#面试题6：在二叉树中找到累加和为指定值地最长路径长度" class="headerlink" title="面试题6：在二叉树中找到累加和为指定值地最长路径长度"></a>面试题6：在二叉树中找到累加和为指定值地最长路径长度</h5><h5 id="面试题7：找到二叉树中最大搜索二叉子数"><a href="#面试题7：找到二叉树中最大搜索二叉子数" class="headerlink" title="面试题7：找到二叉树中最大搜索二叉子数"></a>面试题7：找到二叉树中最大搜索二叉子数</h5><h5 id="面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构"><a href="#面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构" class="headerlink" title="面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构"></a>面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构</h5><h5 id="面试题9：二叉树的按层打印预-ZigZag-打印"><a href="#面试题9：二叉树的按层打印预-ZigZag-打印" class="headerlink" title="面试题9：二叉树的按层打印预 ZigZag 打印"></a>面试题9：二叉树的按层打印预 ZigZag 打印</h5><h5 id="面试题10：调整搜索二叉树中两个错误的节点"><a href="#面试题10：调整搜索二叉树中两个错误的节点" class="headerlink" title="面试题10：调整搜索二叉树中两个错误的节点"></a>面试题10：调整搜索二叉树中两个错误的节点</h5><h5 id="面试题11：判断-t1-树是否包含-t2-树全部的拓扑结构"><a href="#面试题11：判断-t1-树是否包含-t2-树全部的拓扑结构" class="headerlink" title="面试题11：判断 t1 树是否包含 t2 树全部的拓扑结构"></a>面试题11：判断 t1 树是否包含 t2 树全部的拓扑结构</h5><h5 id="面试题12：判断-t1-树中是否有与-t2-树拓扑结构完全相同的子数"><a href="#面试题12：判断-t1-树中是否有与-t2-树拓扑结构完全相同的子数" class="headerlink" title="面试题12：判断 t1 树中是否有与 t2 树拓扑结构完全相同的子数"></a>面试题12：判断 t1 树中是否有与 t2 树拓扑结构完全相同的子数</h5><h5 id="面试题13：判断二叉树是否为平衡二叉树"><a href="#面试题13：判断二叉树是否为平衡二叉树" class="headerlink" title="面试题13：判断二叉树是否为平衡二叉树"></a>面试题13：判断二叉树是否为平衡二叉树</h5><h5 id="面试题14：根据后序数组重建搜索二叉树"><a href="#面试题14：根据后序数组重建搜索二叉树" class="headerlink" title="面试题14：根据后序数组重建搜索二叉树"></a>面试题14：根据后序数组重建搜索二叉树</h5><h5 id="面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树"><a href="#面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树" class="headerlink" title="面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树"></a>面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树</h5><h5 id="面试题16：通过有序数组生成平衡搜索二叉树"><a href="#面试题16：通过有序数组生成平衡搜索二叉树" class="headerlink" title="面试题16：通过有序数组生成平衡搜索二叉树"></a>面试题16：通过有序数组生成平衡搜索二叉树</h5><h5 id="面试题17：在二叉树中找到一个节点的后继节点"><a href="#面试题17：在二叉树中找到一个节点的后继节点" class="headerlink" title="面试题17：在二叉树中找到一个节点的后继节点"></a>面试题17：在二叉树中找到一个节点的后继节点</h5><h5 id="面试题18：在二叉树中找到两个节点的最低公共祖先"><a href="#面试题18：在二叉树中找到两个节点的最低公共祖先" class="headerlink" title="面试题18：在二叉树中找到两个节点的最低公共祖先"></a>面试题18：在二叉树中找到两个节点的最低公共祖先</h5><h5 id="面试题19：Tarjan-算法与并查集解决二叉树节点间最低公共祖先的批量查询问题"><a href="#面试题19：Tarjan-算法与并查集解决二叉树节点间最低公共祖先的批量查询问题" class="headerlink" title="面试题19：Tarjan 算法与并查集解决二叉树节点间最低公共祖先的批量查询问题"></a>面试题19：Tarjan 算法与并查集解决二叉树节点间最低公共祖先的批量查询问题</h5><h5 id="面试题20：二叉树节点间的最大距离问题"><a href="#面试题20：二叉树节点间的最大距离问题" class="headerlink" title="面试题20：二叉树节点间的最大距离问题"></a>面试题20：二叉树节点间的最大距离问题</h5><h5 id="面试题21：派对的最大快乐值"><a href="#面试题21：派对的最大快乐值" class="headerlink" title="面试题21：派对的最大快乐值"></a>面试题21：派对的最大快乐值</h5><h5 id="面试题22：通过先序和中序数组生成后序数组"><a href="#面试题22：通过先序和中序数组生成后序数组" class="headerlink" title="面试题22：通过先序和中序数组生成后序数组"></a>面试题22：通过先序和中序数组生成后序数组</h5><h5 id="面试题23：统计和生成所有不同的二叉树"><a href="#面试题23：统计和生成所有不同的二叉树" class="headerlink" title="面试题23：统计和生成所有不同的二叉树"></a>面试题23：统计和生成所有不同的二叉树</h5><h5 id="面试题24：统计完全二叉树的节点树"><a href="#面试题24：统计完全二叉树的节点树" class="headerlink" title="面试题24：统计完全二叉树的节点树"></a>面试题24：统计完全二叉树的节点树</h5><h4 id="递归和动态规划"><a href="#递归和动态规划" class="headerlink" title="递归和动态规划"></a>递归和动态规划</h4><h5 id="面试题1：斐波那契数列问题的递归和动态规划"><a href="#面试题1：斐波那契数列问题的递归和动态规划" class="headerlink" title="面试题1：斐波那契数列问题的递归和动态规划"></a>面试题1：斐波那契数列问题的递归和动态规划</h5><h5 id="面试题2：矩阵的最小路径和"><a href="#面试题2：矩阵的最小路径和" class="headerlink" title="面试题2：矩阵的最小路径和"></a>面试题2：矩阵的最小路径和</h5><h5 id="面试题3：换钱的最少货币数"><a href="#面试题3：换钱的最少货币数" class="headerlink" title="面试题3：换钱的最少货币数"></a>面试题3：换钱的最少货币数</h5><h5 id="面试题4：机器人达到指定位置方法数"><a href="#面试题4：机器人达到指定位置方法数" class="headerlink" title="面试题4：机器人达到指定位置方法数"></a>面试题4：机器人达到指定位置方法数</h5><h5 id="面试题5：换钱的方法数"><a href="#面试题5：换钱的方法数" class="headerlink" title="面试题5：换钱的方法数"></a>面试题5：换钱的方法数</h5><h5 id="面试题6：打气球的最大分数"><a href="#面试题6：打气球的最大分数" class="headerlink" title="面试题6：打气球的最大分数"></a>面试题6：打气球的最大分数</h5><h5 id="面试题7：最长递增子序列"><a href="#面试题7：最长递增子序列" class="headerlink" title="面试题7：最长递增子序列"></a>面试题7：最长递增子序列</h5><h5 id="面试题8：信封嵌套问题"><a href="#面试题8：信封嵌套问题" class="headerlink" title="面试题8：信封嵌套问题"></a>面试题8：信封嵌套问题</h5><h5 id="面试题9：汉诺塔问题"><a href="#面试题9：汉诺塔问题" class="headerlink" title="面试题9：汉诺塔问题"></a>面试题9：汉诺塔问题</h5><h5 id="面试题10：最长公共子序列问题"><a href="#面试题10：最长公共子序列问题" class="headerlink" title="面试题10：最长公共子序列问题"></a>面试题10：最长公共子序列问题</h5><h5 id="面试题11：最长公共子串问题"><a href="#面试题11：最长公共子串问题" class="headerlink" title="面试题11：最长公共子串问题"></a>面试题11：最长公共子串问题</h5><h5 id="面试题12：子数组异或和为0的最多划分"><a href="#面试题12：子数组异或和为0的最多划分" class="headerlink" title="面试题12：子数组异或和为0的最多划分"></a>面试题12：子数组异或和为0的最多划分</h5><h5 id="面试题13：最小编辑代价"><a href="#面试题13：最小编辑代价" class="headerlink" title="面试题13：最小编辑代价"></a>面试题13：最小编辑代价</h5><h5 id="面试题14：字符串的交错组成"><a href="#面试题14：字符串的交错组成" class="headerlink" title="面试题14：字符串的交错组成"></a>面试题14：字符串的交错组成</h5><h5 id="面试题15：龙与地下城游戏问题"><a href="#面试题15：龙与地下城游戏问题" class="headerlink" title="面试题15：龙与地下城游戏问题"></a>面试题15：龙与地下城游戏问题</h5><h5 id="面试题16：数字字符串转换为字符组合的种数"><a href="#面试题16：数字字符串转换为字符组合的种数" class="headerlink" title="面试题16：数字字符串转换为字符组合的种数"></a>面试题16：数字字符串转换为字符组合的种数</h5><h5 id="面试题17：表达式得到期望结果的组成种树"><a href="#面试题17：表达式得到期望结果的组成种树" class="headerlink" title="面试题17：表达式得到期望结果的组成种树"></a>面试题17：表达式得到期望结果的组成种树</h5><h5 id="面试题18：排成一条线的纸牌博弈问题"><a href="#面试题18：排成一条线的纸牌博弈问题" class="headerlink" title="面试题18：排成一条线的纸牌博弈问题"></a>面试题18：排成一条线的纸牌博弈问题</h5><h5 id="面试题19：跳跃游戏"><a href="#面试题19：跳跃游戏" class="headerlink" title="面试题19：跳跃游戏"></a>面试题19：跳跃游戏</h5><h5 id="面试题20：数组中的最长连续序列"><a href="#面试题20：数组中的最长连续序列" class="headerlink" title="面试题20：数组中的最长连续序列"></a>面试题20：数组中的最长连续序列</h5><h5 id="面试题21：N-皇后问题"><a href="#面试题21：N-皇后问题" class="headerlink" title="面试题21：N 皇后问题"></a>面试题21：N 皇后问题</h5><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="面试题1：判断两个字符串是否互为变形词"><a href="#面试题1：判断两个字符串是否互为变形词" class="headerlink" title="面试题1：判断两个字符串是否互为变形词"></a>面试题1：判断两个字符串是否互为变形词</h5><h5 id="面试题2：判断两个字符串是否互为旋转词"><a href="#面试题2：判断两个字符串是否互为旋转词" class="headerlink" title="面试题2：判断两个字符串是否互为旋转词"></a>面试题2：判断两个字符串是否互为旋转词</h5><h5 id="面试题3：字符串中统计字符串"><a href="#面试题3：字符串中统计字符串" class="headerlink" title="面试题3：字符串中统计字符串"></a>面试题3：字符串中统计字符串</h5><h5 id="面试题4：判断字符数组中是否所有的字符都只出现过一次"><a href="#面试题4：判断字符数组中是否所有的字符都只出现过一次" class="headerlink" title="面试题4：判断字符数组中是否所有的字符都只出现过一次"></a>面试题4：判断字符数组中是否所有的字符都只出现过一次</h5><h5 id="面试题5：在有序但包含空数组中查找字符串"><a href="#面试题5：在有序但包含空数组中查找字符串" class="headerlink" title="面试题5：在有序但包含空数组中查找字符串"></a>面试题5：在有序但包含空数组中查找字符串</h5><h5 id="面试题6：字符串的调整与替换"><a href="#面试题6：字符串的调整与替换" class="headerlink" title="面试题6：字符串的调整与替换"></a>面试题6：字符串的调整与替换</h5><h5 id="面试题7：翻转字符串"><a href="#面试题7：翻转字符串" class="headerlink" title="面试题7：翻转字符串"></a>面试题7：翻转字符串</h5><h5 id="面试题8：完美洗牌问题"><a href="#面试题8：完美洗牌问题" class="headerlink" title="面试题8：完美洗牌问题"></a>面试题8：完美洗牌问题</h5><h5 id="面试题9：删除多余字符得到字典序最小的字符串"><a href="#面试题9：删除多余字符得到字典序最小的字符串" class="headerlink" title="面试题9：删除多余字符得到字典序最小的字符串"></a>面试题9：删除多余字符得到字典序最小的字符串</h5><h5 id="面试题10：数组中两个字符串的最小距离"><a href="#面试题10：数组中两个字符串的最小距离" class="headerlink" title="面试题10：数组中两个字符串的最小距离"></a>面试题10：数组中两个字符串的最小距离</h5><h5 id="面试题11：字符串的转换路径问题"><a href="#面试题11：字符串的转换路径问题" class="headerlink" title="面试题11：字符串的转换路径问题"></a>面试题11：字符串的转换路径问题</h5><h5 id="面试题12：添加最少字符使字符串整体都是回文字符串"><a href="#面试题12：添加最少字符使字符串整体都是回文字符串" class="headerlink" title="面试题12：添加最少字符使字符串整体都是回文字符串"></a>面试题12：添加最少字符使字符串整体都是回文字符串</h5><h5 id="面试题13：括号字符串的有效性和最长有效长度"><a href="#面试题13：括号字符串的有效性和最长有效长度" class="headerlink" title="面试题13：括号字符串的有效性和最长有效长度"></a>面试题13：括号字符串的有效性和最长有效长度</h5><h5 id="面试题14：公司字符串求值"><a href="#面试题14：公司字符串求值" class="headerlink" title="面试题14：公司字符串求值"></a>面试题14：公司字符串求值</h5><h5 id="面试题15：0-左边必有-1-的二进制字符串数量"><a href="#面试题15：0-左边必有-1-的二进制字符串数量" class="headerlink" title="面试题15：0 左边必有 1 的二进制字符串数量"></a>面试题15：0 左边必有 1 的二进制字符串数量</h5><h5 id="面试题16：拼接所有字符串产生字典顺序最小的大写字符串"><a href="#面试题16：拼接所有字符串产生字典顺序最小的大写字符串" class="headerlink" title="面试题16：拼接所有字符串产生字典顺序最小的大写字符串"></a>面试题16：拼接所有字符串产生字典顺序最小的大写字符串</h5><h5 id="面试题17：找到字符串的最长无重复字符子串"><a href="#面试题17：找到字符串的最长无重复字符子串" class="headerlink" title="面试题17：找到字符串的最长无重复字符子串"></a>面试题17：找到字符串的最长无重复字符子串</h5><h5 id="面试题18：找到指定的新类型字符"><a href="#面试题18：找到指定的新类型字符" class="headerlink" title="面试题18：找到指定的新类型字符"></a>面试题18：找到指定的新类型字符</h5><h5 id="面试题19：旋变字符串问题"><a href="#面试题19：旋变字符串问题" class="headerlink" title="面试题19：旋变字符串问题"></a>面试题19：旋变字符串问题</h5><h5 id="面试题20：最小包含子串的长度"><a href="#面试题20：最小包含子串的长度" class="headerlink" title="面试题20：最小包含子串的长度"></a>面试题20：最小包含子串的长度</h5><h5 id="面试题21：回文最少分割数"><a href="#面试题21：回文最少分割数" class="headerlink" title="面试题21：回文最少分割数"></a>面试题21：回文最少分割数</h5><h5 id="面试题22：字符串匹配问题"><a href="#面试题22：字符串匹配问题" class="headerlink" title="面试题22：字符串匹配问题"></a>面试题22：字符串匹配问题</h5><h5 id="面试题23：字典树（前缀树）的实现"><a href="#面试题23：字典树（前缀树）的实现" class="headerlink" title="面试题23：字典树（前缀树）的实现"></a>面试题23：字典树（前缀树）的实现</h5><h5 id="面试题24：子数组的最大异或和"><a href="#面试题24：子数组的最大异或和" class="headerlink" title="面试题24：子数组的最大异或和"></a>面试题24：子数组的最大异或和</h5><h4 id="大数据和空间限制"><a href="#大数据和空间限制" class="headerlink" title="大数据和空间限制"></a>大数据和空间限制</h4><h5 id="面试题1-认识布隆过滤器"><a href="#面试题1-认识布隆过滤器" class="headerlink" title="面试题1.  认识布隆过滤器"></a>面试题1.  认识布隆过滤器</h5><h5 id="面试题2-只用2GB内存在20亿个整数中找到出现次数最多的数"><a href="#面试题2-只用2GB内存在20亿个整数中找到出现次数最多的数" class="headerlink" title="面试题2.  只用2GB内存在20亿个整数中找到出现次数最多的数"></a>面试题2.  只用2GB内存在20亿个整数中找到出现次数最多的数</h5><h5 id="面试题3-40亿个非负整数中找到未出现的数"><a href="#面试题3-40亿个非负整数中找到未出现的数" class="headerlink" title="面试题3.  40亿个非负整数中找到未出现的数"></a>面试题3.  40亿个非负整数中找到未出现的数</h5><h5 id="面试题4-找到100亿个URL中重复的URL及搜索词汇的Top-K问题"><a href="#面试题4-找到100亿个URL中重复的URL及搜索词汇的Top-K问题" class="headerlink" title="面试题4.  找到100亿个URL中重复的URL及搜索词汇的Top  K问题"></a>面试题4.  找到100亿个URL中重复的URL及搜索词汇的Top  K问题</h5><h5 id="面试题5-40亿个非负整数中找到出现两次的数和所有数的中位数（"><a href="#面试题5-40亿个非负整数中找到出现两次的数和所有数的中位数（" class="headerlink" title="面试题5.  40亿个非负整数中找到出现两次的数和所有数的中位数（"></a>面试题5.  40亿个非负整数中找到出现两次的数和所有数的中位数（</h5><h5 id="面试题6-一致性哈希算法的基本原理"><a href="#面试题6-一致性哈希算法的基本原理" class="headerlink" title="面试题6.  一致性哈希算法的基本原理"></a>面试题6.  一致性哈希算法的基本原理</h5><h5 id="面试题7-岛问题"><a href="#面试题7-岛问题" class="headerlink" title="面试题7.  岛问题"></a>面试题7.  岛问题</h5><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><h5 id="面试题1-不用额外变量交换两个整数的值"><a href="#面试题1-不用额外变量交换两个整数的值" class="headerlink" title="面试题1.  不用额外变量交换两个整数的值"></a>面试题1.  不用额外变量交换两个整数的值</h5><h5 id="面试题2-不用做任何比较判断找出两个数中较大的数"><a href="#面试题2-不用做任何比较判断找出两个数中较大的数" class="headerlink" title="面试题2.  不用做任何比较判断找出两个数中较大的数"></a>面试题2.  不用做任何比较判断找出两个数中较大的数</h5><h5 id="面试题3-只用位运算不用算术运算实现整数的加减乘除运算（"><a href="#面试题3-只用位运算不用算术运算实现整数的加减乘除运算（" class="headerlink" title="面试题3.  只用位运算不用算术运算实现整数的加减乘除运算（"></a>面试题3.  只用位运算不用算术运算实现整数的加减乘除运算（</h5><h5 id="面试题4-整数的二进制数表达中有多少个1"><a href="#面试题4-整数的二进制数表达中有多少个1" class="headerlink" title="面试题4. 整数的二进制数表达中有多少个1"></a>面试题4. 整数的二进制数表达中有多少个1</h5><h5 id="面试题5-在其他数都出现偶数次的数组中找到出现奇数次的数（"><a href="#面试题5-在其他数都出现偶数次的数组中找到出现奇数次的数（" class="headerlink" title="面试题5.  在其他数都出现偶数次的数组中找到出现奇数次的数（"></a>面试题5.  在其他数都出现偶数次的数组中找到出现奇数次的数（</h5><h5 id="面试题6-在其他数都出现k次的数组中找到只出现一次的数"><a href="#面试题6-在其他数都出现k次的数组中找到只出现一次的数" class="headerlink" title="面试题6.  在其他数都出现k次的数组中找到只出现一次的数"></a>面试题6.  在其他数都出现k次的数组中找到只出现一次的数</h5><h4 id="数组和矩阵"><a href="#数组和矩阵" class="headerlink" title="数组和矩阵"></a>数组和矩阵</h4><h5 id="面试题1-转圈打印矩阵"><a href="#面试题1-转圈打印矩阵" class="headerlink" title="面试题1.  转圈打印矩阵"></a>面试题1.  转圈打印矩阵</h5><h5 id="面试题2-将正方形矩阵顺时针转动90°"><a href="#面试题2-将正方形矩阵顺时针转动90°" class="headerlink" title="面试题2.  将正方形矩阵顺时针转动90°"></a>面试题2.  将正方形矩阵顺时针转动90°</h5><h5 id="面试题3-“之”字形打印矩阵"><a href="#面试题3-“之”字形打印矩阵" class="headerlink" title="面试题3.  “之”字形打印矩阵"></a>面试题3.  “之”字形打印矩阵</h5><h5 id="面试题4-找到无序数组中最小的k个数（O-Nlogk-的方法"><a href="#面试题4-找到无序数组中最小的k个数（O-Nlogk-的方法" class="headerlink" title="面试题4.   找到无序数组中最小的k个数（O(Nlogk)的方法"></a>面试题4.   找到无序数组中最小的k个数（O(Nlogk)的方法</h5><h5 id="面试题5-需要排序的最短子数组长度"><a href="#面试题5-需要排序的最短子数组长度" class="headerlink" title="面试题5.  需要排序的最短子数组长度"></a>面试题5.  需要排序的最短子数组长度</h5><h5 id="面试题6-在数组中找到出现次数大于N-K的数"><a href="#面试题6-在数组中找到出现次数大于N-K的数" class="headerlink" title="面试题6.  在数组中找到出现次数大于N/K的数"></a>面试题6.  在数组中找到出现次数大于N/K的数</h5><h5 id="面试题7-在行列都排好序的矩阵中找指定数"><a href="#面试题7-在行列都排好序的矩阵中找指定数" class="headerlink" title="面试题7.  在行列都排好序的矩阵中找指定数"></a>面试题7.  在行列都排好序的矩阵中找指定数</h5><h5 id="面试题8-最长的可整合子数组的长度"><a href="#面试题8-最长的可整合子数组的长度" class="headerlink" title="面试题8.  最长的可整合子数组的长度"></a>面试题8.  最长的可整合子数组的长度</h5><h5 id="面试题9-不重复打印排序数组中相加和为给定值的所有二元组和三元组"><a href="#面试题9-不重复打印排序数组中相加和为给定值的所有二元组和三元组" class="headerlink" title="面试题9.  不重复打印排序数组中相加和为给定值的所有二元组和三元组"></a>面试题9.  不重复打印排序数组中相加和为给定值的所有二元组和三元组</h5><h5 id="面试题10-未排序正数数组中累加和为给定值的最长子数组长度"><a href="#面试题10-未排序正数数组中累加和为给定值的最长子数组长度" class="headerlink" title="面试题10. 未排序正数数组中累加和为给定值的最长子数组长度"></a>面试题10. 未排序正数数组中累加和为给定值的最长子数组长度</h5><h5 id="面试题11-未排序数组中累加和为给定值的最长子数组系列问题"><a href="#面试题11-未排序数组中累加和为给定值的最长子数组系列问题" class="headerlink" title="面试题11.  未排序数组中累加和为给定值的最长子数组系列问题"></a>面试题11.  未排序数组中累加和为给定值的最长子数组系列问题</h5><h5 id="面试题12-未排序数组中累加和小于或等于给定值的最长子数组长度"><a href="#面试题12-未排序数组中累加和小于或等于给定值的最长子数组长度" class="headerlink" title="面试题12.  未排序数组中累加和小于或等于给定值的最长子数组长度"></a>面试题12.  未排序数组中累加和小于或等于给定值的最长子数组长度</h5><h5 id="面试题13-计算数组的小和"><a href="#面试题13-计算数组的小和" class="headerlink" title="面试题13.  计算数组的小和"></a>面试题13.  计算数组的小和</h5><h5 id="面试题14-自然数数组的排序"><a href="#面试题14-自然数数组的排序" class="headerlink" title="面试题14.  自然数数组的排序"></a>面试题14.  自然数数组的排序</h5><h5 id="面试题15-奇数下标都是奇数或者偶数下标都是偶数"><a href="#面试题15-奇数下标都是奇数或者偶数下标都是偶数" class="headerlink" title="面试题15.  奇数下标都是奇数或者偶数下标都是偶数"></a>面试题15.  奇数下标都是奇数或者偶数下标都是偶数</h5><h5 id="面试题16-子数组的最大累加和问题"><a href="#面试题16-子数组的最大累加和问题" class="headerlink" title="面试题16.  子数组的最大累加和问题"></a>面试题16.  子数组的最大累加和问题</h5><h5 id="面试题17-子矩阵的最大累加和问题"><a href="#面试题17-子矩阵的最大累加和问题" class="headerlink" title="面试题17.  子矩阵的最大累加和问题"></a>面试题17.  子矩阵的最大累加和问题</h5><h5 id="面试题18-在数组中找到一个局部最小的位置"><a href="#面试题18-在数组中找到一个局部最小的位置" class="headerlink" title="面试题18.  在数组中找到一个局部最小的位置"></a>面试题18.  在数组中找到一个局部最小的位置</h5><h5 id="面试题19-数组中子数组的最大累乘积"><a href="#面试题19-数组中子数组的最大累乘积" class="headerlink" title="面试题19.  数组中子数组的最大累乘积"></a>面试题19.  数组中子数组的最大累乘积</h5><h5 id="面试题20-打印N个数组整体最大的Top-K"><a href="#面试题20-打印N个数组整体最大的Top-K" class="headerlink" title="面试题20.  打印N个数组整体最大的Top  K"></a>面试题20.  打印N个数组整体最大的Top  K</h5><h5 id="面试题21-边界都是1的最大正方形大小"><a href="#面试题21-边界都是1的最大正方形大小" class="headerlink" title="面试题21.  边界都是1的最大正方形大小"></a>面试题21.  边界都是1的最大正方形大小</h5><h5 id="面试题22-不包含本位置值的累乘数组"><a href="#面试题22-不包含本位置值的累乘数组" class="headerlink" title="面试题22.  不包含本位置值的累乘数组"></a>面试题22.  不包含本位置值的累乘数组</h5><h5 id="面试题23-数组的partition调整"><a href="#面试题23-数组的partition调整" class="headerlink" title="面试题23.  数组的partition调整"></a>面试题23.  数组的partition调整</h5><h5 id="面试题24-求最短通路值"><a href="#面试题24-求最短通路值" class="headerlink" title="面试题24.  求最短通路值"></a>面试题24.  求最短通路值</h5><h5 id="面试题25-数组中未出现的最小正整数"><a href="#面试题25-数组中未出现的最小正整数" class="headerlink" title="面试题25. 数组中未出现的最小正整数"></a>面试题25. 数组中未出现的最小正整数</h5><h5 id="面试题26-数组排序之后相邻数的最大差值"><a href="#面试题26-数组排序之后相邻数的最大差值" class="headerlink" title="面试题26.  数组排序之后相邻数的最大差值"></a>面试题26.  数组排序之后相邻数的最大差值</h5><h5 id="面试题27-做项目的最大收益问题"><a href="#面试题27-做项目的最大收益问题" class="headerlink" title="面试题27.  做项目的最大收益问题"></a>面试题27.  做项目的最大收益问题</h5><h5 id="面试题28-分金条的最小花费"><a href="#面试题28-分金条的最小花费" class="headerlink" title="面试题28.  分金条的最小花费"></a>面试题28.  分金条的最小花费</h5><h5 id="面试题29-大楼轮廓问题"><a href="#面试题29-大楼轮廓问题" class="headerlink" title="面试题29.  大楼轮廓问题"></a>面试题29.  大楼轮廓问题</h5><h5 id="面试题30-加油站良好出发点问题"><a href="#面试题30-加油站良好出发点问题" class="headerlink" title="面试题30.  加油站良好出发点问题"></a>面试题30.  加油站良好出发点问题</h5><h5 id="面试题31-容器盛水问题"><a href="#面试题31-容器盛水问题" class="headerlink" title="面试题31.  容器盛水问题"></a>面试题31.  容器盛水问题</h5><h5 id="绳子最多能覆盖的点个数"><a href="#绳子最多能覆盖的点个数" class="headerlink" title="绳子最多能覆盖的点个数"></a>绳子最多能覆盖的点个数</h5><p>题目：给定一个有序数组arr，代表数轴上从左到右有n个点a[0],a[1]…,a[n-1]，给定一根长度为L的绳子，求绳子最多能覆盖其中的几个点。</p>
<p>解法：试每一个点都作为绳子的末尾或开头。再利用有序二分法，时间时间复杂度O(NlogN)；滑动窗口双指针法，时间复杂度O(N)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">CoverMaxPoint</span><span class="params">(self, nums, long)</span>:</span></span><br><span class="line">		res = <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">			nearest = self.nearestIndex(nums, i, nums[i]-long)</span><br><span class="line">			res = max(res, i-nearest+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">nearestIndex</span><span class="params">(self, nums, R, value)</span>:</span></span><br><span class="line">		L = <span class="number">0</span></span><br><span class="line">		index = R </span><br><span class="line">		<span class="keyword">while</span> L &lt; index:</span><br><span class="line">			mid = (L+index)//<span class="number">2</span></span><br><span class="line">			<span class="keyword">if</span> nums[mid] &gt;= value:</span><br><span class="line">				index = mid</span><br><span class="line">				R = mid - <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				L = mid + <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">CoverMaxPoint2</span><span class="params">(self, nums, long)</span>:</span></span><br><span class="line">		L = <span class="number">0</span></span><br><span class="line">		R = <span class="number">0</span></span><br><span class="line">		res = <span class="number">0</span></span><br><span class="line">		<span class="keyword">while</span> R &lt; len(nums):</span><br><span class="line">			<span class="keyword">if</span> nums[R] - nums[L] &lt;= long:</span><br><span class="line">				R += <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				L += <span class="number">1</span></span><br><span class="line">			res = max(res, R-L)</span><br><span class="line">		<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="面试题1-从5随机到7随机及其扩展"><a href="#面试题1-从5随机到7随机及其扩展" class="headerlink" title="面试题1.  从5随机到7随机及其扩展"></a>面试题1.  从5随机到7随机及其扩展</h5><h5 id="面试题2-一行代码求两个数的最大公约数"><a href="#面试题2-一行代码求两个数的最大公约数" class="headerlink" title="面试题2.  一行代码求两个数的最大公约数"></a>面试题2.  一行代码求两个数的最大公约数</h5><h5 id="面试题3-有关阶乘的两个问题"><a href="#面试题3-有关阶乘的两个问题" class="headerlink" title="面试题3.  有关阶乘的两个问题"></a>面试题3.  有关阶乘的两个问题</h5><h5 id="面试题4-判断一个点是否在矩形内部"><a href="#面试题4-判断一个点是否在矩形内部" class="headerlink" title="面试题4.  判断一个点是否在矩形内部"></a>面试题4.  判断一个点是否在矩形内部</h5><h5 id="面试题5-判断一个点是否在三角形内部"><a href="#面试题5-判断一个点是否在三角形内部" class="headerlink" title="面试题5.  判断一个点是否在三角形内部"></a>面试题5.  判断一个点是否在三角形内部</h5><h5 id="面试题6-折纸问题"><a href="#面试题6-折纸问题" class="headerlink" title="面试题6.  折纸问题"></a>面试题6.  折纸问题</h5><h5 id="面试题7-能否完美地拼成矩形"><a href="#面试题7-能否完美地拼成矩形" class="headerlink" title="面试题7.  能否完美地拼成矩形"></a>面试题7.  能否完美地拼成矩形</h5><h5 id="面试题8-蓄水池算法"><a href="#面试题8-蓄水池算法" class="headerlink" title="面试题8.  蓄水池算法"></a>面试题8.  蓄水池算法</h5><h5 id="面试题9-设计有-setAll-功能的哈希表"><a href="#面试题9-设计有-setAll-功能的哈希表" class="headerlink" title="面试题9.  设计有 setAll 功能的哈希表"></a>面试题9.  设计有 setAll 功能的哈希表</h5><h5 id="面试题10-最大的-leftMax-与-rightMax-之差的绝对值"><a href="#面试题10-最大的-leftMax-与-rightMax-之差的绝对值" class="headerlink" title="面试题10.  最大的 leftMax 与 rightMax 之差的绝对值"></a>面试题10.  最大的 leftMax 与 rightMax 之差的绝对值</h5><h5 id="面试题11-设计LRU缓存结构"><a href="#面试题11-设计LRU缓存结构" class="headerlink" title="面试题11.  设计LRU缓存结构"></a>面试题11.  设计LRU缓存结构</h5><h5 id="面试题12-LFU缓存结构设计"><a href="#面试题12-LFU缓存结构设计" class="headerlink" title="面试题12.  LFU缓存结构设计"></a>面试题12.  LFU缓存结构设计</h5><h5 id="面试题13-设计-RandomPool-结构"><a href="#面试题13-设计-RandomPool-结构" class="headerlink" title="面试题13.  设计 RandomPool 结构"></a>面试题13.  设计 RandomPool 结构</h5><h5 id="面试题14-并查集的实现"><a href="#面试题14-并查集的实现" class="headerlink" title="面试题14.  并查集的实现"></a>面试题14.  并查集的实现</h5><h5 id="面试题15-调整-0-x-区间上的数出现的概率"><a href="#面试题15-调整-0-x-区间上的数出现的概率" class="headerlink" title="面试题15.  调整[0,x)区间上的数出现的概率"></a>面试题15.  调整[0,x)区间上的数出现的概率</h5><h5 id="面试题16-路径数组变为统计数组"><a href="#面试题16-路径数组变为统计数组" class="headerlink" title="面试题16.  路径数组变为统计数组"></a>面试题16.  路径数组变为统计数组</h5><h5 id="面试题17-正数数组的最小不可组成和"><a href="#面试题17-正数数组的最小不可组成和" class="headerlink" title="面试题17.  正数数组的最小不可组成和"></a>面试题17.  正数数组的最小不可组成和</h5><h5 id="面试题18-累加出整个范围所有的数最少还需几个数"><a href="#面试题18-累加出整个范围所有的数最少还需几个数" class="headerlink" title="面试题18.  累加出整个范围所有的数最少还需几个数"></a>面试题18.  累加出整个范围所有的数最少还需几个数</h5><h5 id="面试题19-一种字符串和数字的对应关系"><a href="#面试题19-一种字符串和数字的对应关系" class="headerlink" title="面试题19.  一种字符串和数字的对应关系"></a>面试题19.  一种字符串和数字的对应关系</h5><h5 id="面试题20-1到n中1出现的次数"><a href="#面试题20-1到n中1出现的次数" class="headerlink" title="面试题20.  1到n中1出现的次数"></a>面试题20.  1到n中1出现的次数</h5><h5 id="面试题21-从N个数中等概率打印M个数"><a href="#面试题21-从N个数中等概率打印M个数" class="headerlink" title="面试题21.  从N个数中等概率打印M个数"></a>面试题21.  从N个数中等概率打印M个数</h5><h5 id="面试题22-判断一个数是否是回文数"><a href="#面试题22-判断一个数是否是回文数" class="headerlink" title="面试题22.  判断一个数是否是回文数"></a>面试题22.  判断一个数是否是回文数</h5><h5 id="面试题23-在有序旋转数组中找到最小值"><a href="#面试题23-在有序旋转数组中找到最小值" class="headerlink" title="面试题23.  在有序旋转数组中找到最小值"></a>面试题23.  在有序旋转数组中找到最小值</h5><h5 id="面试题24-在有序旋转数组中找到一个数"><a href="#面试题24-在有序旋转数组中找到一个数" class="headerlink" title="面试题24.  在有序旋转数组中找到一个数"></a>面试题24.  在有序旋转数组中找到一个数</h5><h5 id="面试题25-数字的英文表达和中文表达"><a href="#面试题25-数字的英文表达和中文表达" class="headerlink" title="面试题25.  数字的英文表达和中文表达"></a>面试题25.  数字的英文表达和中文表达</h5><h5 id="面试题26-分糖果问题"><a href="#面试题26-分糖果问题" class="headerlink" title="面试题26.  分糖果问题"></a>面试题26.  分糖果问题</h5><h5 id="面试题27-一种消息接收并打印的结构设计"><a href="#面试题27-一种消息接收并打印的结构设计" class="headerlink" title="面试题27.  一种消息接收并打印的结构设计"></a>面试题27.  一种消息接收并打印的结构设计</h5><h5 id="面试题28-随时找到数据流的中位数"><a href="#面试题28-随时找到数据流的中位数" class="headerlink" title="面试题28.  随时找到数据流的中位数"></a>面试题28.  随时找到数据流的中位数</h5><h5 id="面试题29-在两个长度相等的排序数组中找到上中位数"><a href="#面试题29-在两个长度相等的排序数组中找到上中位数" class="headerlink" title="面试题29.  在两个长度相等的排序数组中找到上中位数"></a>面试题29.  在两个长度相等的排序数组中找到上中位数</h5><h5 id="面试题30-在两个排序数组中找到第k小的数"><a href="#面试题30-在两个排序数组中找到第k小的数" class="headerlink" title="面试题30.  在两个排序数组中找到第k小的数"></a>面试题30.  在两个排序数组中找到第k小的数</h5><h5 id="面试题31-两个有序数组间相加和的Top-k问题"><a href="#面试题31-两个有序数组间相加和的Top-k问题" class="headerlink" title="面试题31.  两个有序数组间相加和的Top  k问题"></a>面试题31.  两个有序数组间相加和的Top  k问题</h5><h5 id="面试题32-出现次数的Top-k问题"><a href="#面试题32-出现次数的Top-k问题" class="headerlink" title="面试题32.  出现次数的Top  k问题"></a>面试题32.  出现次数的Top  k问题</h5><h5 id="面试题33-Manacher-算法"><a href="#面试题33-Manacher-算法" class="headerlink" title="面试题33.  Manacher 算法"></a>面试题33.  Manacher 算法</h5><h5 id="面试题34-KMP算法"><a href="#面试题34-KMP算法" class="headerlink" title="面试题34.  KMP算法"></a>面试题34.  KMP算法</h5><h5 id="面试题35-丢棋子问题"><a href="#面试题35-丢棋子问题" class="headerlink" title="面试题35.  丢棋子问题"></a>面试题35.  丢棋子问题</h5><h5 id="面试题36-画匠问题"><a href="#面试题36-画匠问题" class="headerlink" title="面试题36.  画匠问题"></a>面试题36.  画匠问题</h5><h5 id="面试题37-邮局选址问题"><a href="#面试题37-邮局选址问题" class="headerlink" title="面试题37. 邮局选址问题"></a>面试题37. 邮局选址问题</h5>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法与数据结构——程序员代码面试指南/" rel="tag"># 算法与数据结构——程序员代码面试指南</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/29/算法面试题/" rel="next" title="算法面试题">
                <i class="fa fa-chevron-left"></i> 算法面试题
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/01/找工作/" rel="prev" title="找工作">
                找工作 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="木木">
            
              <p class="site-author-name" itemprop="name">木木</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#小知识点"><span class="nav-number">1.</span> <span class="nav-text">小知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#异或运算"><span class="nav-number">1.1.</span> <span class="nav-text">异或运算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#求中点"><span class="nav-number">1.2.</span> <span class="nav-text">求中点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#递归行为时间复杂度"><span class="nav-number">1.3.</span> <span class="nav-text">递归行为时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序算法"><span class="nav-number">2.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#选择排序"><span class="nav-number">2.1.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#冒泡排序"><span class="nav-number">2.2.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#插入排序"><span class="nav-number">2.3.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二分法"><span class="nav-number">2.4.</span> <span class="nav-text">二分法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#归并排序"><span class="nav-number">2.5.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#堆排序"><span class="nav-number">2.6.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#快速排序"><span class="nav-number">2.7.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#桶排序"><span class="nav-number">2.8.</span> <span class="nav-text">桶排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈和队列"><span class="nav-number">3.</span> <span class="nav-text">栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1：设计一个有-getMin-功能的栈"><span class="nav-number">3.1.</span> <span class="nav-text">面试题1：设计一个有 getMin 功能的栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2：由两个栈组成的队列"><span class="nav-number">3.2.</span> <span class="nav-text">面试题2：由两个栈组成的队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3：如何仅用递归函数和栈操作逆序一个栈-★"><span class="nav-number">3.3.</span> <span class="nav-text">面试题3：如何仅用递归函数和栈操作逆序一个栈  ★</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4：猫狗队列"><span class="nav-number">3.4.</span> <span class="nav-text">面试题4：猫狗队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5：用一个栈实现另一个栈的排序-★"><span class="nav-number">3.5.</span> <span class="nav-text">面试题5：用一个栈实现另一个栈的排序   ★</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6：用栈来解决汉诺塔问题"><span class="nav-number">3.6.</span> <span class="nav-text">面试题6：用栈来解决汉诺塔问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7：生成窗口最大值数组-★"><span class="nav-number">3.7.</span> <span class="nav-text">面试题7：生成窗口最大值数组   ★</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题8：单调栈结构-★"><span class="nav-number">3.8.</span> <span class="nav-text">面试题8：单调栈结构   ★</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题9：求最大子矩阵的大小-★"><span class="nav-number">3.9.</span> <span class="nav-text">面试题9：求最大子矩阵的大小   ★</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题10：最大值减去最小值小于或等于-num-的子数组数量"><span class="nav-number">3.10.</span> <span class="nav-text">面试题10：最大值减去最小值小于或等于 num 的子数组数量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题11：可见的山峰对数量"><span class="nav-number">3.11.</span> <span class="nav-text">面试题11：可见的山峰对数量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#指标A最大"><span class="nav-number">3.12.</span> <span class="nav-text">指标A最大</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链表"><span class="nav-number">4.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1：打印两个有序链表的公共部分"><span class="nav-number">4.1.</span> <span class="nav-text">面试题1：打印两个有序链表的公共部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2：在单链表和双链表中删除倒数第-k-个节点"><span class="nav-number">4.2.</span> <span class="nav-text">面试题2：在单链表和双链表中删除倒数第 k 个节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3：删除链表的中间节点和-a-b-处的节点"><span class="nav-number">4.3.</span> <span class="nav-text">面试题3：删除链表的中间节点和 a/b 处的节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4：反转单向和双向链表"><span class="nav-number">4.4.</span> <span class="nav-text">面试题4：反转单向和双向链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5：反转部分单向链表"><span class="nav-number">4.5.</span> <span class="nav-text">面试题5：反转部分单向链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6：环形单链表的约瑟夫问题"><span class="nav-number">4.6.</span> <span class="nav-text">面试题6：环形单链表的约瑟夫问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7：判断一个链表是否为回文结构"><span class="nav-number">4.7.</span> <span class="nav-text">面试题7：判断一个链表是否为回文结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式"><span class="nav-number">4.8.</span> <span class="nav-text">面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题9：复制含有随机指针节点的链表"><span class="nav-number">4.9.</span> <span class="nav-text">面试题9：复制含有随机指针节点的链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题10：两个单链表生成相加链表"><span class="nav-number">4.10.</span> <span class="nav-text">面试题10：两个单链表生成相加链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题11：两个单链表相交的一系列问题"><span class="nav-number">4.11.</span> <span class="nav-text">面试题11：两个单链表相交的一系列问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题12：将单链表的每-K-个节点之间逆序"><span class="nav-number">4.12.</span> <span class="nav-text">面试题12：将单链表的每 K 个节点之间逆序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题13：删除无序单链表中值重复出现的节点"><span class="nav-number">4.13.</span> <span class="nav-text">面试题13：删除无序单链表中值重复出现的节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题14：在单链表中删除指定值的节点"><span class="nav-number">4.14.</span> <span class="nav-text">面试题14：在单链表中删除指定值的节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题15：将搜索二叉树转换成双向链表"><span class="nav-number">4.15.</span> <span class="nav-text">面试题15：将搜索二叉树转换成双向链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题16：单链表的选择排序"><span class="nav-number">4.16.</span> <span class="nav-text">面试题16：单链表的选择排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题17：一种怪异的节点删除方式"><span class="nav-number">4.17.</span> <span class="nav-text">面试题17：一种怪异的节点删除方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题18：向有序的环形单链表中插入新节点"><span class="nav-number">4.18.</span> <span class="nav-text">面试题18：向有序的环形单链表中插入新节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题19：合并两个有序的单链表"><span class="nav-number">4.19.</span> <span class="nav-text">面试题19：合并两个有序的单链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题20：按照左右半区的方式重新组合单链表"><span class="nav-number">4.20.</span> <span class="nav-text">面试题20：按照左右半区的方式重新组合单链表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树"><span class="nav-number">5.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历"><span class="nav-number">5.1.</span> <span class="nav-text">面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2：打印二叉树的边界节点"><span class="nav-number">5.2.</span> <span class="nav-text">面试题2：打印二叉树的边界节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3：如何较为直观地打印二叉树"><span class="nav-number">5.3.</span> <span class="nav-text">面试题3：如何较为直观地打印二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4：二叉树地序列化和反序列化"><span class="nav-number">5.4.</span> <span class="nav-text">面试题4：二叉树地序列化和反序列化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5：遍历二叉树地神级方法"><span class="nav-number">5.5.</span> <span class="nav-text">面试题5：遍历二叉树地神级方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6：在二叉树中找到累加和为指定值地最长路径长度"><span class="nav-number">5.6.</span> <span class="nav-text">面试题6：在二叉树中找到累加和为指定值地最长路径长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7：找到二叉树中最大搜索二叉子数"><span class="nav-number">5.7.</span> <span class="nav-text">面试题7：找到二叉树中最大搜索二叉子数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构"><span class="nav-number">5.8.</span> <span class="nav-text">面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题9：二叉树的按层打印预-ZigZag-打印"><span class="nav-number">5.9.</span> <span class="nav-text">面试题9：二叉树的按层打印预 ZigZag 打印</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题10：调整搜索二叉树中两个错误的节点"><span class="nav-number">5.10.</span> <span class="nav-text">面试题10：调整搜索二叉树中两个错误的节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题11：判断-t1-树是否包含-t2-树全部的拓扑结构"><span class="nav-number">5.11.</span> <span class="nav-text">面试题11：判断 t1 树是否包含 t2 树全部的拓扑结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题12：判断-t1-树中是否有与-t2-树拓扑结构完全相同的子数"><span class="nav-number">5.12.</span> <span class="nav-text">面试题12：判断 t1 树中是否有与 t2 树拓扑结构完全相同的子数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题13：判断二叉树是否为平衡二叉树"><span class="nav-number">5.13.</span> <span class="nav-text">面试题13：判断二叉树是否为平衡二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题14：根据后序数组重建搜索二叉树"><span class="nav-number">5.14.</span> <span class="nav-text">面试题14：根据后序数组重建搜索二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树"><span class="nav-number">5.15.</span> <span class="nav-text">面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题16：通过有序数组生成平衡搜索二叉树"><span class="nav-number">5.16.</span> <span class="nav-text">面试题16：通过有序数组生成平衡搜索二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题17：在二叉树中找到一个节点的后继节点"><span class="nav-number">5.17.</span> <span class="nav-text">面试题17：在二叉树中找到一个节点的后继节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题18：在二叉树中找到两个节点的最低公共祖先"><span class="nav-number">5.18.</span> <span class="nav-text">面试题18：在二叉树中找到两个节点的最低公共祖先</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题19：Tarjan-算法与并查集解决二叉树节点间最低公共祖先的批量查询问题"><span class="nav-number">5.19.</span> <span class="nav-text">面试题19：Tarjan 算法与并查集解决二叉树节点间最低公共祖先的批量查询问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题20：二叉树节点间的最大距离问题"><span class="nav-number">5.20.</span> <span class="nav-text">面试题20：二叉树节点间的最大距离问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题21：派对的最大快乐值"><span class="nav-number">5.21.</span> <span class="nav-text">面试题21：派对的最大快乐值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题22：通过先序和中序数组生成后序数组"><span class="nav-number">5.22.</span> <span class="nav-text">面试题22：通过先序和中序数组生成后序数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题23：统计和生成所有不同的二叉树"><span class="nav-number">5.23.</span> <span class="nav-text">面试题23：统计和生成所有不同的二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题24：统计完全二叉树的节点树"><span class="nav-number">5.24.</span> <span class="nav-text">面试题24：统计完全二叉树的节点树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归和动态规划"><span class="nav-number">6.</span> <span class="nav-text">递归和动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1：斐波那契数列问题的递归和动态规划"><span class="nav-number">6.1.</span> <span class="nav-text">面试题1：斐波那契数列问题的递归和动态规划</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2：矩阵的最小路径和"><span class="nav-number">6.2.</span> <span class="nav-text">面试题2：矩阵的最小路径和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3：换钱的最少货币数"><span class="nav-number">6.3.</span> <span class="nav-text">面试题3：换钱的最少货币数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4：机器人达到指定位置方法数"><span class="nav-number">6.4.</span> <span class="nav-text">面试题4：机器人达到指定位置方法数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5：换钱的方法数"><span class="nav-number">6.5.</span> <span class="nav-text">面试题5：换钱的方法数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6：打气球的最大分数"><span class="nav-number">6.6.</span> <span class="nav-text">面试题6：打气球的最大分数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7：最长递增子序列"><span class="nav-number">6.7.</span> <span class="nav-text">面试题7：最长递增子序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题8：信封嵌套问题"><span class="nav-number">6.8.</span> <span class="nav-text">面试题8：信封嵌套问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题9：汉诺塔问题"><span class="nav-number">6.9.</span> <span class="nav-text">面试题9：汉诺塔问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题10：最长公共子序列问题"><span class="nav-number">6.10.</span> <span class="nav-text">面试题10：最长公共子序列问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题11：最长公共子串问题"><span class="nav-number">6.11.</span> <span class="nav-text">面试题11：最长公共子串问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题12：子数组异或和为0的最多划分"><span class="nav-number">6.12.</span> <span class="nav-text">面试题12：子数组异或和为0的最多划分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题13：最小编辑代价"><span class="nav-number">6.13.</span> <span class="nav-text">面试题13：最小编辑代价</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题14：字符串的交错组成"><span class="nav-number">6.14.</span> <span class="nav-text">面试题14：字符串的交错组成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题15：龙与地下城游戏问题"><span class="nav-number">6.15.</span> <span class="nav-text">面试题15：龙与地下城游戏问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题16：数字字符串转换为字符组合的种数"><span class="nav-number">6.16.</span> <span class="nav-text">面试题16：数字字符串转换为字符组合的种数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题17：表达式得到期望结果的组成种树"><span class="nav-number">6.17.</span> <span class="nav-text">面试题17：表达式得到期望结果的组成种树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题18：排成一条线的纸牌博弈问题"><span class="nav-number">6.18.</span> <span class="nav-text">面试题18：排成一条线的纸牌博弈问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题19：跳跃游戏"><span class="nav-number">6.19.</span> <span class="nav-text">面试题19：跳跃游戏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题20：数组中的最长连续序列"><span class="nav-number">6.20.</span> <span class="nav-text">面试题20：数组中的最长连续序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题21：N-皇后问题"><span class="nav-number">6.21.</span> <span class="nav-text">面试题21：N 皇后问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串"><span class="nav-number">7.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1：判断两个字符串是否互为变形词"><span class="nav-number">7.1.</span> <span class="nav-text">面试题1：判断两个字符串是否互为变形词</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2：判断两个字符串是否互为旋转词"><span class="nav-number">7.2.</span> <span class="nav-text">面试题2：判断两个字符串是否互为旋转词</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3：字符串中统计字符串"><span class="nav-number">7.3.</span> <span class="nav-text">面试题3：字符串中统计字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4：判断字符数组中是否所有的字符都只出现过一次"><span class="nav-number">7.4.</span> <span class="nav-text">面试题4：判断字符数组中是否所有的字符都只出现过一次</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5：在有序但包含空数组中查找字符串"><span class="nav-number">7.5.</span> <span class="nav-text">面试题5：在有序但包含空数组中查找字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6：字符串的调整与替换"><span class="nav-number">7.6.</span> <span class="nav-text">面试题6：字符串的调整与替换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7：翻转字符串"><span class="nav-number">7.7.</span> <span class="nav-text">面试题7：翻转字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题8：完美洗牌问题"><span class="nav-number">7.8.</span> <span class="nav-text">面试题8：完美洗牌问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题9：删除多余字符得到字典序最小的字符串"><span class="nav-number">7.9.</span> <span class="nav-text">面试题9：删除多余字符得到字典序最小的字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题10：数组中两个字符串的最小距离"><span class="nav-number">7.10.</span> <span class="nav-text">面试题10：数组中两个字符串的最小距离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题11：字符串的转换路径问题"><span class="nav-number">7.11.</span> <span class="nav-text">面试题11：字符串的转换路径问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题12：添加最少字符使字符串整体都是回文字符串"><span class="nav-number">7.12.</span> <span class="nav-text">面试题12：添加最少字符使字符串整体都是回文字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题13：括号字符串的有效性和最长有效长度"><span class="nav-number">7.13.</span> <span class="nav-text">面试题13：括号字符串的有效性和最长有效长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题14：公司字符串求值"><span class="nav-number">7.14.</span> <span class="nav-text">面试题14：公司字符串求值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题15：0-左边必有-1-的二进制字符串数量"><span class="nav-number">7.15.</span> <span class="nav-text">面试题15：0 左边必有 1 的二进制字符串数量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题16：拼接所有字符串产生字典顺序最小的大写字符串"><span class="nav-number">7.16.</span> <span class="nav-text">面试题16：拼接所有字符串产生字典顺序最小的大写字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题17：找到字符串的最长无重复字符子串"><span class="nav-number">7.17.</span> <span class="nav-text">面试题17：找到字符串的最长无重复字符子串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题18：找到指定的新类型字符"><span class="nav-number">7.18.</span> <span class="nav-text">面试题18：找到指定的新类型字符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题19：旋变字符串问题"><span class="nav-number">7.19.</span> <span class="nav-text">面试题19：旋变字符串问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题20：最小包含子串的长度"><span class="nav-number">7.20.</span> <span class="nav-text">面试题20：最小包含子串的长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题21：回文最少分割数"><span class="nav-number">7.21.</span> <span class="nav-text">面试题21：回文最少分割数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题22：字符串匹配问题"><span class="nav-number">7.22.</span> <span class="nav-text">面试题22：字符串匹配问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题23：字典树（前缀树）的实现"><span class="nav-number">7.23.</span> <span class="nav-text">面试题23：字典树（前缀树）的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题24：子数组的最大异或和"><span class="nav-number">7.24.</span> <span class="nav-text">面试题24：子数组的最大异或和</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#大数据和空间限制"><span class="nav-number">8.</span> <span class="nav-text">大数据和空间限制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1-认识布隆过滤器"><span class="nav-number">8.1.</span> <span class="nav-text">面试题1.  认识布隆过滤器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2-只用2GB内存在20亿个整数中找到出现次数最多的数"><span class="nav-number">8.2.</span> <span class="nav-text">面试题2.  只用2GB内存在20亿个整数中找到出现次数最多的数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3-40亿个非负整数中找到未出现的数"><span class="nav-number">8.3.</span> <span class="nav-text">面试题3.  40亿个非负整数中找到未出现的数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4-找到100亿个URL中重复的URL及搜索词汇的Top-K问题"><span class="nav-number">8.4.</span> <span class="nav-text">面试题4.  找到100亿个URL中重复的URL及搜索词汇的Top  K问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5-40亿个非负整数中找到出现两次的数和所有数的中位数（"><span class="nav-number">8.5.</span> <span class="nav-text">面试题5.  40亿个非负整数中找到出现两次的数和所有数的中位数（</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6-一致性哈希算法的基本原理"><span class="nav-number">8.6.</span> <span class="nav-text">面试题6.  一致性哈希算法的基本原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7-岛问题"><span class="nav-number">8.7.</span> <span class="nav-text">面试题7.  岛问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#位运算"><span class="nav-number">9.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1-不用额外变量交换两个整数的值"><span class="nav-number">9.1.</span> <span class="nav-text">面试题1.  不用额外变量交换两个整数的值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2-不用做任何比较判断找出两个数中较大的数"><span class="nav-number">9.2.</span> <span class="nav-text">面试题2.  不用做任何比较判断找出两个数中较大的数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3-只用位运算不用算术运算实现整数的加减乘除运算（"><span class="nav-number">9.3.</span> <span class="nav-text">面试题3.  只用位运算不用算术运算实现整数的加减乘除运算（</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4-整数的二进制数表达中有多少个1"><span class="nav-number">9.4.</span> <span class="nav-text">面试题4. 整数的二进制数表达中有多少个1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5-在其他数都出现偶数次的数组中找到出现奇数次的数（"><span class="nav-number">9.5.</span> <span class="nav-text">面试题5.  在其他数都出现偶数次的数组中找到出现奇数次的数（</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6-在其他数都出现k次的数组中找到只出现一次的数"><span class="nav-number">9.6.</span> <span class="nav-text">面试题6.  在其他数都出现k次的数组中找到只出现一次的数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组和矩阵"><span class="nav-number">10.</span> <span class="nav-text">数组和矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1-转圈打印矩阵"><span class="nav-number">10.1.</span> <span class="nav-text">面试题1.  转圈打印矩阵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2-将正方形矩阵顺时针转动90°"><span class="nav-number">10.2.</span> <span class="nav-text">面试题2.  将正方形矩阵顺时针转动90°</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3-“之”字形打印矩阵"><span class="nav-number">10.3.</span> <span class="nav-text">面试题3.  “之”字形打印矩阵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4-找到无序数组中最小的k个数（O-Nlogk-的方法"><span class="nav-number">10.4.</span> <span class="nav-text">面试题4.   找到无序数组中最小的k个数（O(Nlogk)的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5-需要排序的最短子数组长度"><span class="nav-number">10.5.</span> <span class="nav-text">面试题5.  需要排序的最短子数组长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6-在数组中找到出现次数大于N-K的数"><span class="nav-number">10.6.</span> <span class="nav-text">面试题6.  在数组中找到出现次数大于N/K的数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7-在行列都排好序的矩阵中找指定数"><span class="nav-number">10.7.</span> <span class="nav-text">面试题7.  在行列都排好序的矩阵中找指定数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题8-最长的可整合子数组的长度"><span class="nav-number">10.8.</span> <span class="nav-text">面试题8.  最长的可整合子数组的长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题9-不重复打印排序数组中相加和为给定值的所有二元组和三元组"><span class="nav-number">10.9.</span> <span class="nav-text">面试题9.  不重复打印排序数组中相加和为给定值的所有二元组和三元组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题10-未排序正数数组中累加和为给定值的最长子数组长度"><span class="nav-number">10.10.</span> <span class="nav-text">面试题10. 未排序正数数组中累加和为给定值的最长子数组长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题11-未排序数组中累加和为给定值的最长子数组系列问题"><span class="nav-number">10.11.</span> <span class="nav-text">面试题11.  未排序数组中累加和为给定值的最长子数组系列问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题12-未排序数组中累加和小于或等于给定值的最长子数组长度"><span class="nav-number">10.12.</span> <span class="nav-text">面试题12.  未排序数组中累加和小于或等于给定值的最长子数组长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题13-计算数组的小和"><span class="nav-number">10.13.</span> <span class="nav-text">面试题13.  计算数组的小和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题14-自然数数组的排序"><span class="nav-number">10.14.</span> <span class="nav-text">面试题14.  自然数数组的排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题15-奇数下标都是奇数或者偶数下标都是偶数"><span class="nav-number">10.15.</span> <span class="nav-text">面试题15.  奇数下标都是奇数或者偶数下标都是偶数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题16-子数组的最大累加和问题"><span class="nav-number">10.16.</span> <span class="nav-text">面试题16.  子数组的最大累加和问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题17-子矩阵的最大累加和问题"><span class="nav-number">10.17.</span> <span class="nav-text">面试题17.  子矩阵的最大累加和问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题18-在数组中找到一个局部最小的位置"><span class="nav-number">10.18.</span> <span class="nav-text">面试题18.  在数组中找到一个局部最小的位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题19-数组中子数组的最大累乘积"><span class="nav-number">10.19.</span> <span class="nav-text">面试题19.  数组中子数组的最大累乘积</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题20-打印N个数组整体最大的Top-K"><span class="nav-number">10.20.</span> <span class="nav-text">面试题20.  打印N个数组整体最大的Top  K</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题21-边界都是1的最大正方形大小"><span class="nav-number">10.21.</span> <span class="nav-text">面试题21.  边界都是1的最大正方形大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题22-不包含本位置值的累乘数组"><span class="nav-number">10.22.</span> <span class="nav-text">面试题22.  不包含本位置值的累乘数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题23-数组的partition调整"><span class="nav-number">10.23.</span> <span class="nav-text">面试题23.  数组的partition调整</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题24-求最短通路值"><span class="nav-number">10.24.</span> <span class="nav-text">面试题24.  求最短通路值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题25-数组中未出现的最小正整数"><span class="nav-number">10.25.</span> <span class="nav-text">面试题25. 数组中未出现的最小正整数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题26-数组排序之后相邻数的最大差值"><span class="nav-number">10.26.</span> <span class="nav-text">面试题26.  数组排序之后相邻数的最大差值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题27-做项目的最大收益问题"><span class="nav-number">10.27.</span> <span class="nav-text">面试题27.  做项目的最大收益问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题28-分金条的最小花费"><span class="nav-number">10.28.</span> <span class="nav-text">面试题28.  分金条的最小花费</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题29-大楼轮廓问题"><span class="nav-number">10.29.</span> <span class="nav-text">面试题29.  大楼轮廓问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题30-加油站良好出发点问题"><span class="nav-number">10.30.</span> <span class="nav-text">面试题30.  加油站良好出发点问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题31-容器盛水问题"><span class="nav-number">10.31.</span> <span class="nav-text">面试题31.  容器盛水问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#绳子最多能覆盖的点个数"><span class="nav-number">10.32.</span> <span class="nav-text">绳子最多能覆盖的点个数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他"><span class="nav-number">11.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1-从5随机到7随机及其扩展"><span class="nav-number">11.1.</span> <span class="nav-text">面试题1.  从5随机到7随机及其扩展</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2-一行代码求两个数的最大公约数"><span class="nav-number">11.2.</span> <span class="nav-text">面试题2.  一行代码求两个数的最大公约数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3-有关阶乘的两个问题"><span class="nav-number">11.3.</span> <span class="nav-text">面试题3.  有关阶乘的两个问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4-判断一个点是否在矩形内部"><span class="nav-number">11.4.</span> <span class="nav-text">面试题4.  判断一个点是否在矩形内部</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5-判断一个点是否在三角形内部"><span class="nav-number">11.5.</span> <span class="nav-text">面试题5.  判断一个点是否在三角形内部</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6-折纸问题"><span class="nav-number">11.6.</span> <span class="nav-text">面试题6.  折纸问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7-能否完美地拼成矩形"><span class="nav-number">11.7.</span> <span class="nav-text">面试题7.  能否完美地拼成矩形</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题8-蓄水池算法"><span class="nav-number">11.8.</span> <span class="nav-text">面试题8.  蓄水池算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题9-设计有-setAll-功能的哈希表"><span class="nav-number">11.9.</span> <span class="nav-text">面试题9.  设计有 setAll 功能的哈希表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题10-最大的-leftMax-与-rightMax-之差的绝对值"><span class="nav-number">11.10.</span> <span class="nav-text">面试题10.  最大的 leftMax 与 rightMax 之差的绝对值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题11-设计LRU缓存结构"><span class="nav-number">11.11.</span> <span class="nav-text">面试题11.  设计LRU缓存结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题12-LFU缓存结构设计"><span class="nav-number">11.12.</span> <span class="nav-text">面试题12.  LFU缓存结构设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题13-设计-RandomPool-结构"><span class="nav-number">11.13.</span> <span class="nav-text">面试题13.  设计 RandomPool 结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题14-并查集的实现"><span class="nav-number">11.14.</span> <span class="nav-text">面试题14.  并查集的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题15-调整-0-x-区间上的数出现的概率"><span class="nav-number">11.15.</span> <span class="nav-text">面试题15.  调整[0,x)区间上的数出现的概率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题16-路径数组变为统计数组"><span class="nav-number">11.16.</span> <span class="nav-text">面试题16.  路径数组变为统计数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题17-正数数组的最小不可组成和"><span class="nav-number">11.17.</span> <span class="nav-text">面试题17.  正数数组的最小不可组成和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题18-累加出整个范围所有的数最少还需几个数"><span class="nav-number">11.18.</span> <span class="nav-text">面试题18.  累加出整个范围所有的数最少还需几个数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题19-一种字符串和数字的对应关系"><span class="nav-number">11.19.</span> <span class="nav-text">面试题19.  一种字符串和数字的对应关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题20-1到n中1出现的次数"><span class="nav-number">11.20.</span> <span class="nav-text">面试题20.  1到n中1出现的次数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题21-从N个数中等概率打印M个数"><span class="nav-number">11.21.</span> <span class="nav-text">面试题21.  从N个数中等概率打印M个数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题22-判断一个数是否是回文数"><span class="nav-number">11.22.</span> <span class="nav-text">面试题22.  判断一个数是否是回文数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题23-在有序旋转数组中找到最小值"><span class="nav-number">11.23.</span> <span class="nav-text">面试题23.  在有序旋转数组中找到最小值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题24-在有序旋转数组中找到一个数"><span class="nav-number">11.24.</span> <span class="nav-text">面试题24.  在有序旋转数组中找到一个数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题25-数字的英文表达和中文表达"><span class="nav-number">11.25.</span> <span class="nav-text">面试题25.  数字的英文表达和中文表达</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题26-分糖果问题"><span class="nav-number">11.26.</span> <span class="nav-text">面试题26.  分糖果问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题27-一种消息接收并打印的结构设计"><span class="nav-number">11.27.</span> <span class="nav-text">面试题27.  一种消息接收并打印的结构设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题28-随时找到数据流的中位数"><span class="nav-number">11.28.</span> <span class="nav-text">面试题28.  随时找到数据流的中位数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题29-在两个长度相等的排序数组中找到上中位数"><span class="nav-number">11.29.</span> <span class="nav-text">面试题29.  在两个长度相等的排序数组中找到上中位数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题30-在两个排序数组中找到第k小的数"><span class="nav-number">11.30.</span> <span class="nav-text">面试题30.  在两个排序数组中找到第k小的数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题31-两个有序数组间相加和的Top-k问题"><span class="nav-number">11.31.</span> <span class="nav-text">面试题31.  两个有序数组间相加和的Top  k问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题32-出现次数的Top-k问题"><span class="nav-number">11.32.</span> <span class="nav-text">面试题32.  出现次数的Top  k问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题33-Manacher-算法"><span class="nav-number">11.33.</span> <span class="nav-text">面试题33.  Manacher 算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题34-KMP算法"><span class="nav-number">11.34.</span> <span class="nav-text">面试题34.  KMP算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题35-丢棋子问题"><span class="nav-number">11.35.</span> <span class="nav-text">面试题35.  丢棋子问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题36-画匠问题"><span class="nav-number">11.36.</span> <span class="nav-text">面试题36.  画匠问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题37-邮局选址问题"><span class="nav-number">11.37.</span> <span class="nav-text">面试题37. 邮局选址问题</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">木木</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
