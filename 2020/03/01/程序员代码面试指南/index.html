<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法与数据结构——程序员代码面试指南,">





  <link rel="alternate" href="/atom.xml" title="木木的博客" type="application/atom+xml">






<meta name="description" content="参考：所有动图来自牛客网（ https://www.nowcoder.com/discuss/198840?type=1 ）和 RUNOOB.COM 小知识点异或运算异或运算（无进位相加，相同为0， 不同为1）比正常加减速度快，异或运算的性质  a ⊕ b = b  ⊕ a；a  ⊕  (b  ⊕  c) = (a  ⊕  b)  ⊕  c；0  ⊕ N = N；N ⊕ N = 0 交换两个数的值">
<meta name="keywords" content="算法与数据结构——程序员代码面试指南">
<meta property="og:type" content="article">
<meta property="og:title" content="程序员代码面试指南">
<meta property="og:url" content="http://pl741.github.io/2020/03/01/程序员代码面试指南/index.html">
<meta property="og:site_name" content="木木的博客">
<meta property="og:description" content="参考：所有动图来自牛客网（ https://www.nowcoder.com/discuss/198840?type=1 ）和 RUNOOB.COM 小知识点异或运算异或运算（无进位相加，相同为0， 不同为1）比正常加减速度快，异或运算的性质  a ⊕ b = b  ⊕ a；a  ⊕  (b  ⊕  c) = (a  ⊕  b)  ⊕  c；0  ⊕ N = N；N ⊕ N = 0 交换两个数的值">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://pl741.github.io/2020/03/01/程序员代码面试指南/selectionSort.gif">
<meta property="og:image" content="http://pl741.github.io/2020/03/01/程序员代码面试指南/bubbleSort.gif">
<meta property="og:image" content="http://pl741.github.io/2020/03/01/程序员代码面试指南/insertionSort.gif">
<meta property="og:image" content="http://pl741.github.io/2020/03/01/程序员代码面试指南/1.jpg">
<meta property="og:image" content="http://pl741.github.io/2020/03/01/程序员代码面试指南/mergeSort.gif">
<meta property="og:image" content="http://pl741.github.io/2020/03/01/程序员代码面试指南/heapSort.gif">
<meta property="og:image" content="http://pl741.github.io/2020/03/01/程序员代码面试指南/2.jpg">
<meta property="og:updated_time" content="2020-04-24T07:54:05.362Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员代码面试指南">
<meta name="twitter:description" content="参考：所有动图来自牛客网（ https://www.nowcoder.com/discuss/198840?type=1 ）和 RUNOOB.COM 小知识点异或运算异或运算（无进位相加，相同为0， 不同为1）比正常加减速度快，异或运算的性质  a ⊕ b = b  ⊕ a；a  ⊕  (b  ⊕  c) = (a  ⊕  b)  ⊕  c；0  ⊕ N = N；N ⊕ N = 0 交换两个数的值">
<meta name="twitter:image" content="http://pl741.github.io/2020/03/01/程序员代码面试指南/selectionSort.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'D7ALJV5SO6',
      apiKey: '6e20ed4f9126e4bd7125665a8b2f2a43',
      indexName: 'MUMU',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"找不到关于 ${query} 的文章","hits_stats":"共找到 ${hits} 篇文章，花了 ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://pl741.github.io/2020/03/01/程序员代码面试指南/">





  <title>程序员代码面试指南 | 木木的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">木木的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">木木的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          <!--增加的代码 start-->

          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://pl741.github.io/2020/03/01/程序员代码面试指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="木木">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="木木的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">程序员代码面试指南</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-01T14:18:48+08:00">
                2020-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python算法题/" itemprop="url" rel="index">
                    <span itemprop="name">Python算法题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>参考：所有动图来自牛客网（ <a href="https://www.nowcoder.com/discuss/198840?type=1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/198840?type=1</a> ）和 RUNOOB.COM</p>
<h4 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h4><h5 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h5><p>异或运算（<font color="red">无进位相加，相同为0， 不同为1</font>）比正常加减速度快，异或运算的性质  a ⊕ b = b  ⊕ a；a  ⊕  (b  ⊕  c) = (a  ⊕  b)  ⊕  c；0  ⊕ N = N；N ⊕ N = 0</p>
<p>交换两个数的值，不申请额外的变量：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 数组中只有一种数出现奇数次，其他均出现偶数次，利用时间复杂度 $O(1)$，额外空间复杂度 $O(1)$ 找到出现奇数次的数。[136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)  [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)（137题中一个数字出现1次，其他数字出现3次，没看懂使用异或运算的算法）</span><br><span class="line"></span><br><span class="line">2. 数组中有两种数出现奇数次，找出这两个数。</span><br><span class="line"></span><br><span class="line">   eor = 0 与数组中所有数都异或一次 ==&gt; eor = 两个出现奇数次的数的异或结果，且eor != 0  ——&gt; eor 的二进制表达中有一位为 1，设k位上为 1，找出数组中所有 k 位为 1 的数，异或这些数的结果为 eor&apos;，则eor&apos; 一定是其中一个出现奇数次的数。</span><br><span class="line"></span><br><span class="line">   &lt;font color=red&gt;提取一个不等于0的数最右侧的1&lt;/font&gt;：位移 for 循环（不快）；（~eor)+1 &amp; eor 即取反加1，再和自己与</span><br><span class="line"></span><br><span class="line">   ```python</span><br><span class="line">   def printOddTimesNum2(arr):</span><br><span class="line">   	eor = 0</span><br><span class="line">   	eorhasOne = 0</span><br><span class="line">   	for i in arr:</span><br><span class="line">   		eor ^= i</span><br><span class="line">   	rightOne = eor &amp; (~eor + 1)</span><br><span class="line">   	for i in arr:</span><br><span class="line">   		if i &amp; rightOne != 0:</span><br><span class="line">   			eorhasOne ^= i</span><br><span class="line">   	return eorhasOne, (eor ^ eorhasOne)</span><br></pre></td></tr></table></figure></p>
<h5 id="求中点"><a href="#求中点" class="headerlink" title="求中点"></a>求中点</h5><p>正常 $ L + R$ 有可能会溢出，——》 $L + ((L-R）&gt;&gt;1)$</p>
<h5 id="递归行为时间复杂度"><a href="#递归行为时间复杂度" class="headerlink" title="递归行为时间复杂度"></a>递归行为时间复杂度</h5><p>$master$ 公式：$T(N) = a<em>T(N/b) + O(N^d)$<br>$\log(b, a) &gt; d$ 复杂度为 $O(N</em>\log(b, a))$<br>$\log(b, a) = d$ 复杂度为 $O(N^d*\log N)$<br>$\log(b, a) &lt; d$ 复杂度为 $O(N^d)$</p>
<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>排序测试用例：</p>
<ol>
<li>已经排序好的数组</li>
<li>元素的值全部相等或者元素的值近似相等</li>
<li>随机生成的数据</li>
</ol>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>每次从待排序的数据中选择最小的数，交换待排数组的起始位置与最小元素；再从剩余的未排序数组中选择最小元素，以此类推。<strong><font color="red">每次找最小的值放在 i​ 位置</font></strong>。</p>
<img src="/2020/03/01/程序员代码面试指南/selectionSort.gif">
<p>时间复杂度 $O(N^{2})$，额外空间复杂度 $O(1)$。<strong>特点：在一般情况下或者在平均来看，选择排序在排序过程中交换元素的次数最少。</strong>选择排序的运行时间和数据本身所具有的特点无关，优点：排序过程中，元素交换的总次数是最少的，如果移动元素的成本很大，可以考虑选择排序。缺点：排序过程中元素两两间比较的次数较多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">			minIndex = i</span><br><span class="line">			<span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(arr)):</span><br><span class="line">				<span class="keyword">if</span> arr[j] &lt; arr[minIndex]:</span><br><span class="line">					minIndex = j</span><br><span class="line">			self.swap(arr, i, minIndex)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">		tmp = arr[i]</span><br><span class="line">		arr[i] = arr[j]</span><br><span class="line">		arr[j] = tmp</span><br><span class="line">		print(arr)</span><br></pre></td></tr></table></figure>
<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>依次比较两个元素，按照谁打谁放后的规则，每一次循环可以确定最大值。<font color="red">谁大谁往后，每次循环可以确定最大值。</font>时间复杂度 $O(N^{2})$，额外空间复杂度 $O(1)$。</p>
<img src="/2020/03/01/程序员代码面试指南/bubbleSort.gif">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">			<span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">				<span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">					self.swap(arr, j, j+<span class="number">1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">		tmp = arr[i]</span><br><span class="line">		arr[i] = arr[j]</span><br><span class="line">		arr[j] = tmp</span><br><span class="line">		print(i, j, arr)</span><br></pre></td></tr></table></figure>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置插入。（有两种将未排数据插入的方式：逐个交换——往前看，若未排序数据小则交换两个数字的位置；逐个后退——从已排序序列末尾开始，若比待排序数据大则往后退）<font color="red">往前看，小交换，0~1范围有序——&gt;0~2范围有序….</font> 时间复杂度 $O(N^{2})$，额外空间复杂度 $O(1)$。<strong>是时间复杂度为</strong>$O(N^2)$<strong>中最好的排序方法</strong>。在数组近乎有序的情况下，插入排序会很快完成排序任务，即若带排序数组有序，则插入排序的时间复杂度为 $O(N)$。算法复杂度与实际的数据状况有关。</p>
<img src="/2020/03/01/程序员代码面试指南/insertionSort.gif">   <img src="/2020/03/01/程序员代码面试指南/1.jpg">  
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">			<span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># 往前看</span></span><br><span class="line">				<span class="keyword">if</span> arr[j+<span class="number">1</span>] &lt; arr[j]: <span class="comment"># 小交换</span></span><br><span class="line">					self.swap(arr, j, j+<span class="number">1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">		tmp = arr[i]</span><br><span class="line">		arr[i] = arr[j]</span><br><span class="line">		arr[j] = tmp</span><br><span class="line">		print(i, j, arr)</span><br></pre></td></tr></table></figure>
<h5 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h5><ol>
<li><p>在一个有序数组中，找某个数是否存在，遍历的方法时间复杂度为$O(N)$， 二分法的时间复杂度为$O(\log N)$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSExist</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, arr, num)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">		L = <span class="number">0</span></span><br><span class="line">		R = len(arr) - <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> L &lt; R:</span><br><span class="line">			mid = L + ((R - L) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span> arr[mid] == num:</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">			<span class="keyword">elif</span> arr[mid] &gt; num:</span><br><span class="line">				R = mid - <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				L = mid + <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> arr[L] == num:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在一个有序数组中，找&gt;=某个数最左侧的位置，例如：找到 [1, 1, 1, 1,  2,  2, 2, 2, 3, 3, 3, 4, 4] 数组中大于等于 2 的最左侧的位置。 <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSNearLeft</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">nearestIndex</span><span class="params">(self, arr, value)</span>:</span></span><br><span class="line">	    L = <span class="number">0</span></span><br><span class="line">        R = len(nums) - <span class="number">1</span></span><br><span class="line">        indexL = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">            mid = L + ((R - L) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                R = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                L = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                indexL = mid</span><br><span class="line">                R = mid - <span class="number">1</span></span><br><span class="line">        L = <span class="number">0</span></span><br><span class="line">        R = len(nums) - <span class="number">1</span></span><br><span class="line">        indexR = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">            mid = L + ((R - L &gt;&gt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                L = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                R = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                indexR = mid</span><br><span class="line">                L = mid + <span class="number">1</span></span><br><span class="line">         <span class="keyword">return</span> [indexL, indexR]</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部最小值问题，一个无需数组中，任何两个相邻数在数组中不等，找到一个局部最小。 <a href="https://www.nowcoder.com/practice/d1c8838fc9e54b89bc10b5b6d2b52157?tpId=101&amp;tqId=33096&amp;tPage=1&amp;rp=1&amp;ru=/ta/programmer-code-interview-guide&amp;qru=/ta/programmer-code-interview-guide/question-ranking" target="_blank" rel="noopener">在数组中找到一个局部最小的位置</a></p>
<p>情况一：$ arr[0] &lt; arr[1]$，返回位置 0；情况二：$arr[N-1] &lt; arr[N-2]$，返回位置 $N-1$；情况三：$arr[i-1] &gt; arr[i] &lt; arr[i+1]$，返回位置 $i$。</p>
<p>做法：比较 0, 1位置上的数，若$ arr[0] &lt; arr[1]$找到，否则 ==&gt; 比较$N-1， N-2$，若$arr[N-1] &lt; arr[N-2]$找到，否则  ==&gt; 0~N-1 上比存在局部最小  ==&gt; 找到中间位置 mid，比较，若$arr[mid-1] &gt; arr[mid] &lt; arr[mid+1]$找到，否则 ==&gt; 若$arr[mid-1] &lt; arr[mid]$，缩小范围到 0~mid，若$arr[mid+1] &lt; arr[mid]$，缩小范围到 mid~N-1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">LocalMin</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) == <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">		<span class="keyword">if</span> len(arr) == <span class="number">1</span> <span class="keyword">or</span> arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		N = len(arr)</span><br><span class="line">		<span class="keyword">if</span> arr[N<span class="number">-1</span>] &lt; arr[N<span class="number">-2</span>]:</span><br><span class="line">			<span class="keyword">return</span> N<span class="number">-1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			 L = <span class="number">1</span></span><br><span class="line">			 R = N<span class="number">-2</span></span><br><span class="line">			 <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">			 	mid = L + ((R - L) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">			 	<span class="keyword">if</span> arr[mid] &gt; arr[mid+<span class="number">1</span>]:</span><br><span class="line">			 		L = mid + <span class="number">1</span></span><br><span class="line">			 	<span class="keyword">elif</span> arr[mid] &gt; arr[mid<span class="number">-1</span>]:</span><br><span class="line">			 		R = mid - <span class="number">1</span></span><br><span class="line">			 	<span class="keyword">else</span>:</span><br><span class="line">			 		<span class="keyword">return</span> mid</span><br><span class="line">			 <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>将两个有序数组归并成一个更大的有序数组，【左边排好序、右边排好序，整体有序】，<font color="red">需要一个新的辅助空间和两个指针，用于比较</font>。时间复杂度 $O(N \log N)$，额外空间复杂度 $O(N)$。</p>
<img src="/2020/03/01/程序员代码面试指南/mergeSort.gif">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span> </span><br><span class="line">		self.mergeSortCore(arr, <span class="number">0</span>, len(arr)<span class="number">-1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">mergeSortCore</span><span class="params">(self, arr, l, r)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> l == r:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">		self.mergeSortCore(arr, l, mid)</span><br><span class="line">		self.mergeSortCore(arr, mid+<span class="number">1</span>, r)</span><br><span class="line">		self.merge(arr, l ,mid, r)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, arr, l, m, r)</span>:</span></span><br><span class="line">		help = []</span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line">		p1 = l</span><br><span class="line">		p2 = m + <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> p1 &lt;= m <span class="keyword">and</span> p2 &lt;= r:</span><br><span class="line">			<span class="keyword">if</span> arr[p1] &lt; arr[p2]:</span><br><span class="line">				help.append(arr[p1])</span><br><span class="line">				p1 += <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				help.append(arr[p2])</span><br><span class="line">				p2 += <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> p1 &lt;= m:</span><br><span class="line">			help.append(arr[p1])</span><br><span class="line">			p1 += <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> p2 &lt;= r:</span><br><span class="line">			help.append(arr[p2])</span><br><span class="line">			p2 += <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(help)):</span><br><span class="line">			arr[l+i] = help[i]</span><br><span class="line">		print(l, m, r, arr)</span><br></pre></td></tr></table></figure>
<p>归并排序的扩展：小和问题和逆序对问题。例题：LeetCode 第 88 题：<a href="https://leetcode-cn.com/problems/merge-sorted-array" target="_blank" rel="noopener">合并两个有序数组</a>，  <a href="https://www.acwing.com/problem/content/61/" target="_blank" rel="noopener">《剑指 Offer》（第 2 版）第 51 题：计算数组的逆序对</a>， LeetCode 第 315 题：<a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">计算右侧小于当前元素的个数</a>， LeetCode 第 53 题：<a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">最大子序和</a></p>
<p>小和问题：在一个数组中，每个数左边比当前数小的数累加起来，求一个数组的小和。换一个思路想：看每个数右边有多少个数比它大，可以将整体进行归并排序，左侧部分小则开始产生小和。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallSum</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">smallSum</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		<span class="keyword">return</span> self.mergeSort(arr, <span class="number">0</span>, len(arr)<span class="number">-1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(self, arr, l, r)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> l == r:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">		res = self.mergeSort(arr, l, mid) \</span><br><span class="line">			  + self.mergeSort(arr, mid + <span class="number">1</span>, r) \</span><br><span class="line">			  + self.merge(arr, l, mid, r)</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, arr, l, m, r)</span>:</span></span><br><span class="line">		help = []</span><br><span class="line">		p1 = l</span><br><span class="line">		p2 = m + <span class="number">1</span></span><br><span class="line">		res = <span class="number">0</span></span><br><span class="line">		<span class="keyword">while</span> p1 &lt;= m <span class="keyword">and</span> p2 &lt;= r:</span><br><span class="line">			<span class="keyword">if</span> arr[p1] &lt; arr[p2]:</span><br><span class="line">				help.append(arr[p1])</span><br><span class="line">				res += arr[p1] * (r - p2 + <span class="number">1</span>)</span><br><span class="line">				p1 += <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				help.append(arr[p2])</span><br><span class="line">				p2 += <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> p1 &lt;= m:</span><br><span class="line">			help.append(arr[p1])</span><br><span class="line">			p1 += <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> p2 &lt;= r:</span><br><span class="line">			help.append(arr[p2])</span><br><span class="line">			p2 += <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(help)):</span><br><span class="line">			arr[l+i] = help[i]</span><br><span class="line">		print(l, m, r, arr, res)</span><br><span class="line">		<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>逆序对问题，在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对。<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">面试题51. 数组中的逆序对</a>  <a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a>   <a href="https://leetcode-cn.com/problems/k-inverse-pairs-array/" target="_blank" rel="noopener">629. K个逆序对数组</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> nums == <span class="literal">None</span> <span class="keyword">or</span> len(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.mergeSort(nums, <span class="number">0</span>, len(nums)<span class="number">-1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(self, nums, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = l + ((r-l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        res = self.mergeSort(nums, l, mid) + self.mergeSort(nums, mid+<span class="number">1</span>, r) + self.merge(nums, l, mid, r)</span><br><span class="line">        <span class="keyword">return</span> res </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, arr, l, m, r)</span>:</span></span><br><span class="line">        help = []</span><br><span class="line">        p1 = l</span><br><span class="line">        p2 = m + <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt;= m <span class="keyword">and</span> p2 &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> arr[p1] &gt; arr[p2]:</span><br><span class="line">                res += (m - p1 + <span class="number">1</span>)</span><br><span class="line">                help.append(arr[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                help.append(arr[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt;= m:</span><br><span class="line">            help.append(arr[p1])</span><br><span class="line">            p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p2 &lt;= r:</span><br><span class="line">            help.append(arr[p2])</span><br><span class="line">            p2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(help)):</span><br><span class="line">            arr[l+i] = help[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><p>堆结构是用数组实现的完全二叉树结构(满二叉树，在从左往右依次变满，用连续数组实现，位置关系：节点 i 的左孩子是 $2<em>i+1$，节点 i 的右孩子$2</em>i+2$，节点 i 的父节点$(i-1)/2$ 向下取整），完全二叉树中如果每棵子数的最大值都在顶部就是大根堆 (例如：数组 [6, 3, 5, 1, 2, 4] 是大根堆)，完全二叉树中如果每棵子数的最小值都在顶部就是小根堆，优先级队列结构即堆结构。</p>
<p>堆排序过程：</p>
<ol>
<li><p>先让整个数组都变成大根堆结构，建堆过程：heapsize 纪录堆的大小</p>
<p>1）从上到下的方法：heapInsert 方法，时间复杂度为 $O(N \log N)$，用户一个数一个数的依次给你；若用户一次性将数据给你，通过从下往上每个数都 heapify，则建立大根堆的时间复杂度可以优化为 $O(N)$。</p>
<p>2）从下到上的方法：heapify 方法，时间复杂度为 $O(N \log N)$</p>
</li>
<li><p>把堆的最大值和堆末尾的值交换，然后减少堆到的大小后，再去调整为大根堆，周而复始，时间复杂度为 $O(N \log N)$</p>
</li>
<li><p>堆大小减小为 0 后，排序完成。</p>
</li>
</ol>
<img src="/2020/03/01/程序员代码面试指南/heapSort.gif">  <img src="/2020/03/01/程序员代码面试指南/2.jpg">  
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">heapsort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">			self.heapInsert(arr, i) <span class="comment"># arr数组上0~i是大根堆</span></span><br><span class="line">		heapsize = len(arr) - <span class="number">1</span></span><br><span class="line">		self.swap(arr, <span class="number">0</span>, heapsize)</span><br><span class="line">		<span class="keyword">while</span> heapsize &gt; <span class="number">0</span>:</span><br><span class="line">			self.heapify(arr, <span class="number">0</span>, heapsize)</span><br><span class="line">			heapsize -= <span class="number">1</span></span><br><span class="line">			self.swap(arr, <span class="number">0</span>, heapsize)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">heapInsert</span><span class="params">(self, arr, index)</span>:</span></span><br><span class="line">		print(<span class="string">'开始heapInsert'</span>, index, (index - <span class="number">1</span>)//<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">while</span> (index<span class="number">-1</span>)//<span class="number">2</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[index] &gt; arr[(index - <span class="number">1</span>)//<span class="number">2</span>]:</span><br><span class="line">			self.swap(arr, index, (index<span class="number">-1</span>)//<span class="number">2</span>)</span><br><span class="line">			index = (index<span class="number">-1</span>)//<span class="number">2</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(self, arr, index, heapsize)</span>:</span></span><br><span class="line">		print(<span class="string">'开始heapify'</span>, index, heapsize)</span><br><span class="line">		left = <span class="number">2</span> * index + <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> left &lt; heapsize:</span><br><span class="line">			<span class="keyword">if</span> left + <span class="number">1</span> &lt; heapsize <span class="keyword">and</span> arr[left+<span class="number">1</span>] &gt; arr[left]:</span><br><span class="line">				largest = left + <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				largest = left</span><br><span class="line">			<span class="keyword">if</span> arr[largest] &lt; arr[index]:</span><br><span class="line">				largest = index</span><br><span class="line">			<span class="keyword">if</span> largest == index:</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			self.swap(arr, largest, index)</span><br><span class="line">			index = largest</span><br><span class="line">			left = <span class="number">2</span> * index + <span class="number">1</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">		tmp = arr[i]</span><br><span class="line">		arr[i] = arr[j]</span><br><span class="line">		arr[j] = tmp</span><br><span class="line">		print(i, j, arr)</span><br><span class="line">HeapSort().heapsort([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>$Python$ 中 $heapq$ 模块基本实现最小堆：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">heap = [] <span class="comment">#创建了一个空堆</span></span><br><span class="line">heappush(heap,item) <span class="comment">#往堆中插入一条新的值</span></span><br><span class="line">item = heappop(heap) <span class="comment">#从堆中弹出最小值</span></span><br><span class="line">item = heap[<span class="number">0</span>] <span class="comment">#查看堆中最小值，不弹出</span></span><br><span class="line">heapify(x) <span class="comment">#以线性时间讲一个列表转化为堆</span></span><br><span class="line">item = heapreplace(heap,item) <span class="comment">#弹出并返回最小值，然后将heapqreplace方法中item的值插入到堆中</span></span><br><span class="line">heappushpop() <span class="comment">#顾名思义，将值插入到堆中同时弹出堆中的最小值。</span></span><br><span class="line">merge(*iterables) <span class="comment">#合并多个堆然后输出</span></span><br><span class="line">nlargest(n , iterbale, key=<span class="literal">None</span>) <span class="comment">#从堆中找出做大的N个数，key的作用和sorted( )方法里面的key类似，用列表元素的某个属性和函数作为关键字。</span></span><br><span class="line">nsmallest(n, iterable, key=<span class="literal">None</span>) <span class="comment">#找到堆中最小的N个数用法同上。</span></span><br></pre></td></tr></table></figure>
<p>修改为最大堆：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.val &gt; other.val</span><br><span class="line">q = []</span><br><span class="line">heapq.heappush(q, MyObject(<span class="number">50</span>))</span><br><span class="line">heapq.heappush(q, MyObject(<span class="number">40</span>))</span><br><span class="line">heapq.heappush(q, MyObject(<span class="number">30</span>))</span><br><span class="line">heapq.heappush(q, MyObject(<span class="number">20</span>))</span><br><span class="line">heapq.heappush(q, MyObject(<span class="number">200</span>))</span><br><span class="line">obj = heapq.heappop(q)</span><br><span class="line">print(obj.val)  <span class="comment"># 200</span></span><br><span class="line">heapq.heapreplace(q, MyObject(<span class="number">47</span>))  <span class="comment"># 将最大值替换为47</span></span><br><span class="line">print(heapq.heappop(q).val)  <span class="comment"># 47</span></span><br><span class="line">print(q[<span class="number">0</span>].val) <span class="comment"># 40</span></span><br></pre></td></tr></table></figure>
<p>堆排序扩展题目：已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过 k，并且 k 相对于数组来说比较小。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>不改进的快速排序：</p>
<ol>
<li><p>把数组范围中的最后一个数作为划分值，然后把数组通过荷兰国旗问题分成三个部分：左侧 &lt; 划分值、中间 == 划分值、右侧 &gt; 划分值。</p>
<ol>
<li><p><font color="red">Partition​ 问题</font>：给定一个数组 $arr$ 和一个数 $num$，请把小于等于 $num$ 的数放在数组的左边，大于 $num$ 的数放在数组的右边，要求额外空间复杂度 $O(1)$， 时间复杂度 $O(N)$</p>
<p>用一个变量表示 $\le$ 区域，$i$ ：表示从左往右遍历的变量 （当前数）</p>
<p>①  $arr[i] \le num$：当前数和 $\le 区域$ 下一个数交换， $\le 区域$ 扩一个位置，当前数跳下一个</p>
<p>②  $arr[i] \gt num$：当前数直接跳下一个</p>
<p>剑指offer：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">面试题39. 数组中出现次数超过一半的数字</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
<li><p><font color="red">荷兰国旗问题</font>：给定一个数组 $arr$ 和一个数 $num$，请把小于 $num$ 的数放在数组的左边，等于 $num$ 的数放在数组的中间，大于 $num$ 的数放在数组的右边，要求额外空间复杂度 $O(1)$， 时间复杂度 $O(N)$。</p>
<p>用一个变量表示左边界 $\lt 区域$， 一个变量表示右边界 $\gt 区域$，$i$ ：表示从左往右遍历的变量 （当前数）</p>
<p>①  $arr[i] \lt num$：当前数和 $\lt 区域$ 下一个数交换， $\lt 区域$ 扩一个位置，当前数跳下一个</p>
<p>②  $arr[i] = num$：当前数直接跳下一个</p>
<p>③  $arr[i] \gt num$：当前数和 $\gt 区域$ 前一个数交换， $\gt 区域$ 左扩一个位置，当前数定在原地</p>
<p>④  当前数 == $\gt 区域$左边界时停止</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetherlandsFlag</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, arr, l, r, p)</span>:</span></span><br><span class="line">		less = l - <span class="number">1</span></span><br><span class="line">		more = r + <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> l &lt; more:</span><br><span class="line">			<span class="keyword">if</span> arr[l] &lt; p:</span><br><span class="line">				self.swap(arr, l, less+<span class="number">1</span>)</span><br><span class="line">				less += <span class="number">1</span></span><br><span class="line">				l += <span class="number">1</span></span><br><span class="line">			<span class="keyword">elif</span> arr[l] &gt; p:</span><br><span class="line">				self.swap(arr, more<span class="number">-1</span>, l)</span><br><span class="line">				more -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				l += <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> [less, more]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">		tmp = arr[i]</span><br><span class="line">		arr[i] = arr[j]</span><br><span class="line">		arr[j] = tmp</span><br><span class="line">		print(arr, i, j)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>对左侧范围和右侧范围，递归执行</p>
</li>
</ol>
<p>不改进的快速排序：划分值越靠近两侧，复杂度越高；划分值越靠近中间，复杂度越低。数据越有序，不改进的快速排序复杂度越高，最差情况：当数据有序时，时间复杂度为 $O(N^{2})$；好情况：每次划分值处于相当中间的位置，时间复杂度 $O(N \log N)$</p>
<p>改进的快速排序（随机快速排序）：</p>
<ol>
<li>在数组范围中，等概率随机选一个数作为划分值，然后把数组通过荷兰国旗问题分成三个部分：左侧 &lt; 划分值、中间 == 划分值、右侧 &gt; 划分值。</li>
<li>对左侧范围和右侧范围，递归执行</li>
<li>时间复杂度为 $O(N \log N)$【所有情况下期望】，额外空间复杂度 $O(\log N)$【期望上的长期收敛】（好情况：每次以几乎二分递归的方式，中间数是树的高度 $\log N$，坏情况：中点特别偏，树多大，栈压多少层 $N$）</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> arr == <span class="literal">None</span> <span class="keyword">or</span> len(arr) &lt; <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		self.quickSortCore(arr, <span class="number">0</span>, len(arr)<span class="number">-1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">quickSortCore</span><span class="params">(self, arr, l, r)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> l &lt; r:</span><br><span class="line">			p = self.partition(arr, l, r)</span><br><span class="line">			print(l, r, p)</span><br><span class="line">			self.quickSortCore(arr, l, p[<span class="number">0</span>])</span><br><span class="line">			self.quickSortCore(arr, p[<span class="number">1</span>]+<span class="number">1</span>, r)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, arr, l, r)</span>:</span></span><br><span class="line">		print(l, r)</span><br><span class="line">		less = l - <span class="number">1</span></span><br><span class="line">		more = r</span><br><span class="line">		<span class="keyword">while</span> l &lt; more:</span><br><span class="line">			<span class="keyword">if</span> arr[l] &lt; arr[r]:</span><br><span class="line">				self.swap(arr, less+<span class="number">1</span>, l)</span><br><span class="line">				l += <span class="number">1</span></span><br><span class="line">				less += <span class="number">1</span></span><br><span class="line">			<span class="keyword">elif</span> arr[l] &gt; arr[r]:</span><br><span class="line">				self.swap(arr, more<span class="number">-1</span>, l)</span><br><span class="line">				more -= <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				l += <span class="number">1</span></span><br><span class="line">		self.swap(arr, more, r)</span><br><span class="line">		<span class="keyword">return</span> [less, more]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, arr, i, j)</span>:</span></span><br><span class="line">		temp = arr[i]</span><br><span class="line">		arr[i] = arr[j]</span><br><span class="line">		arr[j] = temp</span><br><span class="line">		print(arr)</span><br></pre></td></tr></table></figure>
<h5 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h5><p>桶排序思想下的排序都是不基于比较的排序，时间复杂度 $O(N)$，额外空间复杂度 $O(M)$</p>
<ol>
<li>计数排序</li>
<li>基数排序</li>
</ol>
<h4 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h4><h5 id="面试题1：设计一个有-getMin-功能的栈"><a href="#面试题1：设计一个有-getMin-功能的栈" class="headerlink" title="面试题1：设计一个有 getMin 功能的栈"></a>面试题1：设计一个有 getMin 功能的栈</h5><h5 id="面试题2：由两个栈组成的队列"><a href="#面试题2：由两个栈组成的队列" class="headerlink" title="面试题2：由两个栈组成的队列"></a>面试题2：由两个栈组成的队列</h5><h5 id="面试题3：如何仅用递归函数和栈操作逆序一个栈"><a href="#面试题3：如何仅用递归函数和栈操作逆序一个栈" class="headerlink" title="面试题3：如何仅用递归函数和栈操作逆序一个栈"></a>面试题3：如何仅用递归函数和栈操作逆序一个栈</h5><h5 id="面试题4：猫狗队列"><a href="#面试题4：猫狗队列" class="headerlink" title="面试题4：猫狗队列"></a>面试题4：猫狗队列</h5><h5 id="面试题5：用一个栈实现另一个栈的排序"><a href="#面试题5：用一个栈实现另一个栈的排序" class="headerlink" title="面试题5：用一个栈实现另一个栈的排序"></a>面试题5：用一个栈实现另一个栈的排序</h5><h5 id="面试题6：用栈来解决汉诺塔问题"><a href="#面试题6：用栈来解决汉诺塔问题" class="headerlink" title="面试题6：用栈来解决汉诺塔问题"></a>面试题6：用栈来解决汉诺塔问题</h5><h5 id="面试题7：生成窗口最大值数组"><a href="#面试题7：生成窗口最大值数组" class="headerlink" title="面试题7：生成窗口最大值数组"></a>面试题7：生成窗口最大值数组</h5><h5 id="面试题8：单调栈结构"><a href="#面试题8：单调栈结构" class="headerlink" title="面试题8：单调栈结构"></a>面试题8：单调栈结构</h5><h5 id="面试题9：求最大子矩阵的大小"><a href="#面试题9：求最大子矩阵的大小" class="headerlink" title="面试题9：求最大子矩阵的大小"></a>面试题9：求最大子矩阵的大小</h5><h5 id="面试题10：最大值减去最小值小于或等于-num-的子数组数量"><a href="#面试题10：最大值减去最小值小于或等于-num-的子数组数量" class="headerlink" title="面试题10：最大值减去最小值小于或等于 num 的子数组数量"></a>面试题10：最大值减去最小值小于或等于 num 的子数组数量</h5><h5 id="面试题11：可见的山峰对数量"><a href="#面试题11：可见的山峰对数量" class="headerlink" title="面试题11：可见的山峰对数量"></a>面试题11：可见的山峰对数量</h5><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h5 id="面试题1：打印两个有序链表的公共部分"><a href="#面试题1：打印两个有序链表的公共部分" class="headerlink" title="面试题1：打印两个有序链表的公共部分"></a>面试题1：打印两个有序链表的公共部分</h5><h5 id="面试题2：在单链表和双链表中删除倒数第-k-个节点"><a href="#面试题2：在单链表和双链表中删除倒数第-k-个节点" class="headerlink" title="面试题2：在单链表和双链表中删除倒数第 k 个节点"></a>面试题2：在单链表和双链表中删除倒数第 k 个节点</h5><h5 id="面试题3：删除链表的中间节点和-a-b-处的节点"><a href="#面试题3：删除链表的中间节点和-a-b-处的节点" class="headerlink" title="面试题3：删除链表的中间节点和 a/b 处的节点"></a>面试题3：删除链表的中间节点和 a/b 处的节点</h5><h5 id="面试题4：反转单向和双向链表"><a href="#面试题4：反转单向和双向链表" class="headerlink" title="面试题4：反转单向和双向链表"></a>面试题4：反转单向和双向链表</h5><h5 id="面试题5：反转部分单向链表"><a href="#面试题5：反转部分单向链表" class="headerlink" title="面试题5：反转部分单向链表"></a>面试题5：反转部分单向链表</h5><h5 id="面试题6：环形单链表的约瑟夫问题"><a href="#面试题6：环形单链表的约瑟夫问题" class="headerlink" title="面试题6：环形单链表的约瑟夫问题"></a>面试题6：环形单链表的约瑟夫问题</h5><h5 id="面试题7：判断一个链表是否为回文结构"><a href="#面试题7：判断一个链表是否为回文结构" class="headerlink" title="面试题7：判断一个链表是否为回文结构"></a>面试题7：判断一个链表是否为回文结构</h5><h5 id="面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式"><a href="#面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式" class="headerlink" title="面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式"></a>面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式</h5><h5 id="面试题9：复制含有随机指针节点的链表"><a href="#面试题9：复制含有随机指针节点的链表" class="headerlink" title="面试题9：复制含有随机指针节点的链表"></a>面试题9：复制含有随机指针节点的链表</h5><h5 id="面试题10：两个单链表生成相加链表"><a href="#面试题10：两个单链表生成相加链表" class="headerlink" title="面试题10：两个单链表生成相加链表"></a>面试题10：两个单链表生成相加链表</h5><h5 id="面试题11：两个单链表相交的一系列问题"><a href="#面试题11：两个单链表相交的一系列问题" class="headerlink" title="面试题11：两个单链表相交的一系列问题"></a>面试题11：两个单链表相交的一系列问题</h5><h5 id="面试题12：将单链表的每-K-个节点之间逆序"><a href="#面试题12：将单链表的每-K-个节点之间逆序" class="headerlink" title="面试题12：将单链表的每 K 个节点之间逆序"></a>面试题12：将单链表的每 K 个节点之间逆序</h5><h5 id="面试题13：删除无序单链表中值重复出现的节点"><a href="#面试题13：删除无序单链表中值重复出现的节点" class="headerlink" title="面试题13：删除无序单链表中值重复出现的节点"></a>面试题13：删除无序单链表中值重复出现的节点</h5><h5 id="面试题14：在单链表中删除指定值的节点"><a href="#面试题14：在单链表中删除指定值的节点" class="headerlink" title="面试题14：在单链表中删除指定值的节点"></a>面试题14：在单链表中删除指定值的节点</h5><h5 id="面试题15：将搜索二叉树转换成双向链表"><a href="#面试题15：将搜索二叉树转换成双向链表" class="headerlink" title="面试题15：将搜索二叉树转换成双向链表"></a>面试题15：将搜索二叉树转换成双向链表</h5><h5 id="面试题16：单链表的选择排序"><a href="#面试题16：单链表的选择排序" class="headerlink" title="面试题16：单链表的选择排序"></a>面试题16：单链表的选择排序</h5><h5 id="面试题17：一种怪异的节点删除方式"><a href="#面试题17：一种怪异的节点删除方式" class="headerlink" title="面试题17：一种怪异的节点删除方式"></a>面试题17：一种怪异的节点删除方式</h5><h5 id="面试题18：向有序的环形单链表中插入新节点"><a href="#面试题18：向有序的环形单链表中插入新节点" class="headerlink" title="面试题18：向有序的环形单链表中插入新节点"></a>面试题18：向有序的环形单链表中插入新节点</h5><h5 id="面试题19：合并两个有序的单链表"><a href="#面试题19：合并两个有序的单链表" class="headerlink" title="面试题19：合并两个有序的单链表"></a>面试题19：合并两个有序的单链表</h5><h5 id="面试题20：按照左右半区的方式重新组合单链表"><a href="#面试题20：按照左右半区的方式重新组合单链表" class="headerlink" title="面试题20：按照左右半区的方式重新组合单链表"></a>面试题20：按照左右半区的方式重新组合单链表</h5><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历"><a href="#面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历" class="headerlink" title="面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历"></a>面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历</h5><h5 id="面试题2：打印二叉树的边界节点"><a href="#面试题2：打印二叉树的边界节点" class="headerlink" title="面试题2：打印二叉树的边界节点"></a>面试题2：打印二叉树的边界节点</h5><h5 id="面试题3：如何较为直观地打印二叉树"><a href="#面试题3：如何较为直观地打印二叉树" class="headerlink" title="面试题3：如何较为直观地打印二叉树"></a>面试题3：如何较为直观地打印二叉树</h5><h5 id="面试题4：二叉树地序列化和反序列化"><a href="#面试题4：二叉树地序列化和反序列化" class="headerlink" title="面试题4：二叉树地序列化和反序列化"></a>面试题4：二叉树地序列化和反序列化</h5><h5 id="面试题5：遍历二叉树地神级方法"><a href="#面试题5：遍历二叉树地神级方法" class="headerlink" title="面试题5：遍历二叉树地神级方法"></a>面试题5：遍历二叉树地神级方法</h5><h5 id="面试题6：在二叉树中找到累加和为指定值地最长路径长度"><a href="#面试题6：在二叉树中找到累加和为指定值地最长路径长度" class="headerlink" title="面试题6：在二叉树中找到累加和为指定值地最长路径长度"></a>面试题6：在二叉树中找到累加和为指定值地最长路径长度</h5><h5 id="面试题7：找到二叉树中最大搜索二叉子数"><a href="#面试题7：找到二叉树中最大搜索二叉子数" class="headerlink" title="面试题7：找到二叉树中最大搜索二叉子数"></a>面试题7：找到二叉树中最大搜索二叉子数</h5><h5 id="面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构"><a href="#面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构" class="headerlink" title="面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构"></a>面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构</h5><h5 id="面试题9：二叉树的按层打印预-ZigZag-打印"><a href="#面试题9：二叉树的按层打印预-ZigZag-打印" class="headerlink" title="面试题9：二叉树的按层打印预 ZigZag 打印"></a>面试题9：二叉树的按层打印预 ZigZag 打印</h5><h5 id="面试题10：调整搜索二叉树中两个错误的节点"><a href="#面试题10：调整搜索二叉树中两个错误的节点" class="headerlink" title="面试题10：调整搜索二叉树中两个错误的节点"></a>面试题10：调整搜索二叉树中两个错误的节点</h5><h5 id="面试题11：判断-t1-树是否包含-t2-树全部的拓扑结构"><a href="#面试题11：判断-t1-树是否包含-t2-树全部的拓扑结构" class="headerlink" title="面试题11：判断 t1 树是否包含 t2 树全部的拓扑结构"></a>面试题11：判断 t1 树是否包含 t2 树全部的拓扑结构</h5><h5 id="面试题12：判断-t1-树中是否有与-t2-树拓扑结构完全相同的子数"><a href="#面试题12：判断-t1-树中是否有与-t2-树拓扑结构完全相同的子数" class="headerlink" title="面试题12：判断 t1 树中是否有与 t2 树拓扑结构完全相同的子数"></a>面试题12：判断 t1 树中是否有与 t2 树拓扑结构完全相同的子数</h5><h5 id="面试题13：判断二叉树是否为平衡二叉树"><a href="#面试题13：判断二叉树是否为平衡二叉树" class="headerlink" title="面试题13：判断二叉树是否为平衡二叉树"></a>面试题13：判断二叉树是否为平衡二叉树</h5><h5 id="面试题14：根据后序数组重建搜索二叉树"><a href="#面试题14：根据后序数组重建搜索二叉树" class="headerlink" title="面试题14：根据后序数组重建搜索二叉树"></a>面试题14：根据后序数组重建搜索二叉树</h5><h5 id="面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树"><a href="#面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树" class="headerlink" title="面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树"></a>面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树</h5><h5 id="面试题16：通过有序数组生成平衡搜索二叉树"><a href="#面试题16：通过有序数组生成平衡搜索二叉树" class="headerlink" title="面试题16：通过有序数组生成平衡搜索二叉树"></a>面试题16：通过有序数组生成平衡搜索二叉树</h5><h5 id="面试题17：在二叉树中找到一个节点的后继节点"><a href="#面试题17：在二叉树中找到一个节点的后继节点" class="headerlink" title="面试题17：在二叉树中找到一个节点的后继节点"></a>面试题17：在二叉树中找到一个节点的后继节点</h5><h5 id="面试题18：在二叉树中找到两个节点的最低公共祖先"><a href="#面试题18：在二叉树中找到两个节点的最低公共祖先" class="headerlink" title="面试题18：在二叉树中找到两个节点的最低公共祖先"></a>面试题18：在二叉树中找到两个节点的最低公共祖先</h5><h5 id="面试题19：Tarjan-算法与并查集解决二叉树节点间最低公共祖先的批量查询问题"><a href="#面试题19：Tarjan-算法与并查集解决二叉树节点间最低公共祖先的批量查询问题" class="headerlink" title="面试题19：Tarjan 算法与并查集解决二叉树节点间最低公共祖先的批量查询问题"></a>面试题19：Tarjan 算法与并查集解决二叉树节点间最低公共祖先的批量查询问题</h5><h5 id="面试题20：二叉树节点间的最大距离问题"><a href="#面试题20：二叉树节点间的最大距离问题" class="headerlink" title="面试题20：二叉树节点间的最大距离问题"></a>面试题20：二叉树节点间的最大距离问题</h5><h5 id="面试题21：派对的最大快乐值"><a href="#面试题21：派对的最大快乐值" class="headerlink" title="面试题21：派对的最大快乐值"></a>面试题21：派对的最大快乐值</h5><h5 id="面试题22：通过先序和中序数组生成后序数组"><a href="#面试题22：通过先序和中序数组生成后序数组" class="headerlink" title="面试题22：通过先序和中序数组生成后序数组"></a>面试题22：通过先序和中序数组生成后序数组</h5><h5 id="面试题23：统计和生成所有不同的二叉树"><a href="#面试题23：统计和生成所有不同的二叉树" class="headerlink" title="面试题23：统计和生成所有不同的二叉树"></a>面试题23：统计和生成所有不同的二叉树</h5><h5 id="面试题24：统计完全二叉树的节点树"><a href="#面试题24：统计完全二叉树的节点树" class="headerlink" title="面试题24：统计完全二叉树的节点树"></a>面试题24：统计完全二叉树的节点树</h5><h4 id="递归和动态规划"><a href="#递归和动态规划" class="headerlink" title="递归和动态规划"></a>递归和动态规划</h4><h5 id="面试题1：斐波那契数列问题的递归和动态规划"><a href="#面试题1：斐波那契数列问题的递归和动态规划" class="headerlink" title="面试题1：斐波那契数列问题的递归和动态规划"></a>面试题1：斐波那契数列问题的递归和动态规划</h5><h5 id="面试题2：矩阵的最小路径和"><a href="#面试题2：矩阵的最小路径和" class="headerlink" title="面试题2：矩阵的最小路径和"></a>面试题2：矩阵的最小路径和</h5><h5 id="面试题3：换钱的最少货币数"><a href="#面试题3：换钱的最少货币数" class="headerlink" title="面试题3：换钱的最少货币数"></a>面试题3：换钱的最少货币数</h5><h5 id="面试题4：机器人达到指定位置方法数"><a href="#面试题4：机器人达到指定位置方法数" class="headerlink" title="面试题4：机器人达到指定位置方法数"></a>面试题4：机器人达到指定位置方法数</h5><h5 id="面试题5：换钱的方法数"><a href="#面试题5：换钱的方法数" class="headerlink" title="面试题5：换钱的方法数"></a>面试题5：换钱的方法数</h5><h5 id="面试题6：打气球的最大分数"><a href="#面试题6：打气球的最大分数" class="headerlink" title="面试题6：打气球的最大分数"></a>面试题6：打气球的最大分数</h5><h5 id="面试题7：最长递增子序列"><a href="#面试题7：最长递增子序列" class="headerlink" title="面试题7：最长递增子序列"></a>面试题7：最长递增子序列</h5><h5 id="面试题8：信封嵌套问题"><a href="#面试题8：信封嵌套问题" class="headerlink" title="面试题8：信封嵌套问题"></a>面试题8：信封嵌套问题</h5><h5 id="面试题9：汉诺塔问题"><a href="#面试题9：汉诺塔问题" class="headerlink" title="面试题9：汉诺塔问题"></a>面试题9：汉诺塔问题</h5><h5 id="面试题10：最长公共子序列问题"><a href="#面试题10：最长公共子序列问题" class="headerlink" title="面试题10：最长公共子序列问题"></a>面试题10：最长公共子序列问题</h5><h5 id="面试题11：最长公共子串问题"><a href="#面试题11：最长公共子串问题" class="headerlink" title="面试题11：最长公共子串问题"></a>面试题11：最长公共子串问题</h5><h5 id="面试题12：子数组异或和为0的最多划分"><a href="#面试题12：子数组异或和为0的最多划分" class="headerlink" title="面试题12：子数组异或和为0的最多划分"></a>面试题12：子数组异或和为0的最多划分</h5><h5 id="面试题13：最小编辑代价"><a href="#面试题13：最小编辑代价" class="headerlink" title="面试题13：最小编辑代价"></a>面试题13：最小编辑代价</h5><h5 id="面试题14：字符串的交错组成"><a href="#面试题14：字符串的交错组成" class="headerlink" title="面试题14：字符串的交错组成"></a>面试题14：字符串的交错组成</h5><h5 id="面试题15：龙与地下城游戏问题"><a href="#面试题15：龙与地下城游戏问题" class="headerlink" title="面试题15：龙与地下城游戏问题"></a>面试题15：龙与地下城游戏问题</h5><h5 id="面试题16：数字字符串转换为字符组合的种数"><a href="#面试题16：数字字符串转换为字符组合的种数" class="headerlink" title="面试题16：数字字符串转换为字符组合的种数"></a>面试题16：数字字符串转换为字符组合的种数</h5><h5 id="面试题17：表达式得到期望结果的组成种树"><a href="#面试题17：表达式得到期望结果的组成种树" class="headerlink" title="面试题17：表达式得到期望结果的组成种树"></a>面试题17：表达式得到期望结果的组成种树</h5><h5 id="面试题18：排成一条线的纸牌博弈问题"><a href="#面试题18：排成一条线的纸牌博弈问题" class="headerlink" title="面试题18：排成一条线的纸牌博弈问题"></a>面试题18：排成一条线的纸牌博弈问题</h5><h5 id="面试题19：跳跃游戏"><a href="#面试题19：跳跃游戏" class="headerlink" title="面试题19：跳跃游戏"></a>面试题19：跳跃游戏</h5><h5 id="面试题20：数组中的最长连续序列"><a href="#面试题20：数组中的最长连续序列" class="headerlink" title="面试题20：数组中的最长连续序列"></a>面试题20：数组中的最长连续序列</h5><h5 id="面试题21：N-皇后问题"><a href="#面试题21：N-皇后问题" class="headerlink" title="面试题21：N 皇后问题"></a>面试题21：N 皇后问题</h5><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="面试题1：判断两个字符串是否互为变形词"><a href="#面试题1：判断两个字符串是否互为变形词" class="headerlink" title="面试题1：判断两个字符串是否互为变形词"></a>面试题1：判断两个字符串是否互为变形词</h5><h5 id="面试题2：判断两个字符串是否互为旋转词"><a href="#面试题2：判断两个字符串是否互为旋转词" class="headerlink" title="面试题2：判断两个字符串是否互为旋转词"></a>面试题2：判断两个字符串是否互为旋转词</h5><h5 id="面试题3：字符串中统计字符串"><a href="#面试题3：字符串中统计字符串" class="headerlink" title="面试题3：字符串中统计字符串"></a>面试题3：字符串中统计字符串</h5><h5 id="面试题4：判断字符数组中是否所有的字符都只出现过一次"><a href="#面试题4：判断字符数组中是否所有的字符都只出现过一次" class="headerlink" title="面试题4：判断字符数组中是否所有的字符都只出现过一次"></a>面试题4：判断字符数组中是否所有的字符都只出现过一次</h5><h5 id="面试题5：在有序但包含空数组中查找字符串"><a href="#面试题5：在有序但包含空数组中查找字符串" class="headerlink" title="面试题5：在有序但包含空数组中查找字符串"></a>面试题5：在有序但包含空数组中查找字符串</h5><h5 id="面试题6：字符串的调整与替换"><a href="#面试题6：字符串的调整与替换" class="headerlink" title="面试题6：字符串的调整与替换"></a>面试题6：字符串的调整与替换</h5><h5 id="面试题7：翻转字符串"><a href="#面试题7：翻转字符串" class="headerlink" title="面试题7：翻转字符串"></a>面试题7：翻转字符串</h5><h5 id="面试题8：完美洗牌问题"><a href="#面试题8：完美洗牌问题" class="headerlink" title="面试题8：完美洗牌问题"></a>面试题8：完美洗牌问题</h5><h5 id="面试题9：删除多余字符得到字典序最小的字符串"><a href="#面试题9：删除多余字符得到字典序最小的字符串" class="headerlink" title="面试题9：删除多余字符得到字典序最小的字符串"></a>面试题9：删除多余字符得到字典序最小的字符串</h5><h5 id="面试题10：数组中两个字符串的最小距离"><a href="#面试题10：数组中两个字符串的最小距离" class="headerlink" title="面试题10：数组中两个字符串的最小距离"></a>面试题10：数组中两个字符串的最小距离</h5><h5 id="面试题11：字符串的转换路径问题"><a href="#面试题11：字符串的转换路径问题" class="headerlink" title="面试题11：字符串的转换路径问题"></a>面试题11：字符串的转换路径问题</h5><h5 id="面试题12：添加最少字符使字符串整体都是回文字符串"><a href="#面试题12：添加最少字符使字符串整体都是回文字符串" class="headerlink" title="面试题12：添加最少字符使字符串整体都是回文字符串"></a>面试题12：添加最少字符使字符串整体都是回文字符串</h5><h5 id="面试题13：括号字符串的有效性和最长有效长度"><a href="#面试题13：括号字符串的有效性和最长有效长度" class="headerlink" title="面试题13：括号字符串的有效性和最长有效长度"></a>面试题13：括号字符串的有效性和最长有效长度</h5><h5 id="面试题14：公司字符串求值"><a href="#面试题14：公司字符串求值" class="headerlink" title="面试题14：公司字符串求值"></a>面试题14：公司字符串求值</h5><h5 id="面试题15：0-左边必有-1-的二进制字符串数量"><a href="#面试题15：0-左边必有-1-的二进制字符串数量" class="headerlink" title="面试题15：0 左边必有 1 的二进制字符串数量"></a>面试题15：0 左边必有 1 的二进制字符串数量</h5><h5 id="面试题16：拼接所有字符串产生字典顺序最小的大写字符串"><a href="#面试题16：拼接所有字符串产生字典顺序最小的大写字符串" class="headerlink" title="面试题16：拼接所有字符串产生字典顺序最小的大写字符串"></a>面试题16：拼接所有字符串产生字典顺序最小的大写字符串</h5><h5 id="面试题17：找到字符串的最长无重复字符子串"><a href="#面试题17：找到字符串的最长无重复字符子串" class="headerlink" title="面试题17：找到字符串的最长无重复字符子串"></a>面试题17：找到字符串的最长无重复字符子串</h5><h5 id="面试题18：找到指定的新类型字符"><a href="#面试题18：找到指定的新类型字符" class="headerlink" title="面试题18：找到指定的新类型字符"></a>面试题18：找到指定的新类型字符</h5><h5 id="面试题19：旋变字符串问题"><a href="#面试题19：旋变字符串问题" class="headerlink" title="面试题19：旋变字符串问题"></a>面试题19：旋变字符串问题</h5><h5 id="面试题20：最小包含子串的长度"><a href="#面试题20：最小包含子串的长度" class="headerlink" title="面试题20：最小包含子串的长度"></a>面试题20：最小包含子串的长度</h5><h5 id="面试题21：回文最少分割数"><a href="#面试题21：回文最少分割数" class="headerlink" title="面试题21：回文最少分割数"></a>面试题21：回文最少分割数</h5><h5 id="面试题22：字符串匹配问题"><a href="#面试题22：字符串匹配问题" class="headerlink" title="面试题22：字符串匹配问题"></a>面试题22：字符串匹配问题</h5><h5 id="面试题23：字典树（前缀树）的实现"><a href="#面试题23：字典树（前缀树）的实现" class="headerlink" title="面试题23：字典树（前缀树）的实现"></a>面试题23：字典树（前缀树）的实现</h5><h5 id="面试题24：子数组的最大异或和"><a href="#面试题24：子数组的最大异或和" class="headerlink" title="面试题24：子数组的最大异或和"></a>面试题24：子数组的最大异或和</h5><h4 id="大数据和空间限制"><a href="#大数据和空间限制" class="headerlink" title="大数据和空间限制"></a>大数据和空间限制</h4><h5 id="面试题1-认识布隆过滤器"><a href="#面试题1-认识布隆过滤器" class="headerlink" title="面试题1.  认识布隆过滤器"></a>面试题1.  认识布隆过滤器</h5><h5 id="面试题2-只用2GB内存在20亿个整数中找到出现次数最多的数"><a href="#面试题2-只用2GB内存在20亿个整数中找到出现次数最多的数" class="headerlink" title="面试题2.  只用2GB内存在20亿个整数中找到出现次数最多的数"></a>面试题2.  只用2GB内存在20亿个整数中找到出现次数最多的数</h5><h5 id="面试题3-40亿个非负整数中找到未出现的数"><a href="#面试题3-40亿个非负整数中找到未出现的数" class="headerlink" title="面试题3.  40亿个非负整数中找到未出现的数"></a>面试题3.  40亿个非负整数中找到未出现的数</h5><h5 id="面试题4-找到100亿个URL中重复的URL及搜索词汇的Top-K问题"><a href="#面试题4-找到100亿个URL中重复的URL及搜索词汇的Top-K问题" class="headerlink" title="面试题4.  找到100亿个URL中重复的URL及搜索词汇的Top  K问题"></a>面试题4.  找到100亿个URL中重复的URL及搜索词汇的Top  K问题</h5><h5 id="面试题5-40亿个非负整数中找到出现两次的数和所有数的中位数（"><a href="#面试题5-40亿个非负整数中找到出现两次的数和所有数的中位数（" class="headerlink" title="面试题5.  40亿个非负整数中找到出现两次的数和所有数的中位数（"></a>面试题5.  40亿个非负整数中找到出现两次的数和所有数的中位数（</h5><h5 id="面试题6-一致性哈希算法的基本原理"><a href="#面试题6-一致性哈希算法的基本原理" class="headerlink" title="面试题6.  一致性哈希算法的基本原理"></a>面试题6.  一致性哈希算法的基本原理</h5><h5 id="面试题7-岛问题"><a href="#面试题7-岛问题" class="headerlink" title="面试题7.  岛问题"></a>面试题7.  岛问题</h5><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><h5 id="面试题1-不用额外变量交换两个整数的值"><a href="#面试题1-不用额外变量交换两个整数的值" class="headerlink" title="面试题1.  不用额外变量交换两个整数的值"></a>面试题1.  不用额外变量交换两个整数的值</h5><h5 id="面试题2-不用做任何比较判断找出两个数中较大的数"><a href="#面试题2-不用做任何比较判断找出两个数中较大的数" class="headerlink" title="面试题2.  不用做任何比较判断找出两个数中较大的数"></a>面试题2.  不用做任何比较判断找出两个数中较大的数</h5><h5 id="面试题3-只用位运算不用算术运算实现整数的加减乘除运算（"><a href="#面试题3-只用位运算不用算术运算实现整数的加减乘除运算（" class="headerlink" title="面试题3.  只用位运算不用算术运算实现整数的加减乘除运算（"></a>面试题3.  只用位运算不用算术运算实现整数的加减乘除运算（</h5><h5 id="面试题4-整数的二进制数表达中有多少个1"><a href="#面试题4-整数的二进制数表达中有多少个1" class="headerlink" title="面试题4. 整数的二进制数表达中有多少个1"></a>面试题4. 整数的二进制数表达中有多少个1</h5><h5 id="面试题5-在其他数都出现偶数次的数组中找到出现奇数次的数（"><a href="#面试题5-在其他数都出现偶数次的数组中找到出现奇数次的数（" class="headerlink" title="面试题5.  在其他数都出现偶数次的数组中找到出现奇数次的数（"></a>面试题5.  在其他数都出现偶数次的数组中找到出现奇数次的数（</h5><h5 id="面试题6-在其他数都出现k次的数组中找到只出现一次的数"><a href="#面试题6-在其他数都出现k次的数组中找到只出现一次的数" class="headerlink" title="面试题6.  在其他数都出现k次的数组中找到只出现一次的数"></a>面试题6.  在其他数都出现k次的数组中找到只出现一次的数</h5><h4 id="数组和矩阵"><a href="#数组和矩阵" class="headerlink" title="数组和矩阵"></a>数组和矩阵</h4><h5 id="面试题1-转圈打印矩阵"><a href="#面试题1-转圈打印矩阵" class="headerlink" title="面试题1.  转圈打印矩阵"></a>面试题1.  转圈打印矩阵</h5><h5 id="面试题2-将正方形矩阵顺时针转动90°"><a href="#面试题2-将正方形矩阵顺时针转动90°" class="headerlink" title="面试题2.  将正方形矩阵顺时针转动90°"></a>面试题2.  将正方形矩阵顺时针转动90°</h5><h5 id="面试题3-“之”字形打印矩阵"><a href="#面试题3-“之”字形打印矩阵" class="headerlink" title="面试题3.  “之”字形打印矩阵"></a>面试题3.  “之”字形打印矩阵</h5><h5 id="面试题4-找到无序数组中最小的k个数（O-Nlogk-的方法"><a href="#面试题4-找到无序数组中最小的k个数（O-Nlogk-的方法" class="headerlink" title="面试题4.   找到无序数组中最小的k个数（O(Nlogk)的方法"></a>面试题4.   找到无序数组中最小的k个数（O(Nlogk)的方法</h5><h5 id="面试题5-需要排序的最短子数组长度"><a href="#面试题5-需要排序的最短子数组长度" class="headerlink" title="面试题5.  需要排序的最短子数组长度"></a>面试题5.  需要排序的最短子数组长度</h5><h5 id="面试题6-在数组中找到出现次数大于N-K的数"><a href="#面试题6-在数组中找到出现次数大于N-K的数" class="headerlink" title="面试题6.  在数组中找到出现次数大于N/K的数"></a>面试题6.  在数组中找到出现次数大于N/K的数</h5><h5 id="面试题7-在行列都排好序的矩阵中找指定数"><a href="#面试题7-在行列都排好序的矩阵中找指定数" class="headerlink" title="面试题7.  在行列都排好序的矩阵中找指定数"></a>面试题7.  在行列都排好序的矩阵中找指定数</h5><h5 id="面试题8-最长的可整合子数组的长度"><a href="#面试题8-最长的可整合子数组的长度" class="headerlink" title="面试题8.  最长的可整合子数组的长度"></a>面试题8.  最长的可整合子数组的长度</h5><h5 id="面试题9-不重复打印排序数组中相加和为给定值的所有二元组和三元组"><a href="#面试题9-不重复打印排序数组中相加和为给定值的所有二元组和三元组" class="headerlink" title="面试题9.  不重复打印排序数组中相加和为给定值的所有二元组和三元组"></a>面试题9.  不重复打印排序数组中相加和为给定值的所有二元组和三元组</h5><h5 id="面试题10-未排序正数数组中累加和为给定值的最长子数组长度"><a href="#面试题10-未排序正数数组中累加和为给定值的最长子数组长度" class="headerlink" title="面试题10. 未排序正数数组中累加和为给定值的最长子数组长度"></a>面试题10. 未排序正数数组中累加和为给定值的最长子数组长度</h5><h5 id="面试题11-未排序数组中累加和为给定值的最长子数组系列问题"><a href="#面试题11-未排序数组中累加和为给定值的最长子数组系列问题" class="headerlink" title="面试题11.  未排序数组中累加和为给定值的最长子数组系列问题"></a>面试题11.  未排序数组中累加和为给定值的最长子数组系列问题</h5><h5 id="面试题12-未排序数组中累加和小于或等于给定值的最长子数组长度"><a href="#面试题12-未排序数组中累加和小于或等于给定值的最长子数组长度" class="headerlink" title="面试题12.  未排序数组中累加和小于或等于给定值的最长子数组长度"></a>面试题12.  未排序数组中累加和小于或等于给定值的最长子数组长度</h5><h5 id="面试题13-计算数组的小和"><a href="#面试题13-计算数组的小和" class="headerlink" title="面试题13.  计算数组的小和"></a>面试题13.  计算数组的小和</h5><h5 id="面试题14-自然数数组的排序"><a href="#面试题14-自然数数组的排序" class="headerlink" title="面试题14.  自然数数组的排序"></a>面试题14.  自然数数组的排序</h5><h5 id="面试题15-奇数下标都是奇数或者偶数下标都是偶数"><a href="#面试题15-奇数下标都是奇数或者偶数下标都是偶数" class="headerlink" title="面试题15.  奇数下标都是奇数或者偶数下标都是偶数"></a>面试题15.  奇数下标都是奇数或者偶数下标都是偶数</h5><h5 id="面试题16-子数组的最大累加和问题"><a href="#面试题16-子数组的最大累加和问题" class="headerlink" title="面试题16.  子数组的最大累加和问题"></a>面试题16.  子数组的最大累加和问题</h5><h5 id="面试题17-子矩阵的最大累加和问题"><a href="#面试题17-子矩阵的最大累加和问题" class="headerlink" title="面试题17.  子矩阵的最大累加和问题"></a>面试题17.  子矩阵的最大累加和问题</h5><h5 id="面试题18-在数组中找到一个局部最小的位置"><a href="#面试题18-在数组中找到一个局部最小的位置" class="headerlink" title="面试题18.  在数组中找到一个局部最小的位置"></a>面试题18.  在数组中找到一个局部最小的位置</h5><h5 id="面试题19-数组中子数组的最大累乘积"><a href="#面试题19-数组中子数组的最大累乘积" class="headerlink" title="面试题19.  数组中子数组的最大累乘积"></a>面试题19.  数组中子数组的最大累乘积</h5><h5 id="面试题20-打印N个数组整体最大的Top-K"><a href="#面试题20-打印N个数组整体最大的Top-K" class="headerlink" title="面试题20.  打印N个数组整体最大的Top  K"></a>面试题20.  打印N个数组整体最大的Top  K</h5><h5 id="面试题21-边界都是1的最大正方形大小"><a href="#面试题21-边界都是1的最大正方形大小" class="headerlink" title="面试题21.  边界都是1的最大正方形大小"></a>面试题21.  边界都是1的最大正方形大小</h5><h5 id="面试题22-不包含本位置值的累乘数组"><a href="#面试题22-不包含本位置值的累乘数组" class="headerlink" title="面试题22.  不包含本位置值的累乘数组"></a>面试题22.  不包含本位置值的累乘数组</h5><h5 id="面试题23-数组的partition调整"><a href="#面试题23-数组的partition调整" class="headerlink" title="面试题23.  数组的partition调整"></a>面试题23.  数组的partition调整</h5><h5 id="面试题24-求最短通路值"><a href="#面试题24-求最短通路值" class="headerlink" title="面试题24.  求最短通路值"></a>面试题24.  求最短通路值</h5><h5 id="面试题25-数组中未出现的最小正整数"><a href="#面试题25-数组中未出现的最小正整数" class="headerlink" title="面试题25. 数组中未出现的最小正整数"></a>面试题25. 数组中未出现的最小正整数</h5><h5 id="面试题26-数组排序之后相邻数的最大差值"><a href="#面试题26-数组排序之后相邻数的最大差值" class="headerlink" title="面试题26.  数组排序之后相邻数的最大差值"></a>面试题26.  数组排序之后相邻数的最大差值</h5><h5 id="面试题27-做项目的最大收益问题"><a href="#面试题27-做项目的最大收益问题" class="headerlink" title="面试题27.  做项目的最大收益问题"></a>面试题27.  做项目的最大收益问题</h5><h5 id="面试题28-分金条的最小花费"><a href="#面试题28-分金条的最小花费" class="headerlink" title="面试题28.  分金条的最小花费"></a>面试题28.  分金条的最小花费</h5><h5 id="面试题29-大楼轮廓问题"><a href="#面试题29-大楼轮廓问题" class="headerlink" title="面试题29.  大楼轮廓问题"></a>面试题29.  大楼轮廓问题</h5><h5 id="面试题30-加油站良好出发点问题"><a href="#面试题30-加油站良好出发点问题" class="headerlink" title="面试题30.  加油站良好出发点问题"></a>面试题30.  加油站良好出发点问题</h5><h5 id="面试题31-容器盛水问题"><a href="#面试题31-容器盛水问题" class="headerlink" title="面试题31.  容器盛水问题"></a>面试题31.  容器盛水问题</h5><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="面试题1-从5随机到7随机及其扩展"><a href="#面试题1-从5随机到7随机及其扩展" class="headerlink" title="面试题1.  从5随机到7随机及其扩展"></a>面试题1.  从5随机到7随机及其扩展</h5><h5 id="面试题2-一行代码求两个数的最大公约数"><a href="#面试题2-一行代码求两个数的最大公约数" class="headerlink" title="面试题2.  一行代码求两个数的最大公约数"></a>面试题2.  一行代码求两个数的最大公约数</h5><h5 id="面试题3-有关阶乘的两个问题"><a href="#面试题3-有关阶乘的两个问题" class="headerlink" title="面试题3.  有关阶乘的两个问题"></a>面试题3.  有关阶乘的两个问题</h5><h5 id="面试题4-判断一个点是否在矩形内部"><a href="#面试题4-判断一个点是否在矩形内部" class="headerlink" title="面试题4.  判断一个点是否在矩形内部"></a>面试题4.  判断一个点是否在矩形内部</h5><h5 id="面试题5-判断一个点是否在三角形内部"><a href="#面试题5-判断一个点是否在三角形内部" class="headerlink" title="面试题5.  判断一个点是否在三角形内部"></a>面试题5.  判断一个点是否在三角形内部</h5><h5 id="面试题6-折纸问题"><a href="#面试题6-折纸问题" class="headerlink" title="面试题6.  折纸问题"></a>面试题6.  折纸问题</h5><h5 id="面试题7-能否完美地拼成矩形"><a href="#面试题7-能否完美地拼成矩形" class="headerlink" title="面试题7.  能否完美地拼成矩形"></a>面试题7.  能否完美地拼成矩形</h5><h5 id="面试题8-蓄水池算法"><a href="#面试题8-蓄水池算法" class="headerlink" title="面试题8.  蓄水池算法"></a>面试题8.  蓄水池算法</h5><h5 id="面试题9-设计有-setAll-功能的哈希表"><a href="#面试题9-设计有-setAll-功能的哈希表" class="headerlink" title="面试题9.  设计有 setAll 功能的哈希表"></a>面试题9.  设计有 setAll 功能的哈希表</h5><h5 id="面试题10-最大的-leftMax-与-rightMax-之差的绝对值"><a href="#面试题10-最大的-leftMax-与-rightMax-之差的绝对值" class="headerlink" title="面试题10.  最大的 leftMax 与 rightMax 之差的绝对值"></a>面试题10.  最大的 leftMax 与 rightMax 之差的绝对值</h5><h5 id="面试题11-设计LRU缓存结构"><a href="#面试题11-设计LRU缓存结构" class="headerlink" title="面试题11.  设计LRU缓存结构"></a>面试题11.  设计LRU缓存结构</h5><h5 id="面试题12-LFU缓存结构设计"><a href="#面试题12-LFU缓存结构设计" class="headerlink" title="面试题12.  LFU缓存结构设计"></a>面试题12.  LFU缓存结构设计</h5><h5 id="面试题13-设计-RandomPool-结构"><a href="#面试题13-设计-RandomPool-结构" class="headerlink" title="面试题13.  设计 RandomPool 结构"></a>面试题13.  设计 RandomPool 结构</h5><h5 id="面试题14-并查集的实现"><a href="#面试题14-并查集的实现" class="headerlink" title="面试题14.  并查集的实现"></a>面试题14.  并查集的实现</h5><h5 id="面试题15-调整-0-x-区间上的数出现的概率"><a href="#面试题15-调整-0-x-区间上的数出现的概率" class="headerlink" title="面试题15.  调整[0,x)区间上的数出现的概率"></a>面试题15.  调整[0,x)区间上的数出现的概率</h5><h5 id="面试题16-路径数组变为统计数组"><a href="#面试题16-路径数组变为统计数组" class="headerlink" title="面试题16.  路径数组变为统计数组"></a>面试题16.  路径数组变为统计数组</h5><h5 id="面试题17-正数数组的最小不可组成和"><a href="#面试题17-正数数组的最小不可组成和" class="headerlink" title="面试题17.  正数数组的最小不可组成和"></a>面试题17.  正数数组的最小不可组成和</h5><h5 id="面试题18-累加出整个范围所有的数最少还需几个数"><a href="#面试题18-累加出整个范围所有的数最少还需几个数" class="headerlink" title="面试题18.  累加出整个范围所有的数最少还需几个数"></a>面试题18.  累加出整个范围所有的数最少还需几个数</h5><h5 id="面试题19-一种字符串和数字的对应关系"><a href="#面试题19-一种字符串和数字的对应关系" class="headerlink" title="面试题19.  一种字符串和数字的对应关系"></a>面试题19.  一种字符串和数字的对应关系</h5><h5 id="面试题20-1到n中1出现的次数"><a href="#面试题20-1到n中1出现的次数" class="headerlink" title="面试题20.  1到n中1出现的次数"></a>面试题20.  1到n中1出现的次数</h5><h5 id="面试题21-从N个数中等概率打印M个数"><a href="#面试题21-从N个数中等概率打印M个数" class="headerlink" title="面试题21.  从N个数中等概率打印M个数"></a>面试题21.  从N个数中等概率打印M个数</h5><h5 id="面试题22-判断一个数是否是回文数"><a href="#面试题22-判断一个数是否是回文数" class="headerlink" title="面试题22.  判断一个数是否是回文数"></a>面试题22.  判断一个数是否是回文数</h5><h5 id="面试题23-在有序旋转数组中找到最小值"><a href="#面试题23-在有序旋转数组中找到最小值" class="headerlink" title="面试题23.  在有序旋转数组中找到最小值"></a>面试题23.  在有序旋转数组中找到最小值</h5><h5 id="面试题24-在有序旋转数组中找到一个数"><a href="#面试题24-在有序旋转数组中找到一个数" class="headerlink" title="面试题24.  在有序旋转数组中找到一个数"></a>面试题24.  在有序旋转数组中找到一个数</h5><h5 id="面试题25-数字的英文表达和中文表达"><a href="#面试题25-数字的英文表达和中文表达" class="headerlink" title="面试题25.  数字的英文表达和中文表达"></a>面试题25.  数字的英文表达和中文表达</h5><h5 id="面试题26-分糖果问题"><a href="#面试题26-分糖果问题" class="headerlink" title="面试题26.  分糖果问题"></a>面试题26.  分糖果问题</h5><h5 id="面试题27-一种消息接收并打印的结构设计"><a href="#面试题27-一种消息接收并打印的结构设计" class="headerlink" title="面试题27.  一种消息接收并打印的结构设计"></a>面试题27.  一种消息接收并打印的结构设计</h5><h5 id="面试题28-随时找到数据流的中位数"><a href="#面试题28-随时找到数据流的中位数" class="headerlink" title="面试题28.  随时找到数据流的中位数"></a>面试题28.  随时找到数据流的中位数</h5><h5 id="面试题29-在两个长度相等的排序数组中找到上中位数"><a href="#面试题29-在两个长度相等的排序数组中找到上中位数" class="headerlink" title="面试题29.  在两个长度相等的排序数组中找到上中位数"></a>面试题29.  在两个长度相等的排序数组中找到上中位数</h5><h5 id="面试题30-在两个排序数组中找到第k小的数"><a href="#面试题30-在两个排序数组中找到第k小的数" class="headerlink" title="面试题30.  在两个排序数组中找到第k小的数"></a>面试题30.  在两个排序数组中找到第k小的数</h5><h5 id="面试题31-两个有序数组间相加和的Top-k问题"><a href="#面试题31-两个有序数组间相加和的Top-k问题" class="headerlink" title="面试题31.  两个有序数组间相加和的Top  k问题"></a>面试题31.  两个有序数组间相加和的Top  k问题</h5><h5 id="面试题32-出现次数的Top-k问题"><a href="#面试题32-出现次数的Top-k问题" class="headerlink" title="面试题32.  出现次数的Top  k问题"></a>面试题32.  出现次数的Top  k问题</h5><h5 id="面试题33-Manacher-算法"><a href="#面试题33-Manacher-算法" class="headerlink" title="面试题33.  Manacher 算法"></a>面试题33.  Manacher 算法</h5><h5 id="面试题34-KMP算法"><a href="#面试题34-KMP算法" class="headerlink" title="面试题34.  KMP算法"></a>面试题34.  KMP算法</h5><h5 id="面试题35-丢棋子问题"><a href="#面试题35-丢棋子问题" class="headerlink" title="面试题35.  丢棋子问题"></a>面试题35.  丢棋子问题</h5><h5 id="面试题36-画匠问题"><a href="#面试题36-画匠问题" class="headerlink" title="面试题36.  画匠问题"></a>面试题36.  画匠问题</h5><h5 id="面试题37-邮局选址问题"><a href="#面试题37-邮局选址问题" class="headerlink" title="面试题37. 邮局选址问题"></a>面试题37. 邮局选址问题</h5>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法与数据结构——程序员代码面试指南/" rel="tag"># 算法与数据结构——程序员代码面试指南</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/29/算法面试题/" rel="next" title="算法面试题">
                <i class="fa fa-chevron-left"></i> 算法面试题
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/01/找工作/" rel="prev" title="找工作">
                找工作 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="木木">
            
              <p class="site-author-name" itemprop="name">木木</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#小知识点"><span class="nav-number">1.</span> <span class="nav-text">小知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#异或运算"><span class="nav-number">1.1.</span> <span class="nav-text">异或运算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#求中点"><span class="nav-number">1.2.</span> <span class="nav-text">求中点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#递归行为时间复杂度"><span class="nav-number">1.3.</span> <span class="nav-text">递归行为时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序算法"><span class="nav-number">2.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#选择排序"><span class="nav-number">2.1.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#冒泡排序"><span class="nav-number">2.2.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#插入排序"><span class="nav-number">2.3.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二分法"><span class="nav-number">2.4.</span> <span class="nav-text">二分法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#归并排序"><span class="nav-number">2.5.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#堆排序"><span class="nav-number">2.6.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#快速排序"><span class="nav-number">2.7.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#桶排序"><span class="nav-number">2.8.</span> <span class="nav-text">桶排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈和队列"><span class="nav-number">3.</span> <span class="nav-text">栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1：设计一个有-getMin-功能的栈"><span class="nav-number">3.1.</span> <span class="nav-text">面试题1：设计一个有 getMin 功能的栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2：由两个栈组成的队列"><span class="nav-number">3.2.</span> <span class="nav-text">面试题2：由两个栈组成的队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3：如何仅用递归函数和栈操作逆序一个栈"><span class="nav-number">3.3.</span> <span class="nav-text">面试题3：如何仅用递归函数和栈操作逆序一个栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4：猫狗队列"><span class="nav-number">3.4.</span> <span class="nav-text">面试题4：猫狗队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5：用一个栈实现另一个栈的排序"><span class="nav-number">3.5.</span> <span class="nav-text">面试题5：用一个栈实现另一个栈的排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6：用栈来解决汉诺塔问题"><span class="nav-number">3.6.</span> <span class="nav-text">面试题6：用栈来解决汉诺塔问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7：生成窗口最大值数组"><span class="nav-number">3.7.</span> <span class="nav-text">面试题7：生成窗口最大值数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题8：单调栈结构"><span class="nav-number">3.8.</span> <span class="nav-text">面试题8：单调栈结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题9：求最大子矩阵的大小"><span class="nav-number">3.9.</span> <span class="nav-text">面试题9：求最大子矩阵的大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题10：最大值减去最小值小于或等于-num-的子数组数量"><span class="nav-number">3.10.</span> <span class="nav-text">面试题10：最大值减去最小值小于或等于 num 的子数组数量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题11：可见的山峰对数量"><span class="nav-number">3.11.</span> <span class="nav-text">面试题11：可见的山峰对数量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链表"><span class="nav-number">4.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1：打印两个有序链表的公共部分"><span class="nav-number">4.1.</span> <span class="nav-text">面试题1：打印两个有序链表的公共部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2：在单链表和双链表中删除倒数第-k-个节点"><span class="nav-number">4.2.</span> <span class="nav-text">面试题2：在单链表和双链表中删除倒数第 k 个节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3：删除链表的中间节点和-a-b-处的节点"><span class="nav-number">4.3.</span> <span class="nav-text">面试题3：删除链表的中间节点和 a/b 处的节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4：反转单向和双向链表"><span class="nav-number">4.4.</span> <span class="nav-text">面试题4：反转单向和双向链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5：反转部分单向链表"><span class="nav-number">4.5.</span> <span class="nav-text">面试题5：反转部分单向链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6：环形单链表的约瑟夫问题"><span class="nav-number">4.6.</span> <span class="nav-text">面试题6：环形单链表的约瑟夫问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7：判断一个链表是否为回文结构"><span class="nav-number">4.7.</span> <span class="nav-text">面试题7：判断一个链表是否为回文结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式"><span class="nav-number">4.8.</span> <span class="nav-text">面试题8：将单向链表按某值划分成左边小、中间相等、右边大的形式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题9：复制含有随机指针节点的链表"><span class="nav-number">4.9.</span> <span class="nav-text">面试题9：复制含有随机指针节点的链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题10：两个单链表生成相加链表"><span class="nav-number">4.10.</span> <span class="nav-text">面试题10：两个单链表生成相加链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题11：两个单链表相交的一系列问题"><span class="nav-number">4.11.</span> <span class="nav-text">面试题11：两个单链表相交的一系列问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题12：将单链表的每-K-个节点之间逆序"><span class="nav-number">4.12.</span> <span class="nav-text">面试题12：将单链表的每 K 个节点之间逆序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题13：删除无序单链表中值重复出现的节点"><span class="nav-number">4.13.</span> <span class="nav-text">面试题13：删除无序单链表中值重复出现的节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题14：在单链表中删除指定值的节点"><span class="nav-number">4.14.</span> <span class="nav-text">面试题14：在单链表中删除指定值的节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题15：将搜索二叉树转换成双向链表"><span class="nav-number">4.15.</span> <span class="nav-text">面试题15：将搜索二叉树转换成双向链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题16：单链表的选择排序"><span class="nav-number">4.16.</span> <span class="nav-text">面试题16：单链表的选择排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题17：一种怪异的节点删除方式"><span class="nav-number">4.17.</span> <span class="nav-text">面试题17：一种怪异的节点删除方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题18：向有序的环形单链表中插入新节点"><span class="nav-number">4.18.</span> <span class="nav-text">面试题18：向有序的环形单链表中插入新节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题19：合并两个有序的单链表"><span class="nav-number">4.19.</span> <span class="nav-text">面试题19：合并两个有序的单链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题20：按照左右半区的方式重新组合单链表"><span class="nav-number">4.20.</span> <span class="nav-text">面试题20：按照左右半区的方式重新组合单链表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树"><span class="nav-number">5.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历"><span class="nav-number">5.1.</span> <span class="nav-text">面试题1：分别用递归和非递归方式实现二叉树先序、中序和后序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2：打印二叉树的边界节点"><span class="nav-number">5.2.</span> <span class="nav-text">面试题2：打印二叉树的边界节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3：如何较为直观地打印二叉树"><span class="nav-number">5.3.</span> <span class="nav-text">面试题3：如何较为直观地打印二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4：二叉树地序列化和反序列化"><span class="nav-number">5.4.</span> <span class="nav-text">面试题4：二叉树地序列化和反序列化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5：遍历二叉树地神级方法"><span class="nav-number">5.5.</span> <span class="nav-text">面试题5：遍历二叉树地神级方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6：在二叉树中找到累加和为指定值地最长路径长度"><span class="nav-number">5.6.</span> <span class="nav-text">面试题6：在二叉树中找到累加和为指定值地最长路径长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7：找到二叉树中最大搜索二叉子数"><span class="nav-number">5.7.</span> <span class="nav-text">面试题7：找到二叉树中最大搜索二叉子数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构"><span class="nav-number">5.8.</span> <span class="nav-text">面试题8：找到二叉树中符合搜索二叉树条件地最大拓扑结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题9：二叉树的按层打印预-ZigZag-打印"><span class="nav-number">5.9.</span> <span class="nav-text">面试题9：二叉树的按层打印预 ZigZag 打印</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题10：调整搜索二叉树中两个错误的节点"><span class="nav-number">5.10.</span> <span class="nav-text">面试题10：调整搜索二叉树中两个错误的节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题11：判断-t1-树是否包含-t2-树全部的拓扑结构"><span class="nav-number">5.11.</span> <span class="nav-text">面试题11：判断 t1 树是否包含 t2 树全部的拓扑结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题12：判断-t1-树中是否有与-t2-树拓扑结构完全相同的子数"><span class="nav-number">5.12.</span> <span class="nav-text">面试题12：判断 t1 树中是否有与 t2 树拓扑结构完全相同的子数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题13：判断二叉树是否为平衡二叉树"><span class="nav-number">5.13.</span> <span class="nav-text">面试题13：判断二叉树是否为平衡二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题14：根据后序数组重建搜索二叉树"><span class="nav-number">5.14.</span> <span class="nav-text">面试题14：根据后序数组重建搜索二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树"><span class="nav-number">5.15.</span> <span class="nav-text">面试题15：判断一棵二叉树是否为搜索二叉树和完全二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题16：通过有序数组生成平衡搜索二叉树"><span class="nav-number">5.16.</span> <span class="nav-text">面试题16：通过有序数组生成平衡搜索二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题17：在二叉树中找到一个节点的后继节点"><span class="nav-number">5.17.</span> <span class="nav-text">面试题17：在二叉树中找到一个节点的后继节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题18：在二叉树中找到两个节点的最低公共祖先"><span class="nav-number">5.18.</span> <span class="nav-text">面试题18：在二叉树中找到两个节点的最低公共祖先</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题19：Tarjan-算法与并查集解决二叉树节点间最低公共祖先的批量查询问题"><span class="nav-number">5.19.</span> <span class="nav-text">面试题19：Tarjan 算法与并查集解决二叉树节点间最低公共祖先的批量查询问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题20：二叉树节点间的最大距离问题"><span class="nav-number">5.20.</span> <span class="nav-text">面试题20：二叉树节点间的最大距离问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题21：派对的最大快乐值"><span class="nav-number">5.21.</span> <span class="nav-text">面试题21：派对的最大快乐值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题22：通过先序和中序数组生成后序数组"><span class="nav-number">5.22.</span> <span class="nav-text">面试题22：通过先序和中序数组生成后序数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题23：统计和生成所有不同的二叉树"><span class="nav-number">5.23.</span> <span class="nav-text">面试题23：统计和生成所有不同的二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题24：统计完全二叉树的节点树"><span class="nav-number">5.24.</span> <span class="nav-text">面试题24：统计完全二叉树的节点树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归和动态规划"><span class="nav-number">6.</span> <span class="nav-text">递归和动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1：斐波那契数列问题的递归和动态规划"><span class="nav-number">6.1.</span> <span class="nav-text">面试题1：斐波那契数列问题的递归和动态规划</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2：矩阵的最小路径和"><span class="nav-number">6.2.</span> <span class="nav-text">面试题2：矩阵的最小路径和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3：换钱的最少货币数"><span class="nav-number">6.3.</span> <span class="nav-text">面试题3：换钱的最少货币数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4：机器人达到指定位置方法数"><span class="nav-number">6.4.</span> <span class="nav-text">面试题4：机器人达到指定位置方法数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5：换钱的方法数"><span class="nav-number">6.5.</span> <span class="nav-text">面试题5：换钱的方法数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6：打气球的最大分数"><span class="nav-number">6.6.</span> <span class="nav-text">面试题6：打气球的最大分数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7：最长递增子序列"><span class="nav-number">6.7.</span> <span class="nav-text">面试题7：最长递增子序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题8：信封嵌套问题"><span class="nav-number">6.8.</span> <span class="nav-text">面试题8：信封嵌套问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题9：汉诺塔问题"><span class="nav-number">6.9.</span> <span class="nav-text">面试题9：汉诺塔问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题10：最长公共子序列问题"><span class="nav-number">6.10.</span> <span class="nav-text">面试题10：最长公共子序列问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题11：最长公共子串问题"><span class="nav-number">6.11.</span> <span class="nav-text">面试题11：最长公共子串问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题12：子数组异或和为0的最多划分"><span class="nav-number">6.12.</span> <span class="nav-text">面试题12：子数组异或和为0的最多划分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题13：最小编辑代价"><span class="nav-number">6.13.</span> <span class="nav-text">面试题13：最小编辑代价</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题14：字符串的交错组成"><span class="nav-number">6.14.</span> <span class="nav-text">面试题14：字符串的交错组成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题15：龙与地下城游戏问题"><span class="nav-number">6.15.</span> <span class="nav-text">面试题15：龙与地下城游戏问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题16：数字字符串转换为字符组合的种数"><span class="nav-number">6.16.</span> <span class="nav-text">面试题16：数字字符串转换为字符组合的种数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题17：表达式得到期望结果的组成种树"><span class="nav-number">6.17.</span> <span class="nav-text">面试题17：表达式得到期望结果的组成种树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题18：排成一条线的纸牌博弈问题"><span class="nav-number">6.18.</span> <span class="nav-text">面试题18：排成一条线的纸牌博弈问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题19：跳跃游戏"><span class="nav-number">6.19.</span> <span class="nav-text">面试题19：跳跃游戏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题20：数组中的最长连续序列"><span class="nav-number">6.20.</span> <span class="nav-text">面试题20：数组中的最长连续序列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题21：N-皇后问题"><span class="nav-number">6.21.</span> <span class="nav-text">面试题21：N 皇后问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串"><span class="nav-number">7.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1：判断两个字符串是否互为变形词"><span class="nav-number">7.1.</span> <span class="nav-text">面试题1：判断两个字符串是否互为变形词</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2：判断两个字符串是否互为旋转词"><span class="nav-number">7.2.</span> <span class="nav-text">面试题2：判断两个字符串是否互为旋转词</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3：字符串中统计字符串"><span class="nav-number">7.3.</span> <span class="nav-text">面试题3：字符串中统计字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4：判断字符数组中是否所有的字符都只出现过一次"><span class="nav-number">7.4.</span> <span class="nav-text">面试题4：判断字符数组中是否所有的字符都只出现过一次</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5：在有序但包含空数组中查找字符串"><span class="nav-number">7.5.</span> <span class="nav-text">面试题5：在有序但包含空数组中查找字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6：字符串的调整与替换"><span class="nav-number">7.6.</span> <span class="nav-text">面试题6：字符串的调整与替换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7：翻转字符串"><span class="nav-number">7.7.</span> <span class="nav-text">面试题7：翻转字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题8：完美洗牌问题"><span class="nav-number">7.8.</span> <span class="nav-text">面试题8：完美洗牌问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题9：删除多余字符得到字典序最小的字符串"><span class="nav-number">7.9.</span> <span class="nav-text">面试题9：删除多余字符得到字典序最小的字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题10：数组中两个字符串的最小距离"><span class="nav-number">7.10.</span> <span class="nav-text">面试题10：数组中两个字符串的最小距离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题11：字符串的转换路径问题"><span class="nav-number">7.11.</span> <span class="nav-text">面试题11：字符串的转换路径问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题12：添加最少字符使字符串整体都是回文字符串"><span class="nav-number">7.12.</span> <span class="nav-text">面试题12：添加最少字符使字符串整体都是回文字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题13：括号字符串的有效性和最长有效长度"><span class="nav-number">7.13.</span> <span class="nav-text">面试题13：括号字符串的有效性和最长有效长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题14：公司字符串求值"><span class="nav-number">7.14.</span> <span class="nav-text">面试题14：公司字符串求值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题15：0-左边必有-1-的二进制字符串数量"><span class="nav-number">7.15.</span> <span class="nav-text">面试题15：0 左边必有 1 的二进制字符串数量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题16：拼接所有字符串产生字典顺序最小的大写字符串"><span class="nav-number">7.16.</span> <span class="nav-text">面试题16：拼接所有字符串产生字典顺序最小的大写字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题17：找到字符串的最长无重复字符子串"><span class="nav-number">7.17.</span> <span class="nav-text">面试题17：找到字符串的最长无重复字符子串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题18：找到指定的新类型字符"><span class="nav-number">7.18.</span> <span class="nav-text">面试题18：找到指定的新类型字符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题19：旋变字符串问题"><span class="nav-number">7.19.</span> <span class="nav-text">面试题19：旋变字符串问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题20：最小包含子串的长度"><span class="nav-number">7.20.</span> <span class="nav-text">面试题20：最小包含子串的长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题21：回文最少分割数"><span class="nav-number">7.21.</span> <span class="nav-text">面试题21：回文最少分割数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题22：字符串匹配问题"><span class="nav-number">7.22.</span> <span class="nav-text">面试题22：字符串匹配问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题23：字典树（前缀树）的实现"><span class="nav-number">7.23.</span> <span class="nav-text">面试题23：字典树（前缀树）的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题24：子数组的最大异或和"><span class="nav-number">7.24.</span> <span class="nav-text">面试题24：子数组的最大异或和</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#大数据和空间限制"><span class="nav-number">8.</span> <span class="nav-text">大数据和空间限制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1-认识布隆过滤器"><span class="nav-number">8.1.</span> <span class="nav-text">面试题1.  认识布隆过滤器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2-只用2GB内存在20亿个整数中找到出现次数最多的数"><span class="nav-number">8.2.</span> <span class="nav-text">面试题2.  只用2GB内存在20亿个整数中找到出现次数最多的数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3-40亿个非负整数中找到未出现的数"><span class="nav-number">8.3.</span> <span class="nav-text">面试题3.  40亿个非负整数中找到未出现的数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4-找到100亿个URL中重复的URL及搜索词汇的Top-K问题"><span class="nav-number">8.4.</span> <span class="nav-text">面试题4.  找到100亿个URL中重复的URL及搜索词汇的Top  K问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5-40亿个非负整数中找到出现两次的数和所有数的中位数（"><span class="nav-number">8.5.</span> <span class="nav-text">面试题5.  40亿个非负整数中找到出现两次的数和所有数的中位数（</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6-一致性哈希算法的基本原理"><span class="nav-number">8.6.</span> <span class="nav-text">面试题6.  一致性哈希算法的基本原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7-岛问题"><span class="nav-number">8.7.</span> <span class="nav-text">面试题7.  岛问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#位运算"><span class="nav-number">9.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1-不用额外变量交换两个整数的值"><span class="nav-number">9.1.</span> <span class="nav-text">面试题1.  不用额外变量交换两个整数的值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2-不用做任何比较判断找出两个数中较大的数"><span class="nav-number">9.2.</span> <span class="nav-text">面试题2.  不用做任何比较判断找出两个数中较大的数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3-只用位运算不用算术运算实现整数的加减乘除运算（"><span class="nav-number">9.3.</span> <span class="nav-text">面试题3.  只用位运算不用算术运算实现整数的加减乘除运算（</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4-整数的二进制数表达中有多少个1"><span class="nav-number">9.4.</span> <span class="nav-text">面试题4. 整数的二进制数表达中有多少个1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5-在其他数都出现偶数次的数组中找到出现奇数次的数（"><span class="nav-number">9.5.</span> <span class="nav-text">面试题5.  在其他数都出现偶数次的数组中找到出现奇数次的数（</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6-在其他数都出现k次的数组中找到只出现一次的数"><span class="nav-number">9.6.</span> <span class="nav-text">面试题6.  在其他数都出现k次的数组中找到只出现一次的数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组和矩阵"><span class="nav-number">10.</span> <span class="nav-text">数组和矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1-转圈打印矩阵"><span class="nav-number">10.1.</span> <span class="nav-text">面试题1.  转圈打印矩阵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2-将正方形矩阵顺时针转动90°"><span class="nav-number">10.2.</span> <span class="nav-text">面试题2.  将正方形矩阵顺时针转动90°</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3-“之”字形打印矩阵"><span class="nav-number">10.3.</span> <span class="nav-text">面试题3.  “之”字形打印矩阵</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4-找到无序数组中最小的k个数（O-Nlogk-的方法"><span class="nav-number">10.4.</span> <span class="nav-text">面试题4.   找到无序数组中最小的k个数（O(Nlogk)的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5-需要排序的最短子数组长度"><span class="nav-number">10.5.</span> <span class="nav-text">面试题5.  需要排序的最短子数组长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6-在数组中找到出现次数大于N-K的数"><span class="nav-number">10.6.</span> <span class="nav-text">面试题6.  在数组中找到出现次数大于N/K的数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7-在行列都排好序的矩阵中找指定数"><span class="nav-number">10.7.</span> <span class="nav-text">面试题7.  在行列都排好序的矩阵中找指定数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题8-最长的可整合子数组的长度"><span class="nav-number">10.8.</span> <span class="nav-text">面试题8.  最长的可整合子数组的长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题9-不重复打印排序数组中相加和为给定值的所有二元组和三元组"><span class="nav-number">10.9.</span> <span class="nav-text">面试题9.  不重复打印排序数组中相加和为给定值的所有二元组和三元组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题10-未排序正数数组中累加和为给定值的最长子数组长度"><span class="nav-number">10.10.</span> <span class="nav-text">面试题10. 未排序正数数组中累加和为给定值的最长子数组长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题11-未排序数组中累加和为给定值的最长子数组系列问题"><span class="nav-number">10.11.</span> <span class="nav-text">面试题11.  未排序数组中累加和为给定值的最长子数组系列问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题12-未排序数组中累加和小于或等于给定值的最长子数组长度"><span class="nav-number">10.12.</span> <span class="nav-text">面试题12.  未排序数组中累加和小于或等于给定值的最长子数组长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题13-计算数组的小和"><span class="nav-number">10.13.</span> <span class="nav-text">面试题13.  计算数组的小和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题14-自然数数组的排序"><span class="nav-number">10.14.</span> <span class="nav-text">面试题14.  自然数数组的排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题15-奇数下标都是奇数或者偶数下标都是偶数"><span class="nav-number">10.15.</span> <span class="nav-text">面试题15.  奇数下标都是奇数或者偶数下标都是偶数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题16-子数组的最大累加和问题"><span class="nav-number">10.16.</span> <span class="nav-text">面试题16.  子数组的最大累加和问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题17-子矩阵的最大累加和问题"><span class="nav-number">10.17.</span> <span class="nav-text">面试题17.  子矩阵的最大累加和问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题18-在数组中找到一个局部最小的位置"><span class="nav-number">10.18.</span> <span class="nav-text">面试题18.  在数组中找到一个局部最小的位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题19-数组中子数组的最大累乘积"><span class="nav-number">10.19.</span> <span class="nav-text">面试题19.  数组中子数组的最大累乘积</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题20-打印N个数组整体最大的Top-K"><span class="nav-number">10.20.</span> <span class="nav-text">面试题20.  打印N个数组整体最大的Top  K</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题21-边界都是1的最大正方形大小"><span class="nav-number">10.21.</span> <span class="nav-text">面试题21.  边界都是1的最大正方形大小</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题22-不包含本位置值的累乘数组"><span class="nav-number">10.22.</span> <span class="nav-text">面试题22.  不包含本位置值的累乘数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题23-数组的partition调整"><span class="nav-number">10.23.</span> <span class="nav-text">面试题23.  数组的partition调整</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题24-求最短通路值"><span class="nav-number">10.24.</span> <span class="nav-text">面试题24.  求最短通路值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题25-数组中未出现的最小正整数"><span class="nav-number">10.25.</span> <span class="nav-text">面试题25. 数组中未出现的最小正整数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题26-数组排序之后相邻数的最大差值"><span class="nav-number">10.26.</span> <span class="nav-text">面试题26.  数组排序之后相邻数的最大差值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题27-做项目的最大收益问题"><span class="nav-number">10.27.</span> <span class="nav-text">面试题27.  做项目的最大收益问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题28-分金条的最小花费"><span class="nav-number">10.28.</span> <span class="nav-text">面试题28.  分金条的最小花费</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题29-大楼轮廓问题"><span class="nav-number">10.29.</span> <span class="nav-text">面试题29.  大楼轮廓问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题30-加油站良好出发点问题"><span class="nav-number">10.30.</span> <span class="nav-text">面试题30.  加油站良好出发点问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题31-容器盛水问题"><span class="nav-number">10.31.</span> <span class="nav-text">面试题31.  容器盛水问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他"><span class="nav-number">11.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题1-从5随机到7随机及其扩展"><span class="nav-number">11.1.</span> <span class="nav-text">面试题1.  从5随机到7随机及其扩展</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题2-一行代码求两个数的最大公约数"><span class="nav-number">11.2.</span> <span class="nav-text">面试题2.  一行代码求两个数的最大公约数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题3-有关阶乘的两个问题"><span class="nav-number">11.3.</span> <span class="nav-text">面试题3.  有关阶乘的两个问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题4-判断一个点是否在矩形内部"><span class="nav-number">11.4.</span> <span class="nav-text">面试题4.  判断一个点是否在矩形内部</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题5-判断一个点是否在三角形内部"><span class="nav-number">11.5.</span> <span class="nav-text">面试题5.  判断一个点是否在三角形内部</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题6-折纸问题"><span class="nav-number">11.6.</span> <span class="nav-text">面试题6.  折纸问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题7-能否完美地拼成矩形"><span class="nav-number">11.7.</span> <span class="nav-text">面试题7.  能否完美地拼成矩形</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题8-蓄水池算法"><span class="nav-number">11.8.</span> <span class="nav-text">面试题8.  蓄水池算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题9-设计有-setAll-功能的哈希表"><span class="nav-number">11.9.</span> <span class="nav-text">面试题9.  设计有 setAll 功能的哈希表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题10-最大的-leftMax-与-rightMax-之差的绝对值"><span class="nav-number">11.10.</span> <span class="nav-text">面试题10.  最大的 leftMax 与 rightMax 之差的绝对值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题11-设计LRU缓存结构"><span class="nav-number">11.11.</span> <span class="nav-text">面试题11.  设计LRU缓存结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题12-LFU缓存结构设计"><span class="nav-number">11.12.</span> <span class="nav-text">面试题12.  LFU缓存结构设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题13-设计-RandomPool-结构"><span class="nav-number">11.13.</span> <span class="nav-text">面试题13.  设计 RandomPool 结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题14-并查集的实现"><span class="nav-number">11.14.</span> <span class="nav-text">面试题14.  并查集的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题15-调整-0-x-区间上的数出现的概率"><span class="nav-number">11.15.</span> <span class="nav-text">面试题15.  调整[0,x)区间上的数出现的概率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题16-路径数组变为统计数组"><span class="nav-number">11.16.</span> <span class="nav-text">面试题16.  路径数组变为统计数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题17-正数数组的最小不可组成和"><span class="nav-number">11.17.</span> <span class="nav-text">面试题17.  正数数组的最小不可组成和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题18-累加出整个范围所有的数最少还需几个数"><span class="nav-number">11.18.</span> <span class="nav-text">面试题18.  累加出整个范围所有的数最少还需几个数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题19-一种字符串和数字的对应关系"><span class="nav-number">11.19.</span> <span class="nav-text">面试题19.  一种字符串和数字的对应关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题20-1到n中1出现的次数"><span class="nav-number">11.20.</span> <span class="nav-text">面试题20.  1到n中1出现的次数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题21-从N个数中等概率打印M个数"><span class="nav-number">11.21.</span> <span class="nav-text">面试题21.  从N个数中等概率打印M个数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题22-判断一个数是否是回文数"><span class="nav-number">11.22.</span> <span class="nav-text">面试题22.  判断一个数是否是回文数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题23-在有序旋转数组中找到最小值"><span class="nav-number">11.23.</span> <span class="nav-text">面试题23.  在有序旋转数组中找到最小值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题24-在有序旋转数组中找到一个数"><span class="nav-number">11.24.</span> <span class="nav-text">面试题24.  在有序旋转数组中找到一个数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题25-数字的英文表达和中文表达"><span class="nav-number">11.25.</span> <span class="nav-text">面试题25.  数字的英文表达和中文表达</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题26-分糖果问题"><span class="nav-number">11.26.</span> <span class="nav-text">面试题26.  分糖果问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题27-一种消息接收并打印的结构设计"><span class="nav-number">11.27.</span> <span class="nav-text">面试题27.  一种消息接收并打印的结构设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题28-随时找到数据流的中位数"><span class="nav-number">11.28.</span> <span class="nav-text">面试题28.  随时找到数据流的中位数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题29-在两个长度相等的排序数组中找到上中位数"><span class="nav-number">11.29.</span> <span class="nav-text">面试题29.  在两个长度相等的排序数组中找到上中位数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题30-在两个排序数组中找到第k小的数"><span class="nav-number">11.30.</span> <span class="nav-text">面试题30.  在两个排序数组中找到第k小的数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题31-两个有序数组间相加和的Top-k问题"><span class="nav-number">11.31.</span> <span class="nav-text">面试题31.  两个有序数组间相加和的Top  k问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题32-出现次数的Top-k问题"><span class="nav-number">11.32.</span> <span class="nav-text">面试题32.  出现次数的Top  k问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题33-Manacher-算法"><span class="nav-number">11.33.</span> <span class="nav-text">面试题33.  Manacher 算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题34-KMP算法"><span class="nav-number">11.34.</span> <span class="nav-text">面试题34.  KMP算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题35-丢棋子问题"><span class="nav-number">11.35.</span> <span class="nav-text">面试题35.  丢棋子问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题36-画匠问题"><span class="nav-number">11.36.</span> <span class="nav-text">面试题36.  画匠问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题37-邮局选址问题"><span class="nav-number">11.37.</span> <span class="nav-text">面试题37. 邮局选址问题</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">木木</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
